<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>企业微信第三方打通记录</title>
      <link href="/post/7a2a0c9f.html"/>
      <url>/post/7a2a0c9f.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>企业和客户（B端）进行对接时，往往需要同步客户的组织和成员信息，现在企业大多使用的办公软件有三样：企业微信、钉钉、飞书。现需要对接企业微信，在客户授权企业三方应用时，同步组织和用户信息，方便企业使用</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>企业微信官方提供了<a href="https://developer.work.weixin.qq.com/document/">开发者平台</a>，当然你首先得需要进入一个企业，才可以登录查看开发文档<br><img src="https://image.leidl.top//imgimage-20230314194056845.png" alt="image-20230314194056845"></p><h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><p>简单区分方式：企业和三方比较多，企业自己对自己，三方是别人对自己<br>基于这种背景需求，选择三方开发<br><img src="https://image.leidl.top//imgimage-20230314194739388.png" alt="image-20230314194739388"><br>进入通讯录开发，进入之前建议阅读下<a href="https://developer.work.weixin.qq.com/document/path/91201">开发必读</a><br>了解基本概念及参数</p><h1 id="开发前提"><a href="#开发前提" class="headerlink" title="开发前提"></a>开发前提</h1><p>该需求不是从0开发<br>已经有的</p><ol><li>创建应用</li><li>注册一个测试账号安装了服务商应用（我们的应用）</li><li>通过授权拿到了基本信息（如公司id，秘钥等）</li><li>有这些表示可以直接去请求接口链接</li></ol><h1 id="所需接口"><a href="#所需接口" class="headerlink" title="所需接口"></a>所需接口</h1><p>其实只需要两个接口</p><ol><li><a href="https://developer.work.weixin.qq.com/document/path/90344">获得部门列表</a></li><li><a href="https://developer.work.weixin.qq.com/document/path/90336">获得部门成员</a></li></ol><p>详细步骤官方已经写的很清楚，也不照本宣科了，只说一些关键点和坑点</p><h2 id="获得部门列表"><a href="#获得部门列表" class="headerlink" title="获得部门列表"></a>获得部门列表</h2><ul><li>id参数可以不传，或者传0来获取所有部门信息<br>access_token可以通过官方提供的方式获取，如果根据步骤发现获取不到那就是被加密了，要联系当时搭这个应用的人要</li><li>无法获得部门名称，用id代替名称了</li></ul><h2 id="获得部门成员"><a href="#获得部门成员" class="headerlink" title="获得部门成员"></a>获得部门成员</h2><ul><li>id是必传的</li><li>access_token同上</li><li>无法获得用户名称，同样用id代替名称</li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>现在问题出现了，无法获取到部门名称和用户名称。这个如果不解决，那同步了个寂寞。所以这个问题是一定是要解决的</p><h1 id="方法选择"><a href="#方法选择" class="headerlink" title="方法选择"></a>方法选择</h1><p>官方提供了两个方法，第一个是前端实现，第二个是后端实现<br><img src="https://image.leidl.top//imgimage-20230315120320281.png" alt="image-20230315120320281"><br>但我推荐使用第二个，原因有下</p><ul><li>打通这个需求是后端实现的，不要加别人的工作量</li><li>就算前端实现也是显示解决了问题，存数据库的还是加密的，别的地方用不了，而且前端官方给的SDK还需要进行企业微信授权登录才可以使用</li><li>同步也不只是去企微显示用，可能有多个地方进行了依赖或者显示</li></ul><p>当然第一个比第二个简单，为啥？因为不用你做啊</p><p>所以实现重点就是如图的通讯录ID转译部分<br><img src="https://image.leidl.top//imgimage-20230314203424527.png" alt="image-20230314203424527"></p><h1 id="通讯录转译"><a href="#通讯录转译" class="headerlink" title="通讯录转译"></a>通讯录转译</h1><p><img src="https://image.leidl.top//imgimage-20230314204108507.png" alt="image-20230314204108507"></p><p>先看看官方说的，我当时是理解不了，需要用户那边点击下载把文件给你？</p><p>在看看转译的一个流程<br><img src="https://image.leidl.top//imgimage-20230314204509404.png" alt="image-20230314204509404"></p><p>最终会拿到url来下载这个解密的文件，前提是用户登录？我当时就觉得这个很麻烦，为此还请教了专业人员</p><p><img src="https://image.leidl.top//imgimage-20230314204805893.png" alt="image-20230314204805893"></p><p>我这边想实现的一个效果是当我们点击“同步”的时候完成一系列操作，如果还需要多余的操作就应该考虑是否可以实现全自动化，如果不能，那难点在哪，能不能去解决</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>ps：利用postman走一遍流程，在用代码实现<br>代码实现要逐层递进，保证各个环节单元测试通过</p><h2 id="上传需要转译的文件"><a href="#上传需要转译的文件" class="headerlink" title="上传需要转译的文件"></a>上传需要转译的文件</h2><p>provider_access_token参数与之前的access_token不是同一个token，官方也提供了获取的方法<br>会返回media_id供下一步使用</p><h2 id="异步通讯录id转译"><a href="#异步通讯录id转译" class="headerlink" title="异步通讯录id转译"></a>异步通讯录id转译</h2><p>output_file_name参数可以不要<br>output_file_format参数可以不要<br>会返回job_id供下一步使用</p><h2 id="获取异步任务结果"><a href="#获取异步任务结果" class="headerlink" title="获取异步任务结果"></a>获取异步任务结果</h2><p>url获取大多没什么问题，但下载需要条件，否则如图<br><img src="https://image.leidl.top//imgimage-20230314212333764.png" alt="image-20230314212333764"><br>下载条件：用户通过oauth2授权登录或者单点登录才能进行下载。如果不懂官方说的什么屁话，且听我一言<br>需要客户登录后台（管理员权限）进入应用管理的三方小程序里，在进入服务商后台进行授权<br>第二种，第三方小程序使用企微登录<br><img src="https://image.leidl.top//imgimage-20230316210202511.png" alt="image-20230316210202511"><br>测试小技巧：可以到服务商可信域名所在的网站进行测试（打开F12，自定义href标签插入下载）</p><blockquote><p>需要注意的是，无法通过referer指定可信域名的方式投机取巧，登录态才是最重要的<br><img src="https://image.leidl.top//imga26ef569-c6c9-409c-8753-1605f6dfcc88.png" alt="a26ef569-c6c9-409c-8753-1605f6dfcc88"><br>这表明无法通过一站式的方式解决，需要用户下载文件给到这边进行解密，中转一下才可实现</p></blockquote><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>编程语言Java</p><p>代码参考<br>gitHub（<a href="https://github.com/Wechat-Group/WxJava">WxJava</a>）</p><blockquote><p>微信开发Java SDK包括微信的所有功能，非常强大，从0开发推荐，我不是所以没用</p></blockquote><p>github(<a href="https://github.com/liyuexi/qywx-third-java">qywx-third-java</a>)</p><blockquote><p>企微第三方开发demo，一些方法实现可以参考</p></blockquote><p>转译文件excel格式如下<br><img src="https://image.leidl.top//imgimage-20230315114352905.png" alt="image-20230315114352905"><br>企业id：企业在这边的标识<br>id：这边数据库的主键<br>name：部门/用户名称<br>ps：因为最后这个文件还要拿回来用，每个字段都有其对应的作用</p><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 转译的一个大概流程</span></span><br><span class="line"><span class="comment">  * 为什么是异步？</span></span><br><span class="line"><span class="comment">  * 1. 请求需要多个接口，时间长</span></span><br><span class="line"><span class="comment">  * 2. 解密成功与否不应该影响主流程</span></span><br><span class="line"><span class="comment">  * 3. 成功率不是很高，可能由于文件大未能及时获取结果导致失败</span></span><br><span class="line"><span class="comment">  * 接口请求用到了restTemplate</span></span><br><span class="line"><span class="comment">  * 注意拿结果可能需要轮询获取</span></span><br><span class="line"><span class="comment">  * 这里我推荐使用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferInfo</span><span class="params">(String tenant)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取media_id</span></span><br><span class="line">    String mediaId = getMediaId(tenant);</span><br><span class="line">    <span class="comment">// 获取job_id</span></span><br><span class="line">    String jobId = getJobId(mediaId);</span><br><span class="line">    <span class="comment">// 获取url</span></span><br><span class="line">    String url = getUrl(jobId);</span><br><span class="line">    <span class="comment">// 根据url读取文件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readExcel(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExcelCommonException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;转译失败，未经过oauth2授权登录或者单点登录或者不为可信域名，无法下载该文件&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;未知异常&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getMediaId</span><span class="params">(String tenant)</span> </span>&#123;</span><br><span class="line">    List&lt;WxExcel&gt; excelList = getExcelList(tenant);</span><br><span class="line">    <span class="comment">// 相对路径，例如：/Users/dali/develop/om-auth</span></span><br><span class="line">    String rootPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    String filePath= rootPath + <span class="string">&quot;/wechat&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    EasyExcel.write(filePath, WxExcel.class).sheet(<span class="string">&quot;企业微信转译&quot;</span>).doWrite(excelList);</span><br><span class="line">    <span class="comment">// 获得服务商token</span></span><br><span class="line">    String providerAccessToken = workWechatHelper.getProviderAccessToken();</span><br><span class="line">    String url = String.format(workWechatConfig.getUploadUrl(), providerAccessToken);</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; params = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    FileSystemResource resource = <span class="keyword">new</span> FileSystemResource(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    params.add(<span class="string">&quot;media&quot;</span>,resource);</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.setContentType(MediaType.MULTIPART_FORM_DATA);</span><br><span class="line">    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(params, headers);</span><br><span class="line">    Map&lt;String, String&gt; post = RestTemplateHelper.post(url, entity);</span><br><span class="line">    <span class="comment">// 将缓存的信息删除</span></span><br><span class="line">    FileUtil.del(filePath);</span><br><span class="line">    <span class="keyword">if</span> (post != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String code = post.get(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(code, workWechatConfig.getSuccessCode())) &#123;</span><br><span class="line">            <span class="keyword">return</span> post.get(<span class="string">&quot;media_id&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;调用失败，失败码为：&#123;&#125;, 失败原因为:&#123;&#125;&quot;</span>, code, post.get(<span class="string">&quot;errmsg&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getJobId</span><span class="params">(String mediaId, String tenant)</span> </span>&#123;</span><br><span class="line">        String providerToken = workWechatHelper.getProviderAccessToken();</span><br><span class="line">        String url = String.format(workWechatConfig.getJobUrl(), providerToken);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        String corpId = workWechatHelper.getConfig(<span class="string">&quot;appId&quot;</span>, tenant);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (corpId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;调用失败，获取corpId失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(<span class="string">&quot;auth_corpid&quot;</span>, corpId);</span><br><span class="line"></span><br><span class="line">        JSONArray mediaList = <span class="keyword">new</span> JSONArray();</span><br><span class="line">        mediaList.add(mediaId);</span><br><span class="line">        map.put(<span class="string">&quot;media_id_list&quot;</span>,mediaList);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; post = RestTemplateHelper.post(url, map);</span><br><span class="line">        <span class="keyword">if</span> (post != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String code = post.get(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(code, workWechatConfig.getSuccessCode())) &#123;</span><br><span class="line">                <span class="keyword">return</span> post.get(<span class="string">&quot;jobid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;调用失败，失败码为：&#123;&#125;, 失败原因为:&#123;&#125;&quot;</span>, code, post.get(<span class="string">&quot;errmsg&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目搭建</title>
      <link href="/post/d39191a5.html"/>
      <url>/post/d39191a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p><img src="https://image.leidl.top//img%E7%BB%93%E6%9E%84.png" alt="结构"></p><h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><p>原则：要什么配什么（application文件同理）<br>springboot - 2.3.2.RELEASE<br>选择理由：比较稳定的版本</p><p>mybatis-plus - 3.5.2<br>理由：兼容mz项目的mybatis，同时简单CRUD也不需要编写，但实测没有JPA灵活。主要为了兼容，否则迁移sql工作量也不小</p><p>jdk - 1.8<br>理由：企业比较稳定的版本</p><p>hu-tool<br>理由：有很多实用的工具包，如UUID生成器，数字类型判断等</p><h2 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h2><ul><li>增加了数据库校验环节，确保数据库配置正确的前提下才能启动项目</li><li>增加了插入记录和修改记录自动更新时间的功能</li></ul><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>报错原因：<code>nested exception is java.lang.NoClassDefFoundError: org/mybatis/logging/LoggerFactory</code></p><p><code>问题背景</code><br>使用springboot整合mybatis-plus时，出现报错</p><p><code>思考过程</code><br>控制台提示LoggerFactory空指针，说明无法将mapper对象加入其中，也就是说拿不到这个对象，那么可能是没扫描到包的问题，也有可能是版本不兼容的问题，或者是配置文件出错导致的，最后没想到的是maven依赖包的冲突问题</p><p><code>解决方案</code><br>在pagehelper中排除mybatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><p>基于《Java开发手册（嵩山版）》之外，加一些自己的要求</p><ul><li>web文件夹存放request与response文件。原则：对关键信息隐藏，前端不必要写入多余字段，也不需要收到无用的字段</li><li>简单的sql交给BaseMapper去处理，复杂的需要自己写入xml</li><li>接口方法标注注释，描述信息、作者、版号、时间、参数意义、返回体</li><li>按Java类的分类放入不同的package中，保证条理有序</li><li>物尽其用，保证质量。不引多余jar包，不写冗余代码，不写晦涩难懂的代码，高端的工程往往只需要最朴素的实现方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发技巧</title>
      <link href="/post/317f8360.html"/>
      <url>/post/317f8360.html</url>
      
        <content type="html"><![CDATA[<h1 id="减少查询数据库的频率，多在内存中计算"><a href="#减少查询数据库的频率，多在内存中计算" class="headerlink" title="减少查询数据库的频率，多在内存中计算"></a>减少查询数据库的频率，多在内存中计算</h1><p>在一次请求中，网络IO占据了大多数的时间，代码在内存中的时间是很快的。有时候需要多次查询数据库，这时候可以将一个大的集合查询到，具体使用的时候在进行筛选。尤其避免了在for循环中多次调用数据库查询的情况。举例<br><code>错误示范</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Pojo&gt; collection = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span> (Pojo pojo : collection) &#123;</span><br><span class="line">    Object o = repository.findById(pojo.getId());</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>正确示范</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Pojo&gt; collection = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 并不一定是全量查询，尽量缩小范围</span></span><br><span class="line">List allData = repository.findAll();</span><br><span class="line"><span class="keyword">for</span> (Pojo pojo : collection) &#123;</span><br><span class="line">    Optional data = allData.stream().filter(e -&gt; Objects.equals(e.getId(), pojo.getId())).findFirst();</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据需要精确计算的场景下（如金额，率值，数据分析等）使用java-math-BigDecimal"><a href="#数据需要精确计算的场景下（如金额，率值，数据分析等）使用java-math-BigDecimal" class="headerlink" title="数据需要精确计算的场景下（如金额，率值，数据分析等）使用java.math.BigDecimal"></a>数据需要精确计算的场景下（如金额，率值，数据分析等）使用java.math.BigDecimal</h1><p>推荐入参都使用Sring类型的，可以准确的获取预期值，尤其是浮点数，可能无法准确表示一个值，这与二进制有关，而我们使用的是十进制。例如0.1，当构造函数使用double时，传入的值不会正好等于0.1<br>出参也同样推荐BigDecimal，使用toPlainString()准确的表示。使用toString()可能会出现科学计数法的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认除法精度 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DIV_SCALE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(String v1, String v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> div(v1, v2, DEFAULT_DIV_SCALE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(String v1, String v2, <span class="keyword">int</span> scale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (NumberUtil.isNumber(v1) &amp;&amp; NumberUtil.isNumber(v2) &amp;&amp; <span class="keyword">new</span> BigDecimal(v2).compareTo(BigDecimal.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(v1).divide(<span class="keyword">new</span> BigDecimal(v2), scale, RoundingMode.HALF_UP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BigDecimal.ZERO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用枚举判断时，无需使用equals比较，直接使用"><a href="#使用枚举判断时，无需使用equals比较，直接使用" class="headerlink" title="使用枚举判断时，无需使用equals比较，直接使用=="></a>使用枚举判断时，无需使用equals比较，直接使用==</h1><p>直接使用==也避免了null的判断，枚举的equals实现也是直接==判断的，所以equals等同于==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if the specified object is equal to this enum constant.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>==other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="善用工具类"><a href="#善用工具类" class="headerlink" title="善用工具类"></a>善用工具类</h1><p><code>判断集合是否有元素</code><br>通常为list != null &amp;&amp; list.size() &gt; 0。可替换为!CollectionUtils.isEmpty(list)更加清晰<br><code>判断两个对象的值是否相等</code><br>需要判断不为空并且使用equals区比较。可替换为Objects.equals(a, b)<br><code>判断两个集合是否相等</code><br>许多工具类都提供了API，但并不好用，自己DIY的，也挺好使</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断集合是否相等</span></span><br><span class="line"><span class="comment">    * 1.个数必须相等</span></span><br><span class="line"><span class="comment">    * 2.元素必须相等</span></span><br><span class="line"><span class="comment">    * 3.元素顺序可以不相等</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list1 集合1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list2 集合2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true表示元素相等</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function"><span class="keyword">boolean</span> <span class="title">isEqualList</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list1.size() != list2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;T&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;(list1);</span><br><span class="line">    Set&lt;T&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;(list2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> set1.containsAll(set2) &amp;&amp; set2.containsAll(set1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>根据对象属性去重</code><br>stream的distinct无法对对象去重（除非每个对象的属性全部相同）。有些时候需要针对于对象的部分属性进行去重，需要使用自定义方法去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putIfAbsent()方法是如果key不存在则put如map中，并返回null。若key存在，则直接返回key所对应的value值。<br><code>seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;</code><br>最终表达式如果没有该值会返回true得以保留，有该值会返回false跳过不收集<br><code>举个例子</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;A&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ls.add(<span class="keyword">new</span> A(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;10&quot;</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">        ls.add(<span class="keyword">new</span> A(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;20&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">        ls.add(<span class="keyword">new</span> A(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;10&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">        List&lt;A&gt; collect = ls.stream().filter(distinctByKey(e -&gt; e.getName() + e.getAge())).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object, Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line">    String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name, String age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：[A(name=tom, age=10, address=a), A(name=jack, age=20, address=b)]</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><p>-XX:+PrintCommandLineFlags可以输出使用的命令（比如最大堆内存之类的）</p>]]></content>
      
      
      <categories>
          
          <category> 工作实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存小记</title>
      <link href="/post/1a7b7abf.html"/>
      <url>/post/1a7b7abf.html</url>
      
        <content type="html"><![CDATA[<p>缓存脏读无法避免，也没必要避免。如果想要保证数据的强一致性，应该阻塞所有的读（在满足多个db，分区容错性的前提下，必须牺牲一定的可用性），但就失去了使用redis的初衷</p><p>如果将更新缓存的方式，变为删除缓存，这样看似合理，本质上和更新一样，除此之外还需要考虑缓存击穿的问题</p><p>前脚读，后脚改其实无法避免，即使是单db也无法避免。用户在页面停留半小时点提交也是很正常的。类似这种的做好数据校验和幂等性，提示用户操作失败就可以了</p><p>所以只要不是特别严重（长时间不更新的）都是可以接受的</p><p>最重要的一定要设置缓存失效时间，兜底刷新</p><p>结论：缓存脏读无法避免，数据要求强一致性的本身就不应该放入缓存中。更新db刷新缓存，保证毫秒级别的更新即可</p><p>使用spring线程池可以归纳为线程隔离的一种方式。这种做法使Tomcat线程池和spring线程池不会互相拖累。spring线程池的作用是为了保证Tomcat线程池不枯竭</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql记录</title>
      <link href="/post/490cdff9.html"/>
      <url>/post/490cdff9.html</url>
      
        <content type="html"><![CDATA[<p>备注：来源于掘金小册（花了30大洋）</p><h1 id="散碎小点"><a href="#散碎小点" class="headerlink" title="散碎小点"></a>散碎小点</h1><ul><li>mysql服务器程序被称为mysql数据库实例，简称数据库实例</li><li>mysql服务进程默认名称为mysqld，客户端默认名称为mysql</li><li>输入命令返回结果过程的本质就是一个进程间通信的过程，一般支持三种通信方式：TCP/IP / 命名管道和共享内存 / Unix域套接字文件（了解）</li><li>服务端处理来自客户端的请求大致分为三部分：连接管理 -&gt; 解析优化 -&gt; 存储引擎</li><li>连接管理可采用上述的三种方式建立连接。当客户端发起连接请求的时候，需要携带主机信息，用户名，密码，服务器对这些信息进行验证，认证失败则拒绝连接。可使用SSL来保证数据传输安全性</li><li>解析优化分为：查询缓存，语法解析，查询优化</li><li>查询缓存：从5.7开始不推荐查询缓存，并在8.0移除，只做了解即可。移除原因：虽然可提高性能，但需要维护缓存造成的开销，每次需要更新缓存，维护该缓存的内存区域</li><li>语法解析：sql语句如何执行？服务端需要对该语句进行判断与校验</li><li>查询优化：服务端会将sql语句进行与具有划来保证执行效率</li><li>存储引擎：常见的有MyISAM与InnoDB。负责对表中数据进行提取与写入</li><li>并不是所有系统变量都有GLOBAL与SESSION的作用范围，比如max_connections，最多连接数只有GLOBAL，insert_id表示有自增列的表进行插入时，该列的初始值，就只有SESSION的作用范围</li><li>有些变量只读，不可以设置。比如version</li><li>字符集_ci结尾的表示不区分大小写</li><li>utf8是utf8mb3的别名，utf8mb4可存储一些表情</li><li>字符集举例utf8，比较规则举例utf8_general_ci</li><li>字符集一般由三个系统变量控制，为了避免乱码，通常会将字符集统一（一般为utf8），语句为<code>SET NAMES 字符集名;</code>等同于<code>SET character_set_client = 字符集名;SET character_set_connection = 字符集名;SET character_set_results = 字符集名;</code></li><li>比较规则一般在排序中使用</li></ul><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><p>将表中数据存储到磁盘的存储引擎。处理数据的过程发生在内存里。磁盘的读取速度是没法和内存比的，InnoDB的方式为：将数据划分为若干页，以页作为磁盘到内存交互的基本单位，一般页大小为16KB，也就是一次最少从磁盘中读取16KB的内容到内存中，将内存的16KB刷新到磁盘中</p><p>平时存储的一条条记录的存放方式被称为行格式。行格式有以下四种格式</p><h2 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h2><p><img src="https://image.leidl.top/img/202203302005437.awebp" alt="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png"><br>一条完整记录分为两段，一段能看见的，一段隐藏的。又可以说分为<code>额外信息</code>与<code>真实数据</code>。</p><h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><p>分为三类：变长字段长度列表、NULL值列表、记录头。</p><h3 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h3><p>在mysql中有一些变长字段比如varchar，存储的字节数据不固定，所以在存储真实数据的时候需要顺表把这些数据占用的字节数也存起来，变长字段占用的空间分为两部分：真正的数据内容，占用的字节数<br>内容中存的是字符串的长度十六进制表示形式<br>varchar(M)此时M表示的是字符数而不是字节数，字节数=M*一个字符所使用的字节数（看字符集utf8为3，gbk为2，ascii为1）设字节数为L</p><ul><li>若L&lt;=255，那么使用一个字节表示真正的字符串占用的字节数</li><li>若127&lt;=L&lt;255，用两个字节来表示真正占用的字节数</li><li>若L&lt;=127,则用1个字节来表示真正字符串占用的字符数</li></ul><blockquote><p>InnoDB在读记录的变长字段列表先查看表结构，如果某个变长字段允许最大字节数为255时，如何区分一个字段长度还是半个字段长度？设计师使用该字节的第一个二进制位作为标志位，如果该字节第一位为0，那么该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制第一位都为0（不懂？）），如果该字节的第一位是1，那么该字节就是半个字段长度<br>假如某个字段长度超过了16KB，那么如果该记录在单个页面无法存储时，InnoDB会把一部分数据存储到所谓的溢出页中，该变长字段长度列表值存储留在本页面的长度，所以两个字节也可以存放下来</p></blockquote><p>总结：L超过255字节并真实存储字节数超过127字节，则使用2个字节，否则1个字节</p><h3 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h3><p>某些列可能会存储null值，放到真实数据中会占用地方，所以compact将null列统一管理，存储到null值列表中，过程如下</p><ol><li>统计存储null的列有哪些<br>系统计算时候不会统计not null的列，因为不可能存储null值</li><li>如果表中全为not null，则null值列表也就不存在了，否则按二进制顺序<code>逆序排列</code>，1为null。0不为null（可以记为0为false，1为true）</li><li>null值列表必须用整个字节为表示，如果使用二进制个数不是整数，则在高位补0，8bit为1字节，所以最多补8个0</li></ol><h3 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h3><p>由5个字节组成，也就是40个bit位，40个二进制位，不同位表示意义不同<br><img src="https://image.leidl.top/img/202204011922566.awebp" alt="image_1c9geiglj1ah31meo80ci8n1eli8f.png-29.5kB"></p><ul><li>预留位：没有使用</li><li>delete_mask（1）：标记该记录是否被删除</li><li>min_rec_mask（1）：B+每层飞叶子节点的最小记录添加该标记</li><li>n_owned（4）：拥有的记录数</li><li>heap_no（13）：在记录堆中的位置</li><li>record_type（3）：当前记录类型，0普通，1非叶子节点记录，2最小记录，3最大记录</li><li>next_record（16）：下一条记录的相对位置</li></ul><p>mysql会为每条记录默认添加一些列（隐藏列）<br>row_id 行ID，唯一标识<br>transactionid</p><h4 id="b树与b"><a href="#b树与b" class="headerlink" title="b树与b+"></a>b树与b+</h4><ul><li>b所有节点都会存储行数据，一个节点容量为16k是有限的。而b+非叶子节点主存储主键，可以容纳更多数据</li><li>由于可以容纳更多数据所以，同一个节点可以指向更多的节点，所以相同数据量，b+更矮，IO次数更少</li><li>b查询效率不稳定，有可能在非叶子，有可能在叶子。b+稳定</li><li>b+叶子有序，便于范围查询</li></ul><p>为什么不用hash索引<br>精确匹配速度是O（1），但不适合范围查找。hash本身就是散列的</p><p>建造索引的时间<br>刚建表或者修改表结构</p><p>好处<br>加快查询速度，加快排序速度，加快分组速度</p><p>创建索引四大原则</p><ul><li>联合索优于单列索引</li><li>索引应该建立在区分度高的字段上（区分度指，该字段值筛选出的不具备普适应，比如性别只有男女，查出的区分度就低，不适合建立索引）</li><li>为查询频繁的创建索引，修改频繁的避免创建</li><li>避免创建重复索引（单列a索引，和联合（a，b，c）索引就是重复索引，是两颗独立的b+树）</li></ul><p>辅助索引只存储索引列 + 主键，也就是说查到该值之后，其实查到的是一个主键，然后回表，根据该主键去找到对应的数据</p><p>MyISAM表数据和索引是分离的，索引很小，有必要可以加载到内存中，磁盘IO降到最低，但需在最后执行一次回表</p><p>InnoDB数据与索引挂着，不分离，无法直接全部加载到内存中，需要使用磁盘IO分次读取节点，最差的情况就是回表，重新走一次主键索引</p><p>所以MyISAM特点就是查询快，性能高一点。InnoDB稍逊一点，但支持事务</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2021</title>
      <link href="/post/1baa3967.html"/>
      <url>/post/1baa3967.html</url>
      
        <content type="html"><![CDATA[<h1 id="小汇总"><a href="#小汇总" class="headerlink" title="小汇总"></a>小汇总</h1><ul><li>写文章46篇</li><li>搭blog</li><li>换工作</li><li>换房子</li></ul><h1 id="2021春"><a href="#2021春" class="headerlink" title="2021春"></a>2021春</h1><p><code>3月</code>，参加了思特奇未来之星成人礼，思考了一段时间，感觉比较迷茫，与老板深入沟通后，产生了离职的想法，开始做跳槽准备<br><img src="https://image.leidl.top/img/202201281624659.JPG" alt="sitech"></p><p><code>4月</code>，主攻数据结构，开始刷题，备战软考<br><img src="https://image.leidl.top/img/202201281650478.jpeg" alt="yinyang"></p><h1 id="2021夏"><a href="#2021夏" class="headerlink" title="2021夏"></a>2021夏</h1><p><code>5月</code>，劳动节帮姥爷干农活，给姥姥过八十大寿<br><img src="https://image.leidl.top/img/202201281830445.jpeg" alt="laolao"></p><p><code>6月</code>，对数据结构部分进行总结-&gt;<a href="https://leidl.top/post/4a1111be">数据结构与算法之路</a></p><ul><li><p>主攻设计模式部分，算法那俩月差点把我整秃噜了，赶紧拿别的缓缓</p></li><li><p>拉我舍友出征世界公园，什么都不开放。rnm，退钱！不过舞台剧还不错，总之不值这个票价<br><img src="https://image.leidl.top/img/202201281701595.jpeg" alt="shijie"></p></li></ul><h1 id="2021秋"><a href="#2021秋" class="headerlink" title="2021秋"></a>2021秋</h1><p><code>7月</code>，软考通过-&gt;<a href="https://leidl.top/post/bf7f3b65">软考经历</a></p><ul><li><p>对设计模式部分进行总结-&gt;<a href="https://leidl.top/post/2cd418c2">设计模式之路</a></p></li><li><p>主攻JUC，搭建个人blog。前端其实很有意思，比起后端来说不会很枯燥</p></li></ul><p><code>8月</code>，blog初具规模，整理上传一波笔记，并对blog进行优化（网站加速，SEO优化等）-&gt;<a href="https://zhuanlan.zhihu.com/p/397544165">blog搭建</a></p><p><code>9月</code>，在对blog鼓捣了两个月后。不满意它的布局和一些组件，魔改的时候发现很多都没见过比如pug格式与styl格式的文件，毕竟我的前端水平也只停留在前端三剑客阶段，vue也是二把刀。整了这个blog后，发现当下的前端真的是突飞猛进，不是xx.js，就是xxx.js（万能的js），更新频率也特别频繁。现在前端工程化的框架比较火的就是vue和react。react压根没接触过，恰好vue在公司也在用，索性开整vue。</p><ul><li><p>周末路过鸟巢的时候发现竟然还有一个科技馆！票只能去了买，网上不出名，但我比较喜欢这种地方。一共四五层，整体上展示了科技的发展历程，很好的诠释了为什么称科技是第一生产力，如何影响并改变了我们的生活。美中不足的是没开放5G，也没开放人工智能<br><img src="https://image.leidl.top/img/202201281927362.jpeg" alt="game"></p></li><li><p>王者带妹10连败，卸载弃坑</p></li></ul><h1 id="2021冬"><a href="#2021冬" class="headerlink" title="2021冬"></a>2021冬</h1><p><code>10月</code>，朋友拉我去大同领略不一样的云冈石窟，算是舍命陪君子了，个人不喜欢这种，一堆破石头，有什么可看的。。<br><img src="https://image.leidl.top/img/202201281919256.jpeg" alt="ta"></p><ul><li><p>vue月底差不多入了个门，撸完了vue2 + vue3。说实话，暂无用武之地，帮公司用vue实现了一期需求，对我的blog帮助不是很大。跟随其他博主倒是学了不少实用的。</p></li><li><p>入坑lol手游，等的我花都谢了，终于出了！</p></li></ul><p><code>11月</code>，工作确定后开始了最后的年底计划-换个房子。最后我也找下了比较满意的住所。过程很是很折磨人。但还好功夫不负有心人-&gt;<a href="https://zhuanlan.zhihu.com/p/432607840">找房经历</a><br>整个屋子都是IT圈子的，房子里还有两只猫，回家的一大乐趣就是撸猫，家里人也很热情，周末我可以蹭饭，时不时一起打牌，桌游尝新。<br><img src="https://image.leidl.top/img/202201281802997.JPG" alt="wuzi"></p><ul><li>弃坑lol手游，什么辣鸡游戏</li></ul><p><code>12月</code>，从思特奇离职，入职新略，职业生涯迈进新的一步，新略做自己的产品，自己的代码为产品创造价值，有一种成就感与荣誉感。之前做的产品服务的是内部人员，就不会有这么明显。团队氛围年轻有活力，技术上来说也有很多值得学习的地方</p><p><img src="https://image.leidl.top/img/202201281737840.jpg" alt="xinlue"></p><h1 id="2022的规划"><a href="#2022的规划" class="headerlink" title="2022的规划"></a>2022的规划</h1><ul><li><p>少写bug，少挨骂<br><img src="https://image.leidl.top/img/202201281948463.JPG" alt="system"></p></li><li><p>完成mysql小册的学习（感觉很抽象，不太好啃）</p></li><li><p>把更多的理论与实战结合，不拘泥于功能实现，打磨一个更加精细的产品</p></li><li><p>入手新桌游</p></li><li><p>去更多地方</p></li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>感觉每年临近春节，北京的就会很困难。去年是，今年也是。春节难得与家人团聚，也是我向亲朋桌游推新的最好机会，算上五一，一年至多回家三次，或许跌跌撞撞一年图的就是这点“年味儿”吧，虽然现在跟小时候差远了。但还是不可替代。好几年没喝到腊八粥了，今年特意让奶奶给我留了一部分。我订的货终于到了，回家开整！<br><img src="https://image.leidl.top/img/202201282059904.jpeg" alt="zhuo"></p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人见解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈枚举</title>
      <link href="/post/a10c77a7.html"/>
      <url>/post/a10c77a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果实际业务中需要字典项，通常有以下几种做法</p><ul><li>数据库存对应的k，v</li><li>数据库利用视图透视case when拿取结果</li><li>代码中使用EnumMap</li><li>代码中用枚举</li></ul><p>其实就是分为了数据库和代码维护的方式，运行效率来说肯定是直接写到代码中更快，但维护起来就是数据库的优势了，所以说在数据不经常变动的情况下一般是存到代码中，反之存入数据库中。</p><h1 id="使用枚举和常量类的区别"><a href="#使用枚举和常量类的区别" class="headerlink" title="使用枚举和常量类的区别"></a>使用枚举和常量类的区别</h1><p>以下是代码对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectConstant</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 完成 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FINISH = <span class="string">&quot;FINISH&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ObjectEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 完成 */</span></span><br><span class="line">    FINISH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果定义重复的值“FINISH”常量类并不会提示，可能会造成重复问题，枚举类编辑器会给出提示</li><li>enum相当于一个类，但不可被继承，表示对应的实例是有限的</li><li>总结来说eunm做了很多限制更加规范</li></ul><h1 id="枚举的使用场景"><a href="#枚举的使用场景" class="headerlink" title="枚举的使用场景"></a>枚举的使用场景</h1><ul><li>作为常量使用，比如星期一到星期日，通常配合switch使用</li><li>通过增加变量和构造函数来达到灵活取值</li><li>当字典项，数字或英文变量与所表示的值对应起来</li></ul><h1 id="使用枚举作为字典项"><a href="#使用枚举作为字典项" class="headerlink" title="使用枚举作为字典项"></a>使用枚举作为字典项</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ObjectTypeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** GTA历史活动 */</span></span><br><span class="line">    GTA_HISTORY_ACTIVITY(<span class="string">&quot;GTA_HISTORY_ACTIVITY&quot;</span>, <span class="string">&quot;GTA历史活动&quot;</span>),</span><br><span class="line">    <span class="comment">/** GTA活动追踪 */</span></span><br><span class="line">    GTA_ACTIVITY_TRACK(<span class="string">&quot;GTA_ACTIVITY_TRACK&quot;</span>, <span class="string">&quot;GTA活动追踪&quot;</span>),</span><br><span class="line">    <span class="comment">/** 月报 */</span></span><br><span class="line">    OVERALL_DATA_ANALYSIS(<span class="string">&quot;OVERALL_DATA_ANALYSIS&quot;</span>, <span class="string">&quot;月报&quot;</span>),</span><br><span class="line">    <span class="comment">/** 营销活动复盘 */</span></span><br><span class="line">    MARKETING_ACTIVITIES_ANALYSE(<span class="string">&quot;MARKETING_ACTIVITIES_ANALYSE&quot;</span>, <span class="string">&quot;营销活动复盘&quot;</span>),</span><br><span class="line">    <span class="comment">/** 日报 */</span></span><br><span class="line">    DAILY(<span class="string">&quot;DAILY&quot;</span>, <span class="string">&quot;日报&quot;</span>),</span><br><span class="line">    <span class="comment">/** 行为追踪 */</span></span><br><span class="line">    BEHAVIOR_TRACK(<span class="string">&quot;BEHAVIOR_TRACK&quot;</span>, <span class="string">&quot;行为追踪&quot;</span>),</span><br><span class="line">    <span class="comment">/** 连带购买 */</span></span><br><span class="line">    JOINT_PURCHASE(<span class="string">&quot;JOINT_PURCHASE&quot;</span>, <span class="string">&quot;连带购买&quot;</span>),</span><br><span class="line">    <span class="comment">/** 触点分析 */</span></span><br><span class="line">    CONTACT_ANALYSIS(<span class="string">&quot;CONTACT_ANALYSIS&quot;</span>, <span class="string">&quot;触点分析&quot;</span>),</span><br><span class="line">    <span class="comment">/** 复购分析 */</span></span><br><span class="line">    REPURCHASE(<span class="string">&quot;REPURCHASE&quot;</span>, <span class="string">&quot;复购分析&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String typeKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String typeValue;</span><br><span class="line"></span><br><span class="line">    ObjectTypeEnum(String typeKey, String typeValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.typeKey = typeKey;</span><br><span class="line">        <span class="keyword">this</span>.typeValue = typeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTypeKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> typeKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTypeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> typeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String typeKey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ObjectTypeEnum type : values())&#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(type.getTypeKey(), typeKey))&#123;</span><br><span class="line">                <span class="keyword">return</span> type.getTypeValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑记录</title>
      <link href="/post/5e87465f.html"/>
      <url>/post/5e87465f.html</url>
      
        <content type="html"><![CDATA[<h1 id="post入参问题"><a href="#post入参问题" class="headerlink" title="post入参问题"></a>post入参问题</h1><p><code>问题描述</code>：在使用@PostMapping注解时，导致入参错误的问题，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;xxx&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title">xxx</span><span class="params">(Long id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>问题解析</code>：如果不指定接收类型，会从Content-Type中的x-www-form-urlencoded中接收值，使用@RequestBody注解指定后，会从请求体raw中进行取值，但Long类型(前端传的是json串，类型不匹配)无法进行反序列化（错误如下）所以在接收的时候建议使用get的方式进行请求</p><blockquote><p>org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize instance of <code>java.lang.Long</code> out of START_OBJECT token; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of <code>java.lang.Long</code> out of START_OBJECT token</p></blockquote><p><code>备注</code>：@RequestParam用来接收Content-Type的x-www-form-urlencoded类型，相当于url中拼接参数值<br>@RequestBody用来接收Content-Type的请求体raw（一般指定application/json）可以为list，map，自定义对象等</p><h1 id="jpa映射对象的问题"><a href="#jpa映射对象的问题" class="headerlink" title="jpa映射对象的问题"></a>jpa映射对象的问题</h1><p>很多情况下表对应的实体类并不能解决实际的业务问题，这时候就需要单独建立一个模型对象来取自己需要的字段值，使用原生sql来查询所需要的字段并且映射到自定义对象上就显得十分重要，在策略项目中基本是按照继承的方法或者自定义原生sql来返回需要的结果</p><h2 id="如何利用jpa查询的结果来转化为自定义对象？"><a href="#如何利用jpa查询的结果来转化为自定义对象？" class="headerlink" title="如何利用jpa查询的结果来转化为自定义对象？"></a>如何利用jpa查询的结果来转化为自定义对象？</h2><p>通常的做法有这么几种</p><ul><li>按照各个实体类查出来拼到一个对象里<br>存在的问题：两三张表还好说，多了的话代码污染了属于是，不是一个一劳永逸的方法</li><li>查询结果用map接收<br>存在的问题：虽然可通过map的隐式转化转为自定义对象，但实际进行了两次强转，可能存在隐患（ClassCastException警告），而且集合不指定泛型代码可读性也不强，也不符合编码规范</li><li>使用jpql<br>这个是JPA的特有语法。之前一直用的mybaits，可采用配置的方式解决，JPA给我整不会了，查阅资料后并进行了使用。JPA使用面向对象的语法可以让查询的结果直接注入到自定义对象中，之前还吐槽jpa种种槽点。。现在啥也不说了JPA牛逼！但存在的问题也显而易见了，有学习成本，sql是程序员必备技能，但jpql不是。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>也许还有另外或者更好的方法，可见技术广度还是很重要的，它决定了在遇到问题的时候会有几种思路，从而选择一个最优解。</li></ul><h2 id="案例对比"><a href="#案例对比" class="headerlink" title="案例对比"></a>案例对比</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="keyword">value</span> <span class="operator">=</span> &quot;SELECT\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;obc.id AS &#x27;categoryId&#x27;,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;obc.cate_id AS &#x27;cateId&#x27;,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;obc.category,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;obc.category_alias AS &#x27;categoryAlias&#x27;,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;ocb.id AS &#x27;competeId&#x27;,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;ocb.rival_brand_id AS &#x27;rivalBrandId&#x27;,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;ocb.rival_brand AS &#x27;rivalBrand&#x27;,&quot; <span class="operator">+</span></span><br><span class="line">        &quot;ocb.rival_brand_alias AS &#x27;rivalBrandAlias&#x27;\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;FROM overall_brand_category obc\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;LEFT JOIN overall_brand_category_mapping obcm on obcm.category_id = obc.id\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;LEFT JOIN overall_compete_brand ocb on obcm.compete_brand_id = ocb.id\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;WHERE obc.brand_id = :brandId\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;AND obc.data_source = &#x27;STRATEGY&#x27;\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;AND obc.enable = TRUE\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;AND ocb.enable = TRUE&#x27;\n&quot; <span class="operator">+</span></span><br><span class="line">        &quot;ORDER BY obc.cate_id,ocb.rival_brand_id&quot;,</span><br><span class="line">        nativeQuery <span class="operator">=</span> <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="keyword">value</span> <span class="operator">=</span> &quot;SELECT new com.xinluex.unii.insight.backend.domain.entity.overall.dto.OverallCategoryCompeteDTO&quot; <span class="operator">+</span></span><br><span class="line">            &quot;(obc.id,obc.cateId,obc.category,obc.categoryAlias,ocb.id,ocb.rivalBrandId,ocb.rivalBrand,ocb.rivalBrandAlias)\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;FROM OverallBrandCategory obc\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;LEFT JOIN OverallBrandCategoryMappping obcm ON obcm.categoryId = obc.id\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;LEFT JOIN OverallCompeteBrand ocb ON obcm.competeBrandId = ocb.id\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;WHERE obc.brandId = :brandId\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;AND obc.dataSource = &#x27;STRATEGY&#x27;\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;AND obc.enable = TRUE\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;AND ocb.enable = TRUE\n&quot; <span class="operator">+</span></span><br><span class="line">            &quot;ORDER BY obc.cateId,ocb.rivalBrandId&quot;)</span><br></pre></td></tr></table></figure><h1 id="JPA查询缓存的带来的问题"><a href="#JPA查询缓存的带来的问题" class="headerlink" title="JPA查询缓存的带来的问题"></a>JPA查询缓存的带来的问题</h1><p><code>场景描述</code>：JPA自带的方法有一个findAll()，它可以查询该表的所有数据，在开发中用findAll()查出的结果，将该结果属性改变后，重新在调用findAll()查询的结果为改变后的，也就是说不会再次调用数据库中的数据</p><p><code>带来的问题</code>：某些场景需要对查询的对象属性进行更改，但改完之后无法再次查询数据库得到原始数据，这样就需要将原来查询的结果拷贝一份，这里的结果通常是一个集合无法通过BeanUtils.copyProperties()的方法来进行拷贝，创建一个集合使用addAll()/putAll()的方法实际上进行的是浅拷贝，修改新集合的对象依旧会对原始数据造成影响，此时就需要一次进行深拷贝。这里就是通过遍历原始集合数据赋值到新集合中，这样如果原始集合嵌套很多，深拷贝也会有一定时间成本。</p><p><code>换一种思路</code>：能不能不用jpa的缓存？我找过了，目前没有什么配置可以把jpa的缓存关闭，尝试使用了flush()，结果把数据库表全更新了，毁灭性打击。还好修改表数据不多，也还好是开发环境，于是就纳闷儿了，我没调用save()也会更新表？这真是离大谱，连忙去网上找资料，一来二去，这属于JPA特性，flush()会将缓存中 的数据推送到数据库，因为在原始数据上进行了修改，所以数据库也会进行修改（反人类），我这个前提是没有开启事务。如果开启事务直接调findAll()会直接更新，事务在每次查询数据库的时候先将缓存中的数据进行推送，确保查询的数据是最新的（此处口吐芬芳）</p><p><code>处理方式</code>：在不开启事务的前提下，查询一次findAll()先使用原始数据调用业务，在用处理过的数据调用业务。（原来是反过来的，相当于调用了两次findAll()在没进行深拷贝的前提下会带来隐患）</p><p><code>如何消除缓存数据的影响</code>：实际业务中想做到多次使用查出的一个结果集，可以通过序列化，反序列化的方式进行解决，代码示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectMapper.readValue(objectMapper.writeValueAsString(结果集), <span class="keyword">new</span> TypeReference&lt;希望转化的类型&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure><h1 id="mvn-install报错"><a href="#mvn-install报错" class="headerlink" title="mvn install报错"></a>mvn install报错</h1><p>报错详情</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format &lt;plugin-prefix&gt;:&lt;goal&gt; or &lt;plugin-group-id&gt;:&lt;plugin-artifact-id&gt;[:&lt;plugin-version&gt;]:&lt;goal&gt;. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1]</span><br></pre></td></tr></table></figure><p>该错误无法通过mvn命令进行打包安装打tag等一系列操作</p><p>目前在终端未得到解决，本质原因是依赖有公司私服包拉不下来，可以使用idea的maven功能，可以暂时的替代终端</p><h1 id="set无法去重的问题"><a href="#set无法去重的问题" class="headerlink" title="set无法去重的问题"></a>set无法去重的问题</h1><p><img src="image.leidl.top/img/image-20220429110004617.png" alt="image-20220429110004617"></p><p>解决方案：前端也是无法去重，过一天之后发现又可以了，之前试了很多方法</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>存入竞品表，有的话用目前的id，如果没有的话插入表中使用新的id，没有采用实时查询的方式，导致批量插入的时候如果没有插入过这个品牌，那么会插入重复数据。</p><p>处理方式<br>在插入新品牌数据的时候将之前的加入之前的集合中</p><h3 id="update批量更新的问题"><a href="#update批量更新的问题" class="headerlink" title="@update批量更新的问题"></a>@update批量更新的问题</h3><p>@Update(“UPDATE omp_store SET area_id = #{areaId},tag_ids = #{tagIds} WHERE id IN #{ids}”)<br>肯定会有问题，动态sql注解mybatis不支持<br>替换为下方<br>    @Update({“<script>",<br>            "UPDATE omp_store SET area_id = #{areaId},tag_ids = #{tagIds} WHERE id IN ",<br>            "<foreach collection=&quot;ids&quot; item=&quot;id&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;>",<br>            "#{id}",<br>            "</foreach>",<br>            "</script>“})</p>]]></content>
      
      
      <categories>
          
          <category> 工作实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map排序问题</title>
      <link href="/post/7fa79d96.html"/>
      <url>/post/7fa79d96.html</url>
      
        <content type="html"><![CDATA[<h1 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h1><p>导出Excel，标题没有按照规则排序，如图（红框的展示结果同导出的Excel）<br><img src="https://image.leidl.top/img/202112161009822.png" alt="map"></p><p>排序规则，由数据库给出，根据给定的sortTag进行排序<br><img src="https://image.leidl.top/img/202112161015423.png" alt="rule"></p><h2 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h2><p>该集合（keysdata）类型为<code>Map&lt;String,LinkedHashMap&lt;String,List&lt;Object&gt;&gt;&gt;</code>，需要对其中的<code>LinkedHashMap&lt;String,List&lt;Object&gt;&gt;</code>进行排序，而该列的首行并不需要参与排序。<code>该排序相当于用另一个集合的数据对该集合进行排序</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>首先需要新建一个map集合对象，用于存放生成的数据，为什么不能将生成的数据直接生成于原有集合上？LinkedHashMap只保证顺序，不保证有序，在原有集合上更新数据并不会改变结果顺序（Map特性。虽然结果是有序的）</li><li>其次需要一个数组用来判断排序的大小（可以理解为一个辅助数组），这里不能直接使用int，因为lambda不能直接使用外部定义的局部变量，java线程模型中栈帧的私有很可能会导致并发问题。可以使用原子类AtomicInteger进行替换，但不适合该计算场景，也过于复杂了。最后使用数组解决该问题</li></ul><p>关键代码实现如下<br>ruleTag — <code>Map&lt;String, List&lt;Object&gt;&gt;</code> Object指某对象 （ruleTag指图中的sortedTag）<br>resultData — <code>Map&lt;String,LinkedHashMap&lt;String,List&lt;Object&gt;&gt;&gt;</code> （resultData指图中的keysdata）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于接收排序后的数据</span></span><br><span class="line">LinkedHashMap&lt;String, List&lt;Object&gt;&gt; tempMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] compareSort = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对生成的map集合进行排序</span></span><br><span class="line">resultData.forEach((k, v) -&gt; v.entrySet().stream()</span><br><span class="line">        .sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            compareSort[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            compareSort[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 按照给定的规则进行排序</span></span><br><span class="line">            ruleTag.get(k).forEach(x -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getKey().equals(x.getCateName())) &#123;</span><br><span class="line">                    compareSort[<span class="number">0</span>] = x.getSort();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ruleTag.get(k).forEach(x -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (o2.getKey().equals(x.getCateName())) &#123;</span><br><span class="line">                    compareSort[<span class="number">1</span>] = x.getSort();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> compareSort[<span class="number">0</span>] - compareSort[<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .forEachOrdered(x -&gt; tempMap.put(x.getKey(), x.getValue())));</span><br></pre></td></tr></table></figure><p>结果展示（红框的比较明显，其余数据也进行了排序）<br><img src="https://image.leidl.top/img/202112161927154.png" alt="resultMap"></p>]]></content>
      
      
      <categories>
          
          <category> 工作实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之JVM</title>
      <link href="/post/286296.html"/>
      <url>/post/286296.html</url>
      
        <content type="html"><![CDATA[<h1 id="说下JVM的内部组成与作用"><a href="#说下JVM的内部组成与作用" class="headerlink" title="说下JVM的内部组成与作用"></a>说下JVM的内部组成与作用</h1><p><img src="https://image.leidl.top/img/20211115172724.webp" alt="JVM"></p><ul><li>执行引擎（java -&gt; class）</li><li>类加载器（加载class）</li><li>运行时数据区域（加载到内存中指这里）</li><li>本地库接口（运行需要本地接口支持）</li><li>本地方法库（接口需要依赖本地方法库）</li></ul><blockquote><p>联系：编译器会将java代码转为class字节码，类加载器将字节码加载到内存中，放在方法区内，字节码是JVM的一套指令集规范，并不能作用于操作系统，需要由JVM的解释执行引擎翻译为CPU的底层指令，整个过程需要调用本地方法库来实现这个功能</p></blockquote><p><img src="https://image.leidl.top/img/202111241029183.webp" alt="jvm运行时区域"></p><p>简单来说就是<code>堆栈方法区</code>和<code>程序计数器</code></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>作用</p><ol><li>读取指令，实现流程控制（选择、循环、顺序、异常处理）</li><li>多线程情况下，记录线程当前位置</li><li>唯一不会出现OOM的地方，随线程生命周期决定（不涉及对象内存分配，也不承载对象引用）</li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>会出现两个错误。<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code></p><ul><li>StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。</li><li>每次调用方法都会创建栈帧（包括局部变量表、操作数栈、动态链接、返回地址）</li><li>用来保存局部变量、参加方法计算与返回</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>使用native方法服务</li><li>也会出现上述两种错误</li><li>native方法使用C语言编写</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li>内存中最大的一块。共享区域，存放<code>对象</code>和<code>数组</code>，都会在这里分配内存<br>所有的对象都会在堆中分配吗？有个逃逸的概念。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。<br><img src="https://image.leidl.top//imgwatermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAypoudmVub20uyZ4=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></li><li>是垃圾回收的主要区域</li><li>1.8以前，堆内存通常分为：新生代、老生代、永久代</li><li>1.8之后移除永久代，加入元空间，使用的直接内存（物理内存）</li><li>新生代又分为eden区和survivor区，survivor区分为from survivor和to survivor又叫s0，s1</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>放常量、静态变量，类加载信息，又被称为永久代。于1.8之后移除，用元空间代替</li><li>类信息包含版本、字段、方法、接口、父类等信息</li></ul><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><ul><li>1.8后出现，使用本地内存</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区的一部分，存放类信息和常量池表，当无法申请到内存时会OOM。字符串常量池在堆</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>也会出现OOM的问题，受到本机总内存大小和处理器寻址空间的限制</p><h1 id="JVM创建对象是怎么分配的"><a href="#JVM创建对象是怎么分配的" class="headerlink" title="JVM创建对象是怎么分配的"></a>JVM创建对象是怎么分配的</h1><ol><li>先放到eden区，如果满了，触发minor gc。将eden区的剩余对象放入s0</li><li>如果此时再次触发gc，如果没有回收就会进入s1</li><li>如果默认15次回收后进入老年代</li><li>当老年代内存不足会触发major gc，如果还是依然无法放入对象，则OOM</li></ol><h1 id="聊聊垃圾回收"><a href="#聊聊垃圾回收" class="headerlink" title="聊聊垃圾回收"></a>聊聊垃圾回收</h1><ul><li>如何判断是否还在使用了？<code>引用计数法</code>和<code>可达性算法</code>。</li><li>引用简单，有对象引用为+1，无对象为-1.但无法处理对象相互依赖的情况。</li><li>可达性算法类似于树的结构，以GC root作为根节点一直往下搜，能够到达的地方都是存活的，不可达就是不可用的，就可以被回收了</li><li>GC root包含以下内容。栈引用，静态属性引用，常量引用</li></ul><h2 id="有哪些垃圾回收算法"><a href="#有哪些垃圾回收算法" class="headerlink" title="有哪些垃圾回收算法"></a>有哪些垃圾回收算法</h2><p>标记-清除<br>将存活的标记，清理掉未标记的。缺点会造成大量不连续的内存碎片</p><p>标记-整理<br>将存活的挪到一边，将另一边清除。</p><p>标记-复制<br>将内存划为大小相同的两块，每次只使用其中的一块，将存活的放到另一块上，对第一块进行清理</p><p>一般分代收集指的是年轻代（标记-复制）和老年代（标记-清除/整理）</p><h2 id="分代与分区收集的区别"><a href="#分代与分区收集的区别" class="headerlink" title="分代与分区收集的区别"></a>分代与分区收集的区别</h2><p>当前主流采用分代收集。在新生代为什么用复制，因为对象死的多，成本低。老年代存活率高，且没有额外空间进行分配担保</p><p>CMS以最短停顿时间为目标，采用标记-清除算法。吞吐量低jdk9弃用，14删除</p><p>分区则将堆空间划分为连续不同的小区间，每块独立使用，独立回收，便于控制，且可以减少gc所产生的停顿</p><p>G1：高吞吐量，应用于多处理器和大容量的内存环境中</p><p>ZGC：jdk11退出的低延迟回收器，适用于大内存低延迟服务的内存管理和回收</p><h2 id="说说各种gc"><a href="#说说各种gc" class="headerlink" title="说说各种gc"></a>说说各种gc</h2><p>hotspot vm分为部分收集和全部收集（full gc）<br>新生代（minor gc）<br>老年代（major gc）</p><h2 id="什么情况下会触发full-gc"><a href="#什么情况下会触发full-gc" class="headerlink" title="什么情况下会触发full gc"></a>什么情况下会触发full gc</h2><ol><li>system.gc()</li><li>老年代不足</li><li>1.7的永久代不足</li></ol><h1 id="说下JVM是怎么调优的"><a href="#说下JVM是怎么调优的" class="headerlink" title="说下JVM是怎么调优的"></a>说下JVM是怎么调优的</h1><p>VisualVM：如下图所示<br><img src="https://image.leidl.top//imgimage-20230207200024438.png" alt="image-20230207200024438"><br>在短短的运行时间中，Ede进行了49次GC,虽然时间短，但是能说明一个问题，新生代堆内存分配的空间太小，<br>导致频繁GC<br>同时，OId老年代也进行了33次GC,虽然运行时间也在不需要优化的范围内，而且从Survivor可以看出，基本没有GC,说明这些 都是大对象，直接进入到了Old老年代，导致GC频繁<br>所以，我们需要进行的优化就是<code>加大新生代和老年代堆内存的大小</code>，同时<code>减少大对象的产生</code><br>可将VM参数改为：-Xms512m-Xmx512m-Xmn128m-X:+HeapDumpOnOutOfMemoryError</p><p>参考链接 — <a href="https://mikechen.cc/15386.html">https://mikechen.cc/15386.html</a></p><h2 id="谈谈常用命令及作用"><a href="#谈谈常用命令及作用" class="headerlink" title="谈谈常用命令及作用"></a>谈谈常用命令及作用</h2><ul><li>jps：显示系统中所有的虚拟机进程</li><li>jstat：收集虚拟机各方面的运行数据</li><li>jinfo：显示虚拟机配置信息</li><li>jmap：生成虚拟机的内存转储快照</li><li>jhat：分析堆内存转储快照，不推荐使用，消耗资源而且慢</li><li>jstack：显示线程堆栈快照</li></ul><h2 id="JVM调优的一些参数可以举例一些吗"><a href="#JVM调优的一些参数可以举例一些吗" class="headerlink" title="JVM调优的一些参数可以举例一些吗"></a>JVM调优的一些参数可以举例一些吗</h2><p>-Xms2g：初始化堆大小为 2g；</p><p>-Xmx2g：堆最大内存为 2g；</p><p>-Xmn1g：新生代内存大小为1g；-XX:NewSize 新生代大小，-XX:MaxNewSize 新生代最大值，-Xmn 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；</p><p>-XX:NewRatio=2：设置新生代的和老年代的内存比例为 1:2，即新生代占堆内存的1/3，老年代占堆内存的2/3；</p><p>-XX:SurvivorRatio=8：设置新生代Eden和两个Survivor比例为 8:1:1；</p><p>–XX:+UseParNewGC：对新生代使用并行垃圾回收器。</p><p>-XX:+UseParallelOldGC：对老年代并行垃圾回收器。</p><p>-XX:+UseConcMarkSweepGC：以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p><p>-XX:+PrintGC：开启打印gc信息；</p><p>-XX:+PrintGCDetails：打印gc详细信息。</p><h1 id="java会内存泄漏吗？"><a href="#java会内存泄漏吗？" class="headerlink" title="java会内存泄漏吗？"></a>java会内存泄漏吗？</h1><p>java拥有GC机制，但还是会出现内存泄漏的情况，如果GC无法进行回收，那么就会导致泄漏</p><h1 id="java对象引用类型有哪些？具体使用场景是什么？"><a href="#java对象引用类型有哪些？具体使用场景是什么？" class="headerlink" title="java对象引用类型有哪些？具体使用场景是什么？"></a>java对象引用类型有哪些？具体使用场景是什么？</h1><ul><li>强引用：new出来的就是，就算OOM也不会进行内存回收</li><li>软引用：发生内存溢出前会被回收。通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂存缓存，当内存不足时清除掉，这样就可以保证使用缓存的同时，不会耗尽内存</li><li>弱引用：gc的时候就会被回收，同样可用于内存敏感的缓存</li><li>虚引用：无法通过虚引用获得对象，作用在于在GC的时候返回一个系统通知</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>更多内容可点击参照<a href="https://mp.weixin.qq.com/s?__biz=MzkxMDI2NTc2OQ==&mid=2247486021&idx=1&sn=b5c86e9e426b7de8bd4030312775dbb6">这篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经历</title>
      <link href="/post/892a2328.html"/>
      <url>/post/892a2328.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人篇"><a href="#个人篇" class="headerlink" title="个人篇"></a>个人篇</h1><p>说说个人情况，普通本科，软件工程，从传统的计算机软件行业起步，一年后找工作实现了Double，虽然对于互联网“人均水平”来讲不值一提。但对于我来说一直在按照制定的计划中稳步进行。不是人人都是985，211，但可以通过自己的能力获得一个不错的待遇，IT最大的魅力就在于此！<br>写这篇文章一用于个人记录，二就当分享。自己本身优秀就没必要看下去了</p><h1 id="跳槽想法"><a href="#跳槽想法" class="headerlink" title="跳槽想法"></a>跳槽想法</h1><h2 id="第一次跳槽"><a href="#第一次跳槽" class="headerlink" title="第一次跳槽"></a>第一次跳槽</h2><p>主要是没有成长吧，1年 = 10年。对于一个应届毕业生来讲，其实学校基本已经定义了你的一个“身价”，薪资这块不是当前阶段纠结的点，选一个好的平台是无比重要的，我刚毕业可能也没意识到这一点，想着在北京能有份工作就不错了。我第一份工作是做一个企业应用方向的，比较稳定，技术挑战少。而且公司比较扣，我也没什么好讲的，干的这些活确实不值得拿一个高薪</p><h2 id="第二次跳槽"><a href="#第二次跳槽" class="headerlink" title="第二次跳槽"></a>第二次跳槽</h2><p>这个不算作跳槽，我们业务线大砍，我就是那条线的o(╥﹏╥)o不过还是拿到了N+1的补偿，怎么说呢，我觉得这家还不错，出手大方，不压工资（1号发），年终随春节发放，裁员有补偿，五险一金按最高比例缴（公积金有基数）等等吧，我觉得很多公司是给不了的<br>换工作需要准备什么<br>程序员也就三五年方向选择期，后面基本就在一个行业深耕了，所以前期的方向和积累很是重要。我第一家比较好的一点是朝九晚五，留给我的时间很多，我可以利用这个时间去积累一些东西，说起来容易，坚持不易。我做了这些</p><ul><li>考证（软考）</li><li>搭建个人博客</li><li>写原创文章</li><li>夯实基础（算法，设计模式）</li></ul><p>原本想着做开源项目github攒星，奈何能力还不够。与其说这行卷，倒不如换个词儿，行业特性。是一个为数不多可以将付出和回报挂钩的行业，不靠酒场文化，不依赖混年限涨薪。真的适合有梦想的年轻人！</p><h1 id="找工作篇"><a href="#找工作篇" class="headerlink" title="找工作篇"></a>找工作篇</h1><h2 id="第一家"><a href="#第一家" class="headerlink" title="第一家"></a>第一家</h2><p>属于骑驴找马，所以主要以视频面试为主，有偶尔到面的，所以录音笔发挥的用处不大，我只详细的记录了moka和滴滴的内容，其余的根据我的记忆说上一点。有的接受邀请没去的，有的去了感觉没什么写的我就不写了。写几家印象比较深的<br>还是建议不要裸辞，找到心仪的工作花了将近两个月，如果裸辞心态可能会比较急，找个差不多的就去了，因为时间越长会越焦虑，当然各有利弊，在职就不适合找一些急招岗位了，还得看下家是否能给你时间交接，因此也会错过一些机会。而且在公司也不方便接电话，视频面就算约到如果工作忙或者突然开会你很容易爽约，所以看情况而定吧，如果工作就抽不开时间，一直在忙，还是在交接期找吧</p><h2 id="第二家"><a href="#第二家" class="headerlink" title="第二家"></a>第二家</h2><p>手中有粮，心中不慌。我是在22年11月底走的，那段时间合适的工作还是不大好找的，那会儿也不是很慌，就当给自己放个假，顺便看看机会，临近1月，我索性就回家过年去了。正月十五之后才来北京，疫情在22年12月放开，我觉得机会也好起来了，最近面得几家都给offer了，我打算在观察观察（23/2/19记录）</p><h1 id="理想公司"><a href="#理想公司" class="headerlink" title="理想公司"></a>理想公司</h1><p>干IT的人人都想进大厂，没什么可讲的，我想说的是大厂不稳（第一个是学历，第二个是算法题），如何找一个自己心仪的公司<br>首先应该明确自己的优劣势，与一个大致公司类型<br>以我举例，劣势，题刷的少而且项目亮点少，工作年限也短，猎头也不好推（工作经验与薪资）<br>优势：我科班出身，八股背的溜，有自己的博客，基础扎实，实操多。还是有一点竞争优势的<br>最后有一个关键的学校问题，我认为在职业初期，公司还是比较看重这个东西。OD都得211起步了。虽说没有明显要求这个，但必须本科以上，我虽然是双非，也收到了滴滴和蚂蚁的面试，所以面试机会还是有的，个人能力强完全可以进。滴滴项目面挂，这我没什么好说的。蚂蚁没有北京的jd，暂时还不想去杭州。<br>我打算去互联网或者创业团队，找一个自研项目团队，不考虑外包，外协，外派的工作，银行项目和国企也不会考虑（这也算一年经验的一部分吧，知道了自己想要什么）<br>总之，我不大建议海投，容易疲于奔命，不如精投几家，前期可以拿小公司练手（无意冒犯），看看都问些什么</p><h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><p>跳槽是一个成本很大的东西，往往需要有一个不错的待遇做平衡，我认为这东西因人而异，不是说多少就合适<br>根据目前薪资，能力表现（主要），本身硬件（学历证书工作履历这些），还有JD的薪资范围决定<br>值多少钱不是自己说了算，而是市场。如果你能拿到1w往往说明你一个月创造的价值不只这些</p><h1 id="简历篇"><a href="#简历篇" class="headerlink" title="简历篇"></a>简历篇</h1><p>有句话叫面向简历学习。一点也没错，简历是我们的门面，能否获得机会就是这个说了算，为什么有的人海投无果，不要总抱怨什么大环境问题，有可能是自己的简历出了问题<br>简历写的内容少的话机会就少，反之需要准备的东西也就越多（多加一句话可能需要准备很多东西）<br>每个岗位的简历都是不同的，但思想是通用的，我就拿Java技术岗来举例</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>简历名称命名采用：岗位 + 工作经验 + 名字 的方式<br>一般放到一页。如果放不下。则挑重点的留下，其他的简略去写<br>推荐一个数字法则。一共做了x个模块。有y个是自己负责的，为公司带来了Z的价值<br>注意标点符号，全部统一。不要一会儿一个句号，一会儿一个分号的。要不都不写，跟文章一样</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>写一些重要的就行，什么民族这些与找工作无关的不要写<br>姓名<br>年龄<br>学校（985，211标上，普通本科可以不写）<br>学历（现在大多要求统招全日制本科，可以就这么写）<br>专业（科班的话写）<br>工作经验<br>联系方式（手机 + 邮箱）<br>证书链接<br>作品链接</p><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>就职时间 + 公司名 + 职务<br>项目名称<br>工作内容<br>如果有多家一直往下列就好</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p>这块应该是面试业务最常考察的一部分，一定要对自己目前的业务比较熟悉<br>具体阐述项目的，做了哪些模块，涉及了哪些技术，遇到的难点，怎么去解决的<br>技术栈<br>这个是技术岗比较核心的一个部分，为什么把它放到下面了，求职的技术栈都大同小异，应该把入职公司和项目首先让招聘者看到。这块需要注意的是不能光写我熟悉掌握哪项技术，应该更加全一些，举个例子<br>熟悉使用Java，基础扎实<br>熟练使用Java进行面向对象设计与编程，极为注重代码规范和编程风格，有轻微的代码洁癖<br>自我评价<br>不要再写什么乐观活泼有团队意识了，要别具一格，这个部分可有可无，但不要写废话<br>可以写一些自己的竞争优势，比如科班出身，全栈素质等<br>也可以写一些看过的书籍，没看过最好不要编，我就遇到过问的<br>或者是一些正在攻克的技术等等</p><h1 id="面试建议"><a href="#面试建议" class="headerlink" title="面试建议"></a>面试建议</h1><p>不要海投，有针对性一些。面试很累的，不要疲于奔命<br>心态放平，被拒有N种理由。可能是项目不匹配，或者接不了你这薪资，不一定就是能力不行<br>一定要录音！！！一是为了查漏补缺，不跌倒第二次。二来你如果作为面试官听听自己是什么感受<br>最好自带简历。虽然说人家也能打印，但显得咱有准备，印象好一些<br>多准备面经，不打无准备的仗<br>面向简历学习，写什么，看哪块，不要乱写<br>可以先去一些公司练手。一是看问些什么，二是找面试自信<br>上家离职原因必问！是想看你说的这些原因他们存不存在，这个只要不触及红线就可以，尽量真实<br>面试过程中不要说然后…和呃…，尤其是自我介绍的时候，我之前就有很多次不连贯，一直’然后’，自己听录音也会感觉到不舒服，别说面试官了<br>答不答的出来都得扯两句，不会就扯跟它相关的，或者引导相关的问题上。最不乐观的就是一句也说不上来的，要说这块了解的少，别说不会，下来研究，我可以学这样的话<br>一定要对自己有一个价值判断，不要看人家的薪资范围，你为什么值这个价？心里总得有点数，不要乱要，对方可比你精明多了，你值多少人家也有数<br>人事面要流水才开薪资的斟酌下，流水一般入职前提供才正常<br>目前多少，期望多少必问！目前薪资建议不要乱报，如实说就可以，谈基本薪资也行，总包也行，因为最终入职需要提供流水<br>面试需要准备。有的人习惯万事俱备才去面，其实就是害怕失败，害怕别人否定自己。面试本来就是不满意居多，做好记录，查缺补漏就好。只需要准备些高频就可以了（看简历写的内容）<br>如果有到面填表的时候可以不写一些与求职不相关的。比如家庭信息</p><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>一般公司流程3面，一轮技术，二轮项目，三轮人事，大公司会比较多，时间会比较久一点<br>这里只谈一般公司，其实面完之后你可以感觉到过没过，不要追问人家HR，一般过了会在当天过次日告你，否则就是凉了，不要过于纠结，继续面下一家就行了。如果就是在意这个职位，那必定要舍弃一些去跟人家聊（多半是薪酬问题），但我还是建议向前看，因为就算这样进去了，心里也会不舒服</p><h1 id="人事环节（入职前）需要问清楚什么"><a href="#人事环节（入职前）需要问清楚什么" class="headerlink" title="人事环节（入职前）需要问清楚什么"></a>人事环节（入职前）需要问清楚什么</h1><p>到了这一步，恭喜你，基本是成功了。但别高兴太早，人事面也是最好面也是最难的一面，讲究技巧，有一票否决权，入职前需要了解以下问题，粗体必问<br>薪资结构。基础薪资x多少薪，基础薪资包括绩效不（如果有看是按月发还是按季发）<br>有无补助，都有什么，节假日福利，春节国庆休多少，有没有带薪年假。大点的厂可能有期权什么<br>五险一金基数和比例（一般按最低，所以正常的要珍惜）<br>几号发工资，正常公司压薪资不超过15天<br>试用期多长时间，打折不<br>上下班时间，有无加班情况。如果加班是调休还是给加班工资，是否双休<br>进去做什么，如果HR不清楚，问问技术或直属领导，判断能否胜任，或者需要提前准备什么<br>公司是否提供笔记本，若不提供有补助吗，若提供可以用自己的可以拿到补助吗<br>开发的网络环境与软件限制（一般大公司有）<br>晋升和调薪机制。出来打工我不惦记钱，那惦记什么？</p><h2 id="一年面试经历"><a href="#一年面试经历" class="headerlink" title="一年面试经历"></a>一年面试经历</h2><h3 id="moka（一面）"><a href="#moka（一面）" class="headerlink" title="moka（一面）"></a>moka（一面）</h3><p>面试官挺好的，整体体验良好，面了2小时，下来比较累。算法题做出来了，考了一道实际应用题，不准用递归实现。时间比较长，题整体不难，好好准备下也能过，我没准备充分，而且自己给自己挖的坑不少，之后面试注意下吧，千万不要说你不擅长的技术，喜提冷却期一年<br>面试问题<br>自我介绍<br>挑个项目进行下项目介绍吧<br>项目难点有哪些（我说到了适配器模式）<br>聊下适配器模式<br>算法题（遍历部门节点，不用递归实现）<br>springboot用过是吧，描述下@springbootApplication有什么组成，机制是什么，原理是什么<br>用过@Transactional注解吗，有哪几种传播类型<br>熟悉哪些中间件，展开说说<br>说说跳表<br>说说innodb的聚集索引和非聚集索引的区别<br>说说b树与b+树的区别<br>mysql种默认的锁有哪些<br>说说行锁与表锁的应用场景<br>比较了解springcloud的哪个中间件，具体谈一谈<br>谈下zk<br>谈下mq</p><h3 id="知网一面"><a href="#知网一面" class="headerlink" title="知网一面"></a>知网一面</h3><p>知网听着高大上，大家毕设查重肯定都经历过。但进去不是什么核心部门，通过一面的对项目的了解，其实项目不怎么样，二面给你24h内手写一个CRUD，用swagger验证，其实也不知道我为什么没过，邮件发送之后就没理我了，我很烦这种24小时的题<br>自我介绍<br>为什么要离职<br>介绍下你的项目</p><h3 id="知网二面"><a href="#知网二面" class="headerlink" title="知网二面"></a>知网二面</h3><p>机试（手写CRUD）</p><h3 id="滴滴一面"><a href="#滴滴一面" class="headerlink" title="滴滴一面"></a>滴滴一面</h3><p>感觉大厂转go的真多，滴滴也就碰碰运气，不问Java，全靠平时积累，问题都有几个没答出来，比较重视基础<br>转go，偏向基础<br>自我介绍<br>聊聊项目<br>为什么从上家离职<br>面向对象和面向过程的区别<br>面向对象的特性<br>重写和重载的区别和实现的方式<br>谈谈爬虫爬过些什么（简历写的了解）<br>怎么爬取，怎么提取，怎么证明给拦截了，怎么反爬（我就rlgl）<br>说下状态码<br>谈谈http协议的组成<br>谈谈对nginx的了解（简历写的了解）<br>mysql的select * from xxx的执行过程<br>建表的索引的规范<br>建表的规范（mysql规范）<br>innodb与myiasm的区别<br>b和b+的区别<br>b+怎么做范围查询<br>树的高度和树的节点有什么区别<br>数据量足够多怎么降低树的高度<br>B的多叉怎么去定义这个叉<br>手写二叉树的后序遍历</p><h3 id="蓝羚网络科技"><a href="#蓝羚网络科技" class="headerlink" title="蓝羚网络科技"></a>蓝羚网络科技</h3><p>一家互联网公司，电子商务这块，都在一块儿办公区，问项目比较多一点，会比较注重实际的工作经验。我最大的短板就是这个项目，感觉没什么两点，一直追着问，我记得比较清楚的一个问题是，如果一个表需要重复使用，在不同的系统中如何公用，不能同步表，不能join查询，可把我问住了，我当时应该问下他们是怎么解决的，不管过没过，我都能学到点东西。还有mysql问的也比较多，包括执行过程，如何实现隔离级别的诸如此类</p><h3 id="东方国信"><a href="#东方国信" class="headerlink" title="东方国信"></a>东方国信</h3><p>拿到这家的offer了，我听我朋友推荐面了下，整体不难，一轮技术，二轮项目，三轮hr，觉得不错就直接谈薪资了，这家比较稳定，但给的少，不是我考虑的公司</p><h3 id="易诚互动"><a href="#易诚互动" class="headerlink" title="易诚互动"></a>易诚互动</h3><p>招的人很多，HR也多，我都拒了，因为是外包，但有个HR和我聊的还不错，我就打算试试，最后给的还行，但考虑到以后，项目外包驻场做银行项目，我还是没有接受</p><h3 id="深睿医疗"><a href="#深睿医疗" class="headerlink" title="深睿医疗"></a>深睿医疗</h3><p>猎头找的我，打算试试，也是家互联网公司，面试官超级垃圾，不管最后能不能成，起码尊重下，不知道在牛逼什么，面过最恶心的一家</p><h3 id="新略数智"><a href="#新略数智" class="headerlink" title="新略数智"></a>新略数智</h3><p>处于计算机软件和互联网之间，客户称这个是中台，CTO说不是，所以我也比较混乱，可以归纳到电子商务这一块。创业公司，去年成立，最近拿到融资，对岗位进行了扩招，到面。公司整体不大，但HR人很好，一轮技术面，是个架构师，问了集合、JVM、微服务、docker这块，考察了数据结构和一些算法。二面CTO面的，主要问项目和一些非技术问题，一些职业规划什么的。每一面都在一个小时左右。因为我面试表现比较好，所以三轮老板面就不面了，直接给了我期望薪资。就是研发岗加班的比较狠</p><h2 id="三年面试经历"><a href="#三年面试经历" class="headerlink" title="三年面试经历"></a>三年面试经历</h2><h3 id="思想无限"><a href="#思想无限" class="headerlink" title="思想无限"></a>思想无限</h3><p>拿到这家的offer了，没去，它家是做直播的，比较出名的是秀色直播，6层楼，每层我觉得办公环境不怎么好，6点去的，当时面完都9点了，还有上班的（多半）所以感觉加班情况挺严重，一共三面，加上笔试4轮，填表，手写两道算法题，然后一轮技术，会给你出一段代码让你分析，比如如何能保证list在添加元素的时候保证只能加入一个元素，保证线程安全，还得保证性能。二轮项目，扒的很清楚，也聊的挺多，知道它家具体做什么的，岗位做什么。三轮就是HR+人事面，这个人事我觉得很恶心，处处压价，这不行，那不行，最后还需要提供流水才能开薪资，刚开始还会要双证编号，最后待遇也不怎么行，没去</p><h3 id="明之数据"><a href="#明之数据" class="headerlink" title="明之数据"></a>明之数据</h3><p>一家大数据公司，公司规模不大，总共30个人左右，交通方便。面试官和HR交谈感觉都挺好的，聊到了最后一面，薪资没聊对。一周一迭代，还是有一定加班量的，也是基于这点我也没有做让步。问了HashMap，多线程，MySQL，代码实践等等，还有一大块是项目部分，还是有共同之处的</p><h3 id="契约锁"><a href="#契约锁" class="headerlink" title="契约锁"></a>契约锁</h3><p>猎头找的我，一面技术过了，二面人事还没进公司就要考你对公司产品的认知，我很反感的一点，这个猎头还没有正式面试就在微信上一会儿问一句，要不你当面试官？真的是面不下去了</p><h3 id="北大青鸟"><a href="#北大青鸟" class="headerlink" title="北大青鸟"></a>北大青鸟</h3><p>这个主要是过去了解对我的职业发展有没有什么帮助，教育在后期又是一条线，其实这家就是来刷KPI的，看完简历就直接约面试，做了一个小时笔试题，到了业务面也感觉没问题，走之前问了下你们这边想找什么样的人，只说了句我们这边不需要太专业的人，主要是给讲师写教材，离谱至极，做的比较出色可以进行直播当讲师，主要形式是线上，我劝有志青年不要跳火坑</p><p>还有一些比较平常的公司就不列举了，目前（23/2）的就业形势还是挺严峻的，找一些大厂阿里，腾讯这些的部门不缺人，实则是学历卡的就没什么机会了，一些猎头也可以去找，但基本是推一些大厂的</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记</title>
      <link href="/post/cb80ff62.html"/>
      <url>/post/cb80ff62.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><h2 id="数据区域"><a href="#数据区域" class="headerlink" title="数据区域"></a>数据区域</h2><p>1.8之前</p><ul><li>线程共享：堆、方法区</li><li>线程私有：本地方法栈、虚拟机栈、程序计数器</li></ul><p>1.8之后</p><ul><li>线程共享：堆、<code>元空间</code></li><li>线程私有：本地方法栈、虚拟机栈、程序计数器</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>作用</p><ol><li>读取指令，实现流程控制（选择、循环、顺序、异常处理）</li><li>多线程情况下，记录线程当前位置</li><li>唯一不会出现OOM的地方，随线程生命周期决定</li></ol><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>会出现两个错误。<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code></p><ul><li>StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li>OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li><li>每次调用方法都会创建栈帧（包括局部变量表、操作数栈、动态链接、返回地址）</li><li>用来保存局部变量、参加方法计算与返回</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li>使用Native方法服务，也会出现上述两种错误</li><li>Native方法使用C语言编写</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>内存中最大的一块。共享区域，存放对象和数组，都会在这里分配内存<br>不是所有对象，有个逃逸的概念。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</li><li>是垃圾回收的主要区域</li><li>1.8以前，堆内存通常分为：新生代、老生代、永久代</li><li>1.8之后移除永久代，加入元空间，使用的直接内存（物理内存）</li><li>新生代又分为eden区和survivor区，survivor区分为from survivor 和 to survivor又叫s0，s1</li></ul><p>OOM的几种形式<br><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。<br><code>java.lang.OutOfMemoryError: Java heap space</code> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>放常量、静态变量，类加载信息，又被称为永久代。于1.8之后移除，用元空间代替</li><li>类信息包含版本、字段、方法、接口、父类等信息</li></ul><h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><ul><li>1.8后出现，使用本地内存</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>方法区的一部分，存放类信息和常量池表，当无法申请到内存时会OOM。字符串常量池在堆</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>也会出现OOM的问题，受到本机总内存大小和处理器寻址空间的限制</p><h2 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h2><p>Java创建对象的过程</p><ol><li>类信息加载</li><li>分配内存</li><li>初始化零值</li><li>设置对象头</li><li>执行init方法</li></ol><h3 id="类信息加载"><a href="#类信息加载" class="headerlink" title="类信息加载"></a>类信息加载</h3><p>一个判断过程，看是否需要类加载。虚拟机遇到new指令，判断在是否能在常量池中定位到这个类的引用，是否被加载，解析和初始化过。都没有执行类加载过程</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载完后确定内存大小，从堆中划分一块区域。</p><p>内存分配方式</p><blockquote><p>由堆决定，是否规整。分为<code>指针碰撞</code>和<code>空闲列表</code>两种。<br>规整则碰撞，有用过的放一边，没用过的放另一边。指针指向没用过的一块区域。代表GC：serial、parnew<br>不规整则空闲：虚拟机维护一个表，记录哪些内存可用，分配的时候，给一块足够大的。代表GC：CMS</p></blockquote><p>如何保证创建对象线程安全</p><blockquote><p>CAS+失败重试。保证更新操作的原子性<br>TLAB：首先在TLAB分配，如果不够，再采取上述的CAS分配</p></blockquote><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>初始化一个值，保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始值完成后，虚拟机将对象的一些信息放于对象头中（类的元数据信息、对象的哈希码、对象的 GC 分代年龄）</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>对于虚拟机来说，对象已经创建完了，从程序视角看，创建才刚开始，init会按照程序员的意愿进行初始化</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>堆是内存回收的主要区域，又称为GC堆<br><img src="https://image.leidl.top/img/20210922111843.png" alt="heap"></p><blockquote><p>-xmn:设置新生代堆大小，xms：设置最小堆空间，xmx：设置最大堆空间</p></blockquote><p>一般情况下，对象从eden区分配，gc后，如果还存活，进入s0或s1，年龄+1，默认增加到15岁，会放入老年代中，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置老年代默认岁数。大对象（需要连续调用内存空间，字符串，数组）则直接进入老年代</p><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ul><li>部分收集：</li><li>新生代（Minor GC / Young GC）只收集新生代</li><li>老年代（Major GC / Old GC）只收集老年代</li><li>混合收集（Mixed GC）整个新生代和部分老年代</li><li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li></ul><h2 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h2><p>在gc收集的时候，首先会判断对象是否已经死亡。常见的算法有引用计数法、可达性分析算法</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>如果有一个地方引用计数器+1，反之-1，为0的时候表示对象不可在被使用。主流虚拟机不会采用此算法，难以解决对象相互循环引用的问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>以GC roots为起点，向下搜索，如果走不通，则对象不可用</p><h2 id="判断类无用"><a href="#判断类无用" class="headerlink" title="判断类无用"></a>判断类无用</h2><p>达到下面3个条件就<code>可以</code>被回收了</p><ol><li>所有类实例被回收，不存在该类的实例</li><li>classloader被回收</li><li>java.lang.Class对象没有在任何地方被引用，无法通过反射方式获取到该类</li></ol><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代收集算法</li></ul><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>分为两阶段，标记和清除（清除不标记的）首先标记处不需要回收的对象，在标记完成后统一回收掉没有被标记的对象，最基础的算法</p><p>带来的问题</p><ul><li>效率不高</li><li>空间问题（不连续的碎片）</li></ul><h3 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h3><p>解决上述效率问题，将内存分为大小相同的两块，每次使用其中的一块，这块的用完后，将存活的对象复制到另外一块内存中去，再将先前一半清空。这样每次回收都是内存的一半</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记对象后，让存活的对象向一端移动，在清理边界之外的内存</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>主流的回收算法。根据存活周期将内存分为几块，一般分为新生代和老年代，再根据不同的代选择不同的算法</p><p>在新生代中，每次回收都有大量对象死去，可选择标记-复制算法（只需要付出少量对象的复制成本就可以完成每次垃圾收集）<br>老年代对象存活几率高，也没有额外空间分配担保（新生代内存不够了，放到老年代中），必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="收集器种类"><a href="#收集器种类" class="headerlink" title="收集器种类"></a>收集器种类</h2><p>上述方法，下述具体实现</p><ul><li>serial</li><li>parnew</li><li>paraller scavenge</li><li>cms</li><li>G1</li></ul><p>没有最好的收集器，只有最适合的收集器</p><p>新生代回收器：Serial、ParNew、Parallel Scavenge 一般采用的是复制算法</p><p>老年代回收器：Serial Old、Parallel Old、CMS 一般采用的是标记-整理的算法</p><p>整堆回收器：G1</p><h3 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h3><p>串行收集器，最基本的收集器，单线程，工作的时候必须停止其他的工作线程。但简单而高效（与单线程比）<br>新生代采用标记-复制算法，老年代采用标记-整理算法</p><h3 id="parnew"><a href="#parnew" class="headerlink" title="parnew"></a>parnew</h3><p>serial的多线程版本，新生代采用标记-复制算法，老年代采用标记-整理算法</p><h3 id="paraller-scavenge"><a href="#paraller-scavenge" class="headerlink" title="paraller scavenge"></a>paraller scavenge</h3><ul><li>同parnew，关注点是吞吐量（CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。吞吐量越高，cpu利用率越高），CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。</li><li>新生代采用标记-复制算法，老年代采用标记-整理算法。</li><li>jdk8的默认收集器 = paraller scavenge + Parallel Old（Parallel Scavenge的老年代版本）</li><li>注重吞吐量可以选择该收集器</li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul><li>注重用户体验，获取最短停顿时间为目标</li><li>hotspot真正意义上的并发收集器，实现了垃圾收集线程和用户线程同时工作（基本）</li><li>标记-清除算法实现</li><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>有空间碎片</li></ul><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul><li>面向服务器，满足停顿时间还有高吞吐量</li></ul><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><ul><li>标记-复制算法，不过做了重大改进</li></ul><h3 id="什么时候FGC"><a href="#什么时候FGC" class="headerlink" title="什么时候FGC"></a>什么时候FGC</h3><ul><li>system.gc()</li><li>老年代空间不足</li><li>永久代空间不足</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端的vue笔记</title>
      <link href="/post/3f6c447b.html"/>
      <url>/post/3f6c447b.html</url>
      
        <content type="html"><![CDATA[<h2 id="下面是我作为后端对vue的看法"><a href="#下面是我作为后端对vue的看法" class="headerlink" title="下面是我作为后端对vue的看法"></a>下面是我作为后端对vue的看法</h2><p><a href="https://leidl.top/post/ad27c5a8">后端程序员应该对vue了解多少</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vue知识点总结，我认为的后端需要了解的程度，学习永远是学的多，会的少。学的尽可能的往深里研究，毕竟以后也没这机会了</p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>需要掌握一定的ES6相关语法，我这里也总结了一点，可以去网上了解更多</p><h2 id="es6属性的简写"><a href="#es6属性的简写" class="headerlink" title="es6属性的简写"></a>es6属性的简写</h2><p><img src="https://pic1.zhimg.com/v2-8035dccb2c4ebbde898c84f116147b80_b.png" alt="img"></p><h3 id="什么时候方法的-可以省略"><a href="#什么时候方法的-可以省略" class="headerlink" title="什么时候方法的()可以省略"></a>什么时候方法的()可以省略</h3><p>必须满足两个条件，类似下图</p><ol><li>事件监听</li><li>方法没有参数</li></ol><p> 当条件为false的时候，v-if不会存在dom中，v-show会出现，加了一个样式dispaly：none。就是F12查看的时候有没有 使用建议：<strong>如果频繁切换使用v-show，只切换一次v-if</strong></p><p>let i in 遍历的对象，此时i是当前<strong>索引</strong> let i of 遍历的对象，此时i是当前<strong>对象</strong></p><p><strong>如果需要以下三个需求应该怎么写代码</strong> </p><ol><li>筛选数组中小于100的数字</li><li>将筛选出的结果x2</li><li>将结果进行相加</li></ol><p>最直接的方法就是套的写，官方叫做链式编程，也叫函数式编程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = nums.filter(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &lt; <span class="number">100</span>           </span><br><span class="line">&#125;).map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">&#125;).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">preValue, n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> preValue + n</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果了解过Java8新特性的也可以采用lambda编程，更加简洁明了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">30</span>,<span class="number">22</span>]</span><br><span class="line"><span class="keyword">let</span> total = nums.filter(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">100</span>).map(<span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>).reduce(<span class="function">(<span class="params">pre, n</span>) =&gt;</span> pre + n)</span><br><span class="line"><span class="built_in">console</span>.log(total)</span><br></pre></td></tr></table></figure><h2 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h2><p>总结一句话：<strong>以后用let不要用var</strong><br>原因：事实上var的设计可以看成JavaScript语言设计上的错误，这种错误多半不能修复和移除，有个人修复了这个问题，他添加了一个关键字：let，所以可以将let看作更完美的var</p><h3 id="为什么不推荐用var？"><a href="#为什么不推荐用var？" class="headerlink" title="为什么不推荐用var？"></a>为什么不推荐用var？</h3><p>js没有像Java一样是强类型语言，所以涉及一个作用域的问题。Java中可以在for循环中每次都int i，但var i不行。<br>js中使用var来证明一个变量，作用域主要和函数的定义有关<br>针对于其他定义来说是没有作用域的，比如if，for，所以开发中会遇到一些问题<br>虽然说闭包可以解决作用域的问题，但是会影响工作效率，程序员应该把时间用到业务逻辑上，不应该承担语言所带来的缺陷。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>修饰变量，const也就相当于Java中的final，不可修改，必须初始化。一般用于定义Vue对象，和一些常量。其中的标识(zhi)符不能改变其中指向，能改变指向的值。经常使用的const app = new Vue(){}</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>相较于jq的ajax来说，axios更专注于网络请求，比jq封装的异步请求更加专业<br><img src="https://image.leidl.top/img/20210825181208.png" alt="image-20210825181208193"></p><p>返回的数据data才是服务器真实的数据，其他数据都是axios追加的数据<br><img src="https://image.leidl.top/img/20210825182858.png" alt="image-20210825182858119"></p><p><code>await</code>只能用在<code>async</code>修饰的方法中，好处是可以不用写then方法，返回值就是结果，不加修饰的话就是返回一个<code>promise</code>对象，这里标记的三个陌生名词是ES的语法，如果遇到这个写法，那就是国际写法，我这里简单总结了几点前置概念有需要的看看</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p><code>目的</code>：为了解决回调地狱的问题，ES6新增了promise的概念</p><p><code>概念</code>；是一个构造函数，new一个promise，该对象代表一个异步操作,可以在该对象的原型对象上.then()方法</p><p>.then()的作用为预先指定成功和失败的回调函数，比如p.then(result =&gt; {}, error =&gt; {})，成功是必选的，失败是可选的</p><p>如果.then()返回了一个新的promise对象，则可以通过下一个.then继续进行处理，通过对then的链式调用，来解决回调地狱的问题，在链式调用的操作过程中发生了错误可以通过catch来对方法进行捕获处理</p><h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>可以理解为多层套娃，如图，这种代码的耦合性强，会产生大量冗余的代码<br><img src="https://image.leidl.top/img/20210906144406.png" alt="image-20210906144405887"></p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h3><p>是ES8的语法，简化promise的异步操作，在async / await出现之前，只能使用链式.then的方式来处理promise的异步操作，此方式解决了回调地狱的问题，但会造成代码冗余的问题,代码如下<br><img src="https://image.leidl.top/img/20210906154141.png" alt="image-20210906154141739"></p><p><code>使用方式</code><br>await用于方法内部，用作修饰之后就不在返回一个promise对象，而是其中的内容<br><img src="https://image.leidl.top/img/20210906154418.png" alt="image-20210906154418590"></p><p><code>注意事项</code></p><ul><li>如果方法内部用到了await则方法外必须使用async进行修饰，否则会报语法错误</li><li>第一个await之前的代码会同步执行，之后修饰的会异步执行</li></ul><p><img src="https://image.leidl.top/img/20210906154845.png" alt="image-20210906154845698"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">结果</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">1 2 3</span><br><span class="line">D</span><br></pre></td></tr></table></figure><h3 id="vue2中全局配置axios"><a href="#vue2中全局配置axios" class="headerlink" title="vue2中全局配置axios"></a>vue2中全局配置axios</h3><p>main.js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">//配置请求根路径</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;https//www.xxx.xxx&quot;</span></span><br><span class="line"><span class="comment">//全局配置axios</span></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure><h3 id="vue3中全局配置axios"><a href="#vue3中全局配置axios" class="headerlink" title="vue3中全局配置axios"></a>vue3中全局配置axios</h3><p>为什么要全局配置？<br>在实际项目开发中，几乎每个组件都会用到axios去发送数据请求，那么会有如下问题</p><ol><li>每个组件都需要导入</li><li>每次发请求都需要写全部路径</li></ol><p>如何全局配置<br>在main.js中，通过app.config.globalPropeties全局挂载axios<br><img src="https://image.leidl.top/img/20210908164159.png" alt="image-20210908164159214"></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>每次发起ajax请求和得到响应的时候会自动触发<br><img src="https://image.leidl.top/img/20210909151803.png" alt="image-20210909151803388"></p><p>应用场景</p><ul><li>token认证</li><li>loading效果</li></ul><p>如何配置<br><code>axios.interceptors.request.use(成功回调函数，失败回调函数)</code>失败的回调可以忽略</p><p>示例代码—验证token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置请求的拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//为当前请求配置token认证字段</span></span><br><span class="line">    config.headers.Authorization = <span class="string">&#x27;token&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure><h3 id="proxy跨域问题"><a href="#proxy跨域问题" class="headerlink" title="proxy跨域问题"></a>proxy跨域问题</h3><p>如果没有开启CROS跨域资源共享，如下接口i昂无法请求成功<br><img src="https://image.leidl.top/img/20210909154723.png" alt="image-20210909154723025"></p><p>解决方案</p><ol><li>后端帮忙处理跨域问题</li><li>使用代理的方式进行解决<br><img src="https://image.leidl.top/img/20210909154922.png" alt="image-20210909154922263"><br>附上一段我开发过程中企业使用的代码<br>在vue.config.js中，声明如下配置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8888</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://localhost:8088&quot;</span>,   <span class="comment">// 要请求的后台地址</span></span><br><span class="line">                <span class="attr">ws</span>: <span class="literal">true</span>,    <span class="comment">// 启用websockets</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,    <span class="comment">// 是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;/&quot;</span>       <span class="comment">// 这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>js是单线程语言，如果前一个任务耗时则会使后面的一直等待</p><p>同步任务：不耗时的任务，由js主线程次序执行</p><p>异步任务：耗时的任务，js委托给宿主环境执行，执行完之后会通知js主线程执行回调函数。</p><p>执行过程<br><img src="https://image.leidl.top/img/20210906155421.png" alt="image-20210906155421597"></p><p>主线程—&gt;异步（执行完哪个就把哪个放到队列中，主线程执行完之后会按照队列中的顺序执行）</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>它们都是异步任务，但有执行先后顺序，交替执行，先宏后微<br><img src="https://image.leidl.top/img/20210906160144.png" alt="image-20210906160144360"><br>宏任务：ajax、计时器、文件操作<br>微任务：promise.then .catch .finally、process.nextTick</p><h3 id="执行顺序举例"><a href="#执行顺序举例" class="headerlink" title="执行顺序举例"></a>执行顺序举例</h3><p><img src="https://image.leidl.top/img/20210906160756.png" alt="image-20210906160756181"></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>vue在利用脚手架构建项目的时候已经实现了一套默认的配置。但有些东西还是需要去了解下</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>前端模块化打包工具。兼容ES6语法，用来打包，就是将浏览器不认识的语法打包成认识的</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>webpack默认只能处理js文件，而且只能处理一般的js语法，让它拥有强大的打包能力是基于各种loader，如果处理高级的js语法，则需要安装babel-loader</li><li>webpack的插件很多，如果有不知道功能的百度下就可以</li><li>sourceMap显示报错目标行号，生产建议不用。或者配置生产行号点不进去源码</li><li>base64适合小文件的处理，好处是减少请求，提高性能</li><li>一切皆模块，都可以写入为js的格式</li></ul><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>单页面应用程序(single page application)，指一个web网站仅有一个html页面</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的交互体验，内容改变不需要重新加载整个页面，没有页面跳转</li><li>良好的前后端分离模式。API接口复用，专注于页面渲染，有利于前端工程化的发展</li><li>减轻服务器的的压力。服务端只提供数据，不负责页面生成和逻辑处理，吞吐能力提升</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>首屏加载慢、不利于SEO</li></ul><h3 id="为什么要介绍SPA"><a href="#为什么要介绍SPA" class="headerlink" title="为什么要介绍SPA"></a>为什么要介绍SPA</h3><p>vue可以通过vite和vue-cli去创建SPA项目<br><img src="https://image.leidl.top/img/20210906171701.png" alt="image-20210906171701615"></p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>虽然vue中不建议程序员直接操作DOM元素，但也提供了方法，可以在不依赖JQ的情况下操作DOM元素和组件实例<br>在每个vue实例对象中都会包含一个$refs，使用示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 ref=&quot;myh3&quot;&gt;自定义&lt;/h3&gt;</span><br><span class="line">//...</span><br><span class="line">show() &#123;</span><br><span class="line">    let v1 = this.$refs.myh3;</span><br><span class="line">    console.log(v1);</span><br><span class="line">    v1.style.color = &#x27;green&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.$nextTick(callback)，将括号中的代码延期执行，当dom完全渲染之后调用</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>foreach的缺点，无法被停止，不像Java中有个break，所以性能不是很好</p><p>some弥补了这一缺点，再找到元素后，可以通过return true来终止循环</p><p>every可以判断是否全选（结合计算属性）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.every(<span class="function"><span class="params">item</span> =&gt;</span> item.state) <span class="comment">//返回一个true</span></span><br></pre></td></tr></table></figure><p>reduce把每一次循环的结果累加起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">累加变量sum，当前循环项item</span>) =&gt;</span>&#123;<span class="keyword">return</span> 计算过程&#125;,初始值)</span><br></pre></td></tr></table></figure><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><ul><li>概念</li><li>优点</li><li>全家桶</li></ul><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>构架用户界面的一个前端框架</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>渲染页面结构更加方便（数据驱动视图）</li><li>提供独特的书简绑定机制，轻松处理交互行为</li><li>工作重心转移，不在放在处理DOM上</li></ul><h3 id="全家桶"><a href="#全家桶" class="headerlink" title="全家桶"></a>全家桶</h3><ul><li>vue（核心库）</li><li>vue-router（路由）</li><li>vuex（状态管理）</li><li>vue组件库（快速搭建UI效果的方案）</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>1、数据驱动视图（单向数据绑定）vue起到了监听数据变化的作用<br>数据的变化会驱动视图自动更新<br><img src="https://image.leidl.top/img/image-20210823192330191.png" alt="image-20210823192330191"></p><p>2、双向数据绑定<br>辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中<br><img src="https://image.leidl.top/img/image-20210823192802732.png" alt="image-20210823192802732"><br>MVVM（Model-View-ViewModel）</p><p>实现两大特性的核心原理<br><img src="https://image.leidl.top/img/image-20210823193148997.png" alt="image-20210823193148997"></p><p>工作原理<br><img src="https://image.leidl.top/img/20210906164344.png" alt="image-20210906164344403"></p><h3 id="vue使用"><a href="#vue使用" class="headerlink" title="vue使用"></a>vue使用</h3><p>引入vue.js，在<code>&lt;script&gt;</code>中new vue对象，如下图<br><img src="https://image.leidl.top/img/image-20210823194447037.png" alt="image-20210823194447037"></p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p>内容渲染：v-text、<code>&#123;&#123;定义的变量&#125;&#125;</code>、v-html</p><p>属性绑定：v-bind（简写为英文状态下的冒号<code>:</code>）— 单向绑定</p><p>事件绑定：v-on（简写为@）</p><p>事件对象：$event（不常用）</p><p>事件修饰符：@click.prevent（阻止对象的默认行为）@click.stop（阻止对象冒泡）</p><p>按键修饰符：@keyup.esc（按键盘的Esc执行相应方法）</p><p>双向绑定指令：v-model（表单元素才有意义，保证数据内外同步）</p><p>v-model.number（获取到的值转为number类型）.trim（去除空白）.lazy（失去焦点值发生变化）</p><p>条件渲染：v-if（初始状态为false，常用） | v-show（添加display:none样式，适合频繁变换的情况）</p><p>列表渲染指令：v-for 示例<code>&lt;v-for=&quot;(item,index) in json&quot;&gt;</code>官方建议:用v-for绑定key，默认为id值，不能将索引作为key，原因：不用key不具有强关联关系，它只是记住当前位置，加了之后会与内容进行绑定。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>vue2支持，vue3砍了，简单了解下</p><p>常用于文本的格式化，插值和v-bind里使用</p><p><code>&#123;&#123; message | function&#125;&#125;</code> 呈现function的返回值 “ | “叫做管道符，function定义到fitters节点下</p><p>一定要有返回值 | 调用采取就近原则，优先私有过滤器</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听数据的某些变化，如图，username变化之后会执行username方法，其中有个属性immediate默认值为false，如果为true则进入页面就会调用一次侦听器，同样的开启deep进行深度监听，可以监听到对象中属性的变化<br><img src="https://image.leidl.top/img/20210825170623.png" alt="image-20210825170621082"></p><p>应用场景：用户名是否被占用，请求接口返回用户名是否存在<br><img src="https://image.leidl.top/img/20210825174909.png" alt="image-20210825174909234"></p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul><li>computed，执行一系列运算后，最终得到一个属性值。用于复用</li><li>本质是一个function函数，可以实时监听data中的变化，并return一个计算的值（return是必须的）</li><li>相较于method的区别是，计算的结果会被缓存，当再次被使用的时候如果数据没有变化，那么方法将不会被调用，调用的时候按照一个变量去调用，如下图应该为<code>&#123;&#123; plus &#125;&#125; </code>，而不是<code>&#123;&#123; plus() &#125;&#125;</code><br><img src="https://image.leidl.top/img/20210907134101.png" alt="image-20210907134101249"></li></ul><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><ul><li>单页面应用程序：只有一个html，其余由js，css等支撑</li><li>vue-cli可以快速搭建单页面应用，简化了程序员webpack创建工程化vue项目的过程，相当于springboot，减免了ssm的一些配置，程序员可以更专注于业务</li><li>脚手架，官方提供的快速生成vue工程化项目的工具</li></ul><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>开箱即用</li><li>基于webpack</li><li>功能丰富且易于拓展</li><li>支持vue2和vue3</li></ul><h3 id="利用cli构建项目"><a href="#利用cli构建项目" class="headerlink" title="利用cli构建项目"></a>利用cli构建项目</h3><p>安装vue-cli、创建项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">vue create 项目名</span><br></pre></td></tr></table></figure><p>目录结构如下<br><img src="https://image.leidl.top/img/20210825201815.png" alt="image-20210825201815908"></p><h3 id="怎么跑起来的"><a href="#怎么跑起来的" class="headerlink" title="怎么跑起来的"></a>怎么跑起来的</h3><p>通过main.js吧App.vue渲染到index.html指定区域中（vue2与vue3有些许不同）<br><img src="https://image.leidl.top/img/20210825202902.png" alt="image-20210825202902742"><br>vue2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入vue包，得到vue的构造函数</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//导入根组件，把App.vue中的模板结构，渲染到html页面中 </span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vue的实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">//把render函数指定的组件，渲染到HTML页面中，替换掉#app的div</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按需导入createApp函数，用来创建单页面应用实例</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//导入待渲染的App组件</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用createApp函数，返回的是一个单页面应用实例，调用该实例的mount方法来指定vue要控制的区域</span></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="vue运行过程"><a href="#vue运行过程" class="headerlink" title="vue运行过程"></a>vue运行过程</h2><p>template—&gt;解析成 ast(抽象语法树)—&gt;编译成 render —&gt;转成 虚拟dom —&gt;转成真实dom—UI</p><p>runtime-only直接就到了render阶段，所以快，性能更高，代码量更少</p><h3 id="vue的组成"><a href="#vue的组成" class="headerlink" title="vue的组成"></a>vue的组成</h3><p>vue文件是一个组件，由三部分构成。组件时UI结构的复用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; //html &lt;/template&gt;</span><br><span class="line">&lt;style&gt; //css&lt;/style&gt;</span><br><span class="line">&lt;script&gt;//js&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>template—&gt;模板结构，存放html结构</p><p>script—&gt;js语句</p><ul><li>其中包含data节点，存放定义数据</li><li>methods节点，存放方法</li><li>emits存放自定义事件</li></ul><p>style—&gt;样式</p><h3 id="组件的注册方式"><a href="#组件的注册方式" class="headerlink" title="组件的注册方式"></a>组件的注册方式</h3><p>全局注册和局部注册，先注册后使用，推荐使用大驼峰命名</p><p>顾名思义，全局表示任意一个组件都可以使用，局部只可以在指定范围内使用<br><img src="https://image.leidl.top/img/20210906193951.png" alt="image-20210906193950857"><br><img src="https://image.leidl.top/img/20210825211524.png" alt="image-20210825211524767"></p><h3 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h3><ol><li>导入组件 import 组件名 from ‘组件路径’</li><li>使用components来注册组件</li><li>以标签的形式使用<br><img src="https://image.leidl.top/img/20210906194343.png" alt="image-20210906194343409"></li></ol><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p>在实际开发中，前端开发者可以把自己开发的.vue组件整理打包发布为npm的包，以供他人下载和使用。这种现成组件就叫vue的组件库</p><h4 id="与bootStrap的区别"><a href="#与bootStrap的区别" class="headerlink" title="与bootStrap的区别"></a>与bootStrap的区别</h4><p>bootStrap只提供了原材料（html+css+js），还需要开发者进行组装和改造<br>vue组件库遵循了vue语法，高度定制的现成组件，开箱即用</p><h4 id="常用组件库"><a href="#常用组件库" class="headerlink" title="常用组件库"></a>常用组件库</h4><p>PC端：Element UI、View UI<br>移动端：Mint UI、Vant</p><h4 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element UI"></a>Element UI</h4><p>饿了么开源的一套PC端vue组件库。支持vue2+vue3<br>vue2：Element UI<br>vue3：Element Plus</p><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><ul><li>prop可以使公共组件自定义初始值，提高组件复用性</li><li>定义一个组件后，导入该组件后赋予其属性<code>&lt;test msg=&quot;content&quot;&gt;&lt;/test&gt;</code></li><li>prop中的属性也可以直接按照插值中去使用，比如<code>&#123;&#123; msg &#125;&#125;</code></li><li>prop是只读的，不可以被直接修改，需要转存到data中</li><li>相关属性:defalut，给定一个默认值。type:给定一个类型。required:是否为必填项</li><li>定义类型的时候不只可以指定一个类型，还可以指定多个可能的类型，总共有8种基础校验类型：String | Number | Boolean | Array | Object | Date | Function | Symbol，常见写法如下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;</span><br><span class="line">    type: [Number,String]</span><br><span class="line">    defalut: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在绑定属性的时候，如果数据类型定义为大驼峰，则绑定属性推荐用-去进行来连接<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;component</span><br><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;item in arrs&quot;</span></span><br><span class="line">:key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">:user-name:<span class="string">&quot;item.name&quot;</span></span><br><span class="line">&gt;&lt;/component&gt;</span><br><span class="line"><span class="comment">//另一个组件</span></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">key</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>:<span class="built_in">String</span></span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">userName</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="built_in">String</span></span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="为什么data中需要传一个函数？"><a href="#为什么data中需要传一个函数？" class="headerlink" title="为什么data中需要传一个函数？"></a>为什么data中需要传一个函数？</h2><p>假如有一种情况，你定义了一个计数器组件，点击增加或者减少互不影响，为什么，这时候函数的作用就体现出来了，每一次使用组件的时候总会调用一个return去返回一个新的对象，所以是互不影响，这也是为什么使用函数的原因。</p><h3 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h3><p>父 —&gt; 子（自定义属性）<br><img src="https://image.leidl.top/img/20210830201332.png" alt="image-20210830201332261"></p><p>子 —&gt; 父（自定义事件$emit）<br><img src="https://image.leidl.top/img/20210830202156.png" alt="image-20210830202156111"></p><p>父 &lt;—&gt; 子（组件上的v-model）</p><p>兄弟之间（EventBus，组件离得远的都可以用）<br><img src="https://image.leidl.top/img/20210830203535.png" alt="image-20210830203535477"></p><p>后代关系（provide &amp; inject）</p><p>全局数据共享<br>vuex:是终极的组件之间的数据共享方案。在企业级vue的项目开发中，vuex可以让组件之间的数据变得高效、清晰、易于维护，如图所示，左侧没有使用vuex，比较混乱。右侧使用了vuex，有一个专门管理数据的地方<br><img src="https://image.leidl.top/img/20210908163338.png" alt="image-20210908163338173"></p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态切换组件的显示和隐藏</p><p>vue提供了一个默认的<code>&lt;compents&gt;</code>组件，占位符，is属性，写哪个渲染哪个</p><p>在切换之后会遇到重新渲染的问题，可以使用keep-alive标签来避免组件销毁，在浏览器中会被缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-avlive&gt;</span><br><span class="line">    &lt;Compoents is:&quot;custom&quot;&gt;&lt;/Compoents&gt;</span><br><span class="line">&lt;/keep-avlive&gt;</span><br></pre></td></tr></table></figure><p>keep-alive有独自的生命周期函数，可以被频繁触发</p><p>当组件被缓存时，会触发组件的deactivated声明周期函数</p><p>当组件被激活时，会触发组件的activated生命周期函数</p><p>includes属性与exclude属性（但只能同时存在一个）<br><img src="https://image.leidl.top/img/20210831164449.png" alt="image-20210831164444921"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>创建—运行—销毁，指一个时间段<br><img src="https://image.leidl.top/img/20210830193557.png" alt="image-20210830191839160"></p><p>生命周期有很多的钩子函数，不论是谁的生命周期也都是从创建到销毁，之前的servlet，线程之类的也都一样，很多都是相通的。通过钩子函数可以了解到元素分别在不同的函数中加载情况，这样的话可以自定义函数选择在那个生命周期中加载。（自己写下相关代码会更清楚）</p><p>beforecreated：el和data均未加载</p><p>created：data完成初始化，el没有。常用于异步获取数据时候使用</p><p>beforemount：完成el和data初始化</p><p>mounted：完成挂载，将内存中的HTML渲染到浏览器中，此时可以操作DOM（最早操作DOM的阶段）</p><p>updated：可以操作数据变化后的最新DOM</p><p><img src="https://image.leidl.top/img/20210908161149.png" alt="image-20210908161149575"></p><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>一般使用居多，定义较少，不是专业前端了解下就可以了，封装组件的时候会被用到，实现UI结构的复用，把不确定和希望用户自定义的部分叫做插槽</p><p>用slot占位，供用户自定义使用（联想到小霸王游戏机，插哪个玩哪个）</p><p>v-slot简写为#</p><p>默认情况下名称为default</p><p>需要作用域template标签中</p><p><img src="https://image.leidl.top/img/20210831180222.png" alt="image-20210831180222312"></p><p>具名插槽：具有名字的插槽。没有指定名字的插槽叫做”default”<br><code>&lt;slot name=&quot;&quot;&gt;&lt;/slot&gt;&gt;</code></p><p>传参解构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//插槽</span><br><span class="line">&lt;slot name=&quot;名称&quot; msg=&quot;属性&quot; :user=&quot;userinfo&quot;&gt;&lt;/slot&gt;</span><br><span class="line">//使用</span><br><span class="line">&lt;template #名称=&quot;&#123;userinfo对象比如 &#x27;&#123; name &#125;&#x27;&#125;&quot;&gt;</span><br><span class="line">&#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>官方的够用了，了解即可<br>官方提供了一些指令如：v-if、v-for、v-model、v-text等指令，除此之外，开发者还可以自定义指令</p><p>私有自定义指令：组件中自己用</p><p>全局自定义指令：全局都可以用</p><p>关键字directives声明私有自定义指令，与method平级，当指令被绑定到元素中时，会自动触发bind函数<br><img src="https://image.leidl.top/img/20210901153809.png" alt="image-20210901153809517"></p><p>比如定义的时候为color，用的时候为v-color</p><p>bind函数只会调用一次，update函数则会在dom每次更新的时候被调用<br><img src="https://image.leidl.top/img/20210901154754.png" alt="image-20210901154753906"></p><p>如果bind和update逻辑完全相同，那么可以简写<br><img src="https://image.leidl.top/img/20210901155108.png" alt="image-20210901155108590"></p><p>vue3调用方式<br><img src="https://image.leidl.top/img/20210909110048.png" alt="image-20210909110048265"></p><p>全局自定义指令Vue.directive，需要放到main.js中<br><img src="https://image.leidl.top/img/20210901155339.png" alt="image-20210901155339023"></p><h2 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h2><p>用来约束代码风格。坑爹东西，搭配插件后让强迫症受不了，我最后是把它关了，帮你修正代码中的格式错误，有错误不让运行<br>比如他会把单引号在你保存的时候变为双引号，每一句结束都要加上<code>;</code>号，还得花时间去设置，我是拜拜了<br>如果往后公司要求，那就按公司来，公司一般也都设置好了一套规则，不用自己去设置，遭不住也得遭了</p><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><ol><li>配置项，在创建项目的过程中，选择eslint<br><img src="https://image.leidl.top/img/20210901162755.png" alt="image-20210901162755782"></li><li>一般选标准配置<br><img src="https://image.leidl.top/img/20210901162828.png" alt="image-20210901162828548"></li><li>on save表示保存的时候会校验，另一个表示提交的时候会校验，一般选第一个<br><img src="https://image.leidl.top/img/20210901162918.png" alt="image-20210901162917948"></li><li>创建完项目之后会出现一个eslint的js文件<br><img src="https://image.leidl.top/img/20210901163552.png" alt="image-20210901163552057"></li><li>可以在其中的rules中配置一些规则<br><img src="https://image.leidl.top/img/20210901163623.png" alt="image-20210901163623580"><br>官方语法规则见：<a href="https://eslint.bootcss.com/docs/rules/">ESLint中文文档 </a><br>需要掌握当编辑器报错的时候，知道是由于格式引起的，还能定位到哪一行</li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>也是vue中一个比较重要的概念，用来指定hash地址和组件的对应关系。路由的本质就是对应关系</p><h3 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h3><p>请求方式、请求地址、function处理函数的对应关系</p><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>在SPA项目中，利用前端路由实现组件之间的切换</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ol><li>点链接（触发）</li><li>url地址栏发生变化</li><li>前端路由监听到hash地址的变化</li><li>将hash地址的组件渲染到组件中<br><img src="https://image.leidl.top/img/20210901192344.png" alt="image-20210901192344468"></li></ol><p>实际上vue-router已经提供了封装，是vue官方给出的一个路由解决方案，可以轻松管理SPA页面组件之间的切换</p><p>vue-router3与vue-router4的最主要区别：创建路由模块的方式不同，在vue2的项目中只能使用vue-router3的路由<br>vue-router3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入vue2的构造函数</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="comment">// 导入vuerouter3的包</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="comment">//导入路由组件</span></span><br><span class="line"><span class="keyword">import</span> C1 <span class="keyword">from</span> <span class="string">&quot;../components/C1.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> C2 <span class="keyword">from</span> <span class="string">&quot;../components/C2.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Tab1 <span class="keyword">from</span> <span class="string">&quot;../components/Tab1.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Tab2 <span class="keyword">from</span> <span class="string">&quot;../components/Tab2.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Vue.use,把vuerouter安装为vue的插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 定义映射关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/c1&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/c1/:cid&quot;</span>, <span class="attr">component</span>: C1 , <span class="attr">props</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="comment">//嵌套路由</span></span><br><span class="line">    &#123; </span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/c2&quot;</span>, </span><br><span class="line">      <span class="attr">component</span>: C2,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab1&quot;</span>, <span class="attr">component</span>: Tab1 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab2&quot;</span>, <span class="attr">component</span>: Tab2 &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享路由实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>vue-router4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按需导入需要的方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="comment">//导入路由组件</span></span><br><span class="line"><span class="keyword">import</span> C1 <span class="keyword">from</span> <span class="string">&quot;../components/C1.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> C2 <span class="keyword">from</span> <span class="string">&quot;../components/C2.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Tab1 <span class="keyword">from</span> <span class="string">&quot;../components/Tab1.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Tab2 <span class="keyword">from</span> <span class="string">&quot;../components/Tab2.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">history</span>: createWebHistory() <span class="comment">//指定通过hash来管理路由的切换</span></span><br><span class="line">  <span class="comment">// 定义映射关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/c1&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/c1/:cid&quot;</span>, <span class="attr">component</span>: C1 , <span class="attr">props</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="comment">//嵌套路由</span></span><br><span class="line">    &#123; </span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/c2&quot;</span>, </span><br><span class="line">      <span class="attr">component</span>: C2,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab1&quot;</span>, <span class="attr">component</span>: Tab1 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab2&quot;</span>, <span class="attr">component</span>: Tab2 &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享路由实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><ol><li>安装路由模块</li><li>创建路由模块</li><li>导入并挂载</li><li>声明地址和占位符</li></ol><p>src下创建router文件夹创建index.js文件，其中写入以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入vue和vuerouter的包</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Vue.use,把vuerouter安装为vue的插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享路由实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>去main.js中使用，又叫挂载</p><p>在vue-router3中挂载方式为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入路由模块</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vue的实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">//把render函数指定的组件，渲染到HTML页面中，替换掉#app的div</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在vue-router4中挂载方式为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = craeateApp(App)</span><br><span class="line">app.use(router)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果名称一致可以简写为router替代router: router</p><p>导入模块可简写为import router from ‘./router’，因为默认导入模块中的index.js文件</p><p>当访问链接时会自动跳转到对应的组件，使用router-link来代替a标签，实际上渲染出来也是a标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#/C1&quot;</span>&gt;C1&lt;<span class="regexp">/a&gt; =&gt; &lt;router-link to=&quot;/</span>C1<span class="string">&quot;&gt;C1&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>路由重定向，避免用户看见空页面</p><p>{ path: “/“, redirect: ‘/home’ }</p><p>嵌套路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 定义映射关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/c1&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/c1&quot;</span>, <span class="attr">component</span>: C1 &#125;,</span><br><span class="line">    <span class="comment">//嵌套路由</span></span><br><span class="line">    &#123; </span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/c2&quot;</span>, </span><br><span class="line">      <span class="attr">component</span>: C2,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab1&quot;</span>, <span class="attr">component</span>: Tab1 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab2&quot;</span>, <span class="attr">component</span>: Tab2 &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相当于代替{ path: “/c2/tab1”, component: Tab1 }</p><p>默认子路由，替换重定向</p><p>{ path: “”, component: Tab1 }</p><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>在路由配置中使用冒号去接收</p><p>{ path: “/c1/:cid”, component: C1 }</p><p>使用this.$route.params.cid获取值，或者开启props为true，在组件中定义props，插值使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">&#123; path: &quot;/c1/:cid&quot;, component: C1 , props: true&#125;</span><br><span class="line">//组件</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;cid&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">c1---&gt;&#123;&#123; cid &#125;&#125;</span><br></pre></td></tr></table></figure><p>上述的<code>&lt;router-link&gt;</code>使用的是声明式导航，还有一种编程式导航，比如js的locaton.href</p><p>vue-router中也提供了很多API</p><p>最常用的API为</p><ul><li>this.$router.push(‘hash地址’)</li></ul><p>跳转到具体的hash地址，并增加一条记录</p><ul><li>this.$router.replace(‘hash地址’)</li></ul><p>跳转到具体的hash地址，并增加一条记录</p><ul><li>this.$router.go(数值n)，n可以为正负数，1表示前进1页，-2表示后退两页</li></ul><p>如果只是前进后退一个页面，vue提供了简单的方法$router.back()和$router.forward()</p><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>可以控制路由的访问权限，可以理解为一个前端的拦截器</p><p><img src="https://image.leidl.top/img/20210902173631.png" alt="image-20210902173630887"></p><h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>vue3的内容，仅适用于vue3，特点是小而巧，缺点是目前不适合于企业级开发</p><h3 id="创建vite项目"><a href="#创建vite项目" class="headerlink" title="创建vite项目"></a>创建vite项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init vite-app 项目名称</span><br><span class="line">cd 项目</span><br><span class="line">npm i</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>与vue-cli类似<br><img src="https://image.leidl.top/img/20210906174226.png" alt="image-20210906174226243"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node_modules //第三方依赖包</span><br><span class="line">public //公共资源文件</span><br><span class="line">src //源码</span><br><span class="line">index.html //SPA项目唯一html页面</span><br><span class="line">package.json //包管理文件</span><br></pre></td></tr></table></figure><p>其中src下<br><img src="https://image.leidl.top/img/20210906174342.png" alt="image-20210906174342731"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assets //存放所有的静态文件</span><br><span class="line">components //存放所有的组件</span><br><span class="line">App.vue //项目根组件</span><br><span class="line">index.css //全局样式表</span><br><span class="line">main.js //项目打包入口文件</span><br></pre></td></tr></table></figure><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><ol><li>通过main.js把App.vue渲染到index.html指定区域中</li><li>App.vue表示待渲染的模板结构</li><li>index.html需要预留一个el区域<br><img src="https://image.leidl.top/img/20210906174932.png" alt="20210906174932.png"></li></ol><h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>在vue3中取消了只有一个根节点的限制</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的注解是如何发挥作用的</title>
      <link href="/post/8e4fa41e.html"/>
      <url>/post/8e4fa41e.html</url>
      
        <content type="html"><![CDATA[<h4 id="注解是干什么的"><a href="#注解是干什么的" class="headerlink" title="注解是干什么的"></a>注解是干什么的</h4><p>注解本身不提供作用，注解只能是被看作元数据，它不包含任何业务逻辑。注解更像是一个标签，一个声明，表面被注释的这个地方，将具有某种特定的逻辑。</p><h4 id="注解常见的种类"><a href="#注解常见的种类" class="headerlink" title="注解常见的种类"></a>注解常见的种类</h4><p>常见的注解有三大类：JDK的，自定义的，第三方的（比如框架）</p><h4 id="注解三板斧"><a href="#注解三板斧" class="headerlink" title="注解三板斧"></a>注解三板斧</h4><p>定义、使用、读取</p><p>定义：包括名字，能用到哪些地方，有效期，是否可以被继承</p><p>使用：定义好之后在允许的地方使用标注即可</p><p>光有前两步，没什么用，如最熟悉的@Override注解，为什么能验证重写是否有效，怎么不是验证重载？spring的@Autowired为什么是注入作用，而不是输出一句话？显然，他们在程序中做了实现，使得其注解具有各自的作用，也具有了意义，而赋予灵魂的一步就是读取</p><p>读取：让注解发挥作用，给注解注入灵魂</p><h4 id="注解前置知识"><a href="#注解前置知识" class="headerlink" title="注解前置知识"></a>注解前置知识</h4><p>首先是元注解，Java中提供了四个</p><p><em><strong>@Documented</strong></em> | <em><strong>@Retention</strong></em> | <em><strong>@Target</strong></em> | <em><strong>@Inherited</strong></em></p><p>分别解释下</p><p>@Documented </p><blockquote><p>代表着此注解会被javadoc工具提取成文档</p></blockquote><p>@Retention：</p><blockquote><p>代表该注解的有效期</p><p><code>SOURCE</code> 表示编译期，如@Override，只做编译时的提示，不会写入字节码中。</p><p><code>CLASS</code>表示类加载期，会保存在class文件中，但在运行class文件被丢弃，也是默认值</p><p><code>RUNTIME</code>  表示运行期，也是最常用的，可以在代码运行时进行反射执行相关的操作</p></blockquote><p>@Target：</p><blockquote><p>表示这个注解可以放在哪</p><p><code>TYPE</code>：接口、类、枚举、注解</p><p><code>FIELD</code>：字段、枚举的常量</p><p><code>METHOD</code>：方法</p><p><code>PARAMETER</code>：参数</p><p><code>CONSTRUCTOR</code>：构造函数</p><p><code>LOCAL_VARIABLE</code>：局部变量</p><p><code>ANNOTATION_TYPE</code>：注解</p><p><code>PACKAGE</code>：包</p></blockquote><p>@Inherited：</p><blockquote><p>表示子类可以继承该类的注解</p></blockquote><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>自己自定义个注解，并赋予它作用，模拟aop功能，在方法前后加入</p><h5 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法前执行</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyBefore &#123;&#125;</span><br><span class="line"><span class="comment">//主要方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyCore &#123;&#125;</span><br><span class="line"><span class="comment">//方法后执行</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAfter &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyBefore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAfter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyCore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">core</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;核心方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前两步简单，重要的是如何赋予注解作用</p><h5 id="读取注解"><a href="#读取注解" class="headerlink" title="读取注解"></a>读取注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWork</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获得测试类</span></span><br><span class="line">        Class clazz = Test.class;</span><br><span class="line">        <span class="comment">//获得一个实例</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        <span class="comment">//获得Test的所有public方法，将他们存入对应的集合中</span></span><br><span class="line">        List&lt;Method&gt; myBeforeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Method&gt; myAfterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Method&gt; myTestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyBefore.class)) &#123;</span><br><span class="line">                myBeforeList.add(method);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyCore.class)) &#123;</span><br><span class="line">                myTestList.add(method);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyAfter.class)) &#123;</span><br><span class="line">                myAfterList.add(method);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用标有MyTest注解的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method test : myTestList) &#123;</span><br><span class="line">            <span class="comment">//在测试方法前先执行标有MyBefore注解的方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : myBeforeList) &#123;</span><br><span class="line">                method.invoke(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用test方法</span></span><br><span class="line">            test.invoke(obj);</span><br><span class="line">            <span class="comment">//在测试方法后执行标有MyAfter注解的方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : myAfterList) &#123;</span><br><span class="line">                method.invoke(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化。。。</span><br><span class="line">核心方法</span><br><span class="line">销毁。。。</span><br></pre></td></tr></table></figure><p>这只是个举个例子，真实的应用场景绝对不会这么简单，比如我们尝试按此套路分析下@Autowired是如何工作的</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="定义注解-1"><a href="#定义注解-1" class="headerlink" title="定义注解"></a>定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Declares whether the annotated dependency is required.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Defaults to &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码看起来不难，规定了有效期在运行期间，并且可以标注在构造器、方法、参数、常量、注解上面，并且定义了一个属性required默认值为true </p><h5 id="使用注解-1"><a href="#使用注解-1" class="headerlink" title="使用注解"></a>使用注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/say&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user.setName(<span class="string">&quot;法外狂徒张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是为了体现spring给我们创建了一个对象，所有不会抛空指针，页面有值</p><p><img src="https://image.leidl.top/img/20210810205814.png" alt="image-20210810205814551"></p><p>那么spring是如何做到的呢？正所谓注解两板斧不难，重要的是第三板斧</p><h5 id="读取注解-1"><a href="#读取注解-1" class="headerlink" title="读取注解"></a>读取注解</h5><p>@Autowired注解由AutowiredAnnotationBeanPostProcessor这个后置器类进行处理</p><p>先获取标注了@Autowired注解的属性或方法并存入一个集合中，通过反射的方式注入进去</p><p>注入的方法是该后置器的postProcessProperties方法的inject方法</p><p><img src="https://image.leidl.top/img/20210811224127.png" alt="image-20210811224127127"></p><p>这两种方法同样在后置器类中对InjectionMetadata进行了重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">   Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">         (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">   <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">         <span class="comment">//核心由于AutowiredAnnotationBeanPostProcessor重写了inject，所以会根据传入的元素类型来调用不同的方法，注入属性或者调用方法</span></span><br><span class="line">         element.inject(target, beanName, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果标注的是属性那么调用AutowiredFieldElement方法</p><p><img src="https://image.leidl.top/img/20210812135029.png" alt="image-20210812135029193"></p><p>这里表明会给我的user属性附上一个user对象</p><p>如果标注的是方法那么调用AutowiredMethodElement方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行标注了@Autowired的方法</span></span><br><span class="line">      ReflectionUtils.makeAccessible(method);</span><br><span class="line">      method.invoke(bean, arguments);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码拓展"><a href="#源码拓展" class="headerlink" title="源码拓展"></a>源码拓展</h4><p>如果深入了解下@Autowired可以看下去</p><p>整个过程的调用情况，其中postProcessPropertyValues已弃用，取而代之的是postProcessProperties</p><p><img src="https://img-blog.csdnimg.cn/20190319171936407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>整个过程的源码调用非常的多，<code>建议自己动手debug</code>，不然会蒙圈</p><h4 id="疑问一如何具备匹配Autowired的能力？"><a href="#疑问一如何具备匹配Autowired的能力？" class="headerlink" title="疑问一如何具备匹配Autowired的能力？"></a>疑问一如何具备匹配Autowired的能力？</h4><p>在创建出AutowiredAnnotationBeanPostProcessor后置类的时候进行了初始化，将Autowired这个注解类型放入了集合中，方便后面匹配使用，那么如何进行该后置器类的初始化？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">   <span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="疑问二：那么如何进行AutowiredAnnotationBeanPostProcessor后置器类的初始化？"><a href="#疑问二：那么如何进行AutowiredAnnotationBeanPostProcessor后置器类的初始化？" class="headerlink" title="疑问二：那么如何进行AutowiredAnnotationBeanPostProcessor后置器类的初始化？"></a>疑问二：那么如何进行AutowiredAnnotationBeanPostProcessor后置器类的初始化？</h4><p>在spring容器启动的时候会调用关键的refresh方法，其中有一步就是去注册所有的后置器类，自然也包括AutowiredAnnotationBeanPostProcessor这个类<img src="https://image.leidl.top/img/20210810213744.png" alt="image-20210810213743919"></p><h4 id="疑问三：AutowiredAnnotationBeanPostProcessor激活之后如何去获取到注解标注的属性或方法"><a href="#疑问三：AutowiredAnnotationBeanPostProcessor激活之后如何去获取到注解标注的属性或方法" class="headerlink" title="疑问三：AutowiredAnnotationBeanPostProcessor激活之后如何去获取到注解标注的属性或方法"></a>疑问三：AutowiredAnnotationBeanPostProcessor激活之后如何去获取到注解标注的属性或方法</h4><p>如图11步，该后置器类有一个findAutowiringMetadata方法，找到的话最后返回一个InjectionMetadata集合，后面利用这个集合中的元素来进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//核心</span></span><br><span class="line">                metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何获取这个元素的？核心方法为buildAutowiringMetadata</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="comment">//省略之前</span></span><br><span class="line">    <span class="comment">//找到带有@Autowired注解的属性并封装为AutowiredFieldElement</span></span><br><span class="line">      ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">          <span class="comment">//核心</span></span><br><span class="line">         MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">         <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                  logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">            currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="comment">//找到带有@Autowired注解的方法并封装为AutowiredMethodElement</span></span><br><span class="line">      ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">         Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">         <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="comment">//核心</span></span><br><span class="line">         MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">         <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                  logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                  logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                        method);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">            PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">            currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">      targetClass = targetClass.getSuperclass();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这两个方法中都有一个findAutowiredAnnotation方法，作用是找到带有@Autowired和@Value注解的属性和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">   MergedAnnotations annotations = MergedAnnotations.from(ao);</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">      MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">      <span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">         <span class="keyword">return</span> annotation;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将<strong>AutowiredFieldElement</strong>和<strong>AutowiredMethodElement</strong>对象的封装成<strong>InjectionMetadata</strong>，完成对注解的收集，如果找不到就返回null</p><h4 id="疑问四：在拥有收集好注解的集合后，在哪里去使用？"><a href="#疑问四：在拥有收集好注解的集合后，在哪里去使用？" class="headerlink" title="疑问四：在拥有收集好注解的集合后，在哪里去使用？"></a>疑问四：在拥有收集好注解的集合后，在哪里去使用？</h4><p>这个问题也可以改为如何进行依赖注入的？</p><p>这时候refresh的registerBeanPostProcessors方法也执行完了，然后来执行finishBeanFactoryInitialization</p><p><img src="https://image.leidl.top/img/20210812152011.png" alt="image-20210812152011029"></p><p>中间一大串调用就不说了，可以自己debug去看，主要说下调用到后置器类的postProcessProperties方法</p><p>可以粗略理解为finishBeanFactoryInitialization — &gt; xxxxxxx —-&gt; postProcessProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">   InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//核心</span></span><br><span class="line">      metadata.inject(bean, beanName, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点进去，里面有个InjectedElement抽象类，而之前的这两个封装对象也就用到了</p><p><img src="https://image.leidl.top/img/20210812152622.png" alt="image-20210812152622107"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">   Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">         (checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">   <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">          <span class="comment">//根据不同的元素类型去调用不同的注入方法</span></span><br><span class="line">         element.inject(target, beanName, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就对应上开头的那段代码了</p><h4 id="疑问五：开头的那段代码中的bean时怎么获取的？"><a href="#疑问五：开头的那段代码中的bean时怎么获取的？" class="headerlink" title="疑问五：开头的那段代码中的bean时怎么获取的？"></a>疑问五：开头的那段代码中的bean时怎么获取的？</h4><p>因为开头只展示了属性注入了对象，没说这个对象是怎么获取的，获取的方法为resolveFieldValue，这个方法是在属性注入前调用的</p><p><img src="https://image.leidl.top/img/20210812153128.png" alt="image-20210812153128145"></p><p>别看方法一大堆，真正有用的就是红框中的那个，其他是缓存的处理</p><p>点进去之后一般执行else方法</p><p><img src="https://image.leidl.top/img/20210812153304.png" alt="image-20210812153304732"></p><p>这个方法也是一大堆，主要讲了matchingBeans集合的获取与调用，这个集合存的是依赖对象的所有实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//前面省略</span></span><br><span class="line">    Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">        <span class="comment">//后面省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里利用获取的map集合进行bean的实例化返回，具体判断规则感兴趣的可以看源码</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>任何的注解都是三板斧，难点在于如何读取注解并赋予它作用，推荐看springboot的一些注解，它开发利用注解替代了很多的配置文件，可以看看是怎么做到的，看源码实现可以学到很多东西，不过需要一定的内功，比如良好的基础，尤其是对反射这块需要很清楚，还有设计模式也是非常重要的，源码中也有很多地方得到了体现</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot启动过程</title>
      <link href="/post/78c07335.html"/>
      <url>/post/78c07335.html</url>
      
        <content type="html"><![CDATA[<p>这个图做的很好：<a href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e">SpringBoot启动结构图</a></p><p>springboot启动分为构造器部分和run部分</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化资源加载器</span></span><br><span class="line">   <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">//断言资源加载器不为null，否则报错</span></span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">//初始化资源</span></span><br><span class="line">   <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">//推断当前的web应用类型（非WEB / SERVLET / REACTIVE）</span></span><br><span class="line">   <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">//初始化bootstrap启动器，将所有pom中的start加载进来</span></span><br><span class="line">   <span class="keyword">this</span>.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">    <span class="comment">//初始化spring.factories文件的所有组件信息，并放入缓存中</span></span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">//初始化应用监听器</span></span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">//推断主程序类</span></span><br><span class="line">   <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><p>运行SpringApplication</p><p>创建上下文—启动监听器—创建IOC容器—准备环境—刷新IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录应用启动时间</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">//创建引导上下文，获得所有的bootstraps逐个执行</span></span><br><span class="line">    DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//进入自力更生模式（Headless模式）</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">//获取到所有的listener</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">//遍历所有的listener调用starting方法，通知当前项目正在启动</span></span><br><span class="line">    listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//保存命令行参数</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">//准备环境</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="comment">//配置忽略信息</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">//打印bannner</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">//创建IOC容器</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">//设置start</span></span><br><span class="line">        context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">        <span class="comment">//准备环境信息</span></span><br><span class="line">        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">//刷新IOC容器，创建容器中的所有组件</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">//刷新后需要完成的工作</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">//记录停止时间</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向观察者发布上下文已启动</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">//调用所有runners</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//向观察者发布上下文已就绪</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回应用上下文</span></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个比较重要的步骤</p><h4 id="准备上下文环境"><a href="#准备上下文环境" class="headerlink" title="准备上下文环境"></a>准备上下文环境</h4><p>也是创建IOC容器—createApplicationContext</p><p>根据当前项目类型创建容器，最后返回一个AnnotationConfigServletWebServerApplicationContext容器对象</p><p><img src="https://image.leidl.top/img/20210810165517.png" alt="image-20210810165517194"></p><p>保存当前环境信息</p><p>应用初始化器applyInitializers，遍历并调用对IOC容器进行初始化</p><p>通知所有的监听器</p><h4 id="刷新IOC容器refreshContext-context"><a href="#刷新IOC容器refreshContext-context" class="headerlink" title="刷新IOC容器refreshContext(context)"></a>刷新IOC容器refreshContext(context)</h4><p>这个涉及的内容比较多，打算单独在开一篇文章，作用就是实例化了bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">      <span class="comment">//设置容器状态，初始化</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">      <span class="comment">//获取bean工厂</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">  <span class="comment">//准备bean工厂</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//bean工厂后置处理器</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">         <span class="comment">//实现bean工厂的后置处理器</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">         <span class="comment">// 注册bean工厂的后置处理器</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         beanPostProcess.end();</span><br><span class="line">         <span class="comment">//初始化消息源</span></span><br><span class="line">         initMessageSource();</span><br><span class="line">         <span class="comment">//初始化时间广播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line">         <span class="comment">//初始化特定子类及特殊bean</span></span><br><span class="line">         onRefresh();</span><br><span class="line">         <span class="comment">//检查监听器并注册</span></span><br><span class="line">         registerListeners();</span><br><span class="line">         <span class="comment">//实例化所有的单例（非lazy）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">         <span class="comment">//刷新，发布相应的事件</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//catch、finally省略</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot自动配置原理</title>
      <link href="/post/524e74d7.html"/>
      <url>/post/524e74d7.html</url>
      
        <content type="html"><![CDATA[<p>在使用springboot进行开发的时候，只需要在application.properties中进行参数配置，不配置也会有一个默认值，tomcat，映射关系都不用配置了，那么spring是如何实现自动配置的呢？</p><h4 id="springboot如何实现自动装配"><a href="#springboot如何实现自动装配" class="headerlink" title="springboot如何实现自动装配"></a>springboot如何实现自动装配</h4><p>自动配置的。这都要归功于springboot强大的注解功能，也是springboot的一大特点</p><p>举例：在springboot主运行程序中，下面是常见的springboot启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootSrcApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootSrcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来平平无奇，但为什么一运行main方法就会启动容器？</p><p>spring会在启动的时候new自己—&gt;new SpringApplication(primarySources).run(args)这时候就会初始化，并加载扫描到所有的组件进入缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">   Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">   <span class="comment">//后面这个类会经常用到，所以spring做了缓存，如果有直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//没有会扫描META-INF/spring.factories的所有组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次扫描结果如下，返回18个结果，其中就有后面需要的自动配置包，如红框所示</p><p><img src="https://image.leidl.top/img/20210812175255.png" alt="image-20210812175255284"></p><h4 id="这么多组件，哪个才会真正的被容器所实例化？"><a href="#这么多组件，哪个才会真正的被容器所实例化？" class="headerlink" title="这么多组件，哪个才会真正的被容器所实例化？"></a>这么多组件，哪个才会真正的被容器所实例化？</h4><p>其实真正发挥作用的是@Import()，它导什么，容器实例化什么</p><p>先来从@SpringBootApplication这个注解说起</p><p><img src="https://image.leidl.top/img/20210810114704.png" alt="image-20210810114455286"></p><p>主要的注解为@SpringBootConfiguration+@ComponentScan+@EnableAutoConfiguration</p><p>前两个没什么好说的，@SpringBootConfiguration就是封装了@Configuration注解，表示他是一个配置类</p><p><img src="https://image.leidl.top/img/20210810114947.png" alt="image-20210810114947459"></p><p>@ComponentScan：扫描注解，表示哪些会被spring扫描到</p><p>那么重要的就是@EnableAutoConfiguration，见名知意拥有自动配置的能力，点进去看下</p><p><img src="https://image.leidl.top/img/20210812181648.png" alt="image-20210812181648668"></p><p>主要注解为@AutoConfigurationPackage+@Import，而@AutoConfigurationPackage其中也是@Import，所以起到主要作用的就是@Import这个注解了</p><p>@Import：给容器中导入一个组件，前提是必须作用于spring的组件下，可以自动调用组件的无参构造器创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上图可知import导入了AutoConfigurationImportSelector.class这个组件，那么程序中是什么时候导入的？</p><p>spring容器启动会刷新IOC容器（refreshContext(context)）执行invokeBeanFactoryPostProcessors方法，最终调用到getImports()这个方法，这个方法会将标有@Import的组件进行实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">   <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="keyword">this</span>.deferredImports) &#123;</span><br><span class="line">       <span class="comment">//核心process</span></span><br><span class="line">      <span class="keyword">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">            deferredImport.getImportSelector());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.group.selectImports();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法会执行AutoConfigurationImportSelector类的process方法</p><p>调用核心方法SpringFactoriesLoader.loadFactoryNames导入一系列组件</p><p><img src="https://image.leidl.top/img/20210810150103.png" alt="image-20210810150102886"></p><h4 id="拓展部分，怎么导入的？"><a href="#拓展部分，怎么导入的？" class="headerlink" title="拓展部分，怎么导入的？"></a>拓展部分，怎么导入的？</h4><p>接上段程序，调用关键语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">      getBeanClassLoader());</span><br></pre></td></tr></table></figure><p>其中getSpringFactoriesLoaderFactoryClass()返回的正是@EnableAutoConfiguration这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">   <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进去loadFactoryNames</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">   <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//根据上面代码获得EnableAutoConfiguration的完整类名（全类名，包括包名）</span></span><br><span class="line">    <span class="comment">//org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line">   String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="comment">//loadSpringFactories(classLoaderToUse)就是刚开始初始化的18个结果集</span></span><br><span class="line">    <span class="comment">//后面的get方法就是Map的方法，根据这个全类名可以获取到自动配置包下的所有组件（类）</span></span><br><span class="line">    <span class="comment">//也就是上面截图中的131个组件</span></span><br><span class="line">   <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="怎么实例化的"><a href="#怎么实例化的" class="headerlink" title="怎么实例化的"></a>怎么实例化的</h4><p>spring在刷新IOC的最后一步会调用finishBeanFactoryInitialization(beanFactory)方法，来实例化剩余的非lazy的单例，在调用过程中beanFactory.preInstantiateSingletons()，该方法会遍历所有的bean</p><p><img src="https://image.leidl.top/img/20210812184747.png" alt="image-20210812184747238"></p><p>然后调用工厂的getBean方法进行实例化</p><p><img src="https://image.leidl.top/img/20210812185015.png" alt="image-20210812185015122"></p><p>但并不是这133个都会被实例化，还得看条件注解，实现了按需配置</p><p>注解有如下几项：</p><blockquote><p>@ConditionalOnBean：当容器里有指定的bean的条件下</p><p>@ConditionalOnMissingBean：当容器里不存在指定bean的条件下</p><p>@ConditionalOnClass：当类路径下有指定类的条件下</p><p>@ConditionalOnMissingClass：当类路径下不存在指定类的条件下</p><p>@ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix=”xxx.xxx”, value=”enable”, matchIfMissing=true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true</p></blockquote><p>比如DispatcherServletAutoConfiguration自动配置类中满足DispatcherServlet类存在，并且当前环境是SERVLET的时候才会进行实例化</p><p><img src="https://image.leidl.top/img/20210812185340.png" alt="image-20210812185340454"></p><p>反观KafkaAutoConfiguration，由于没有导入对应的包KafkaTemplate类也就不存在了，自然这个自动配置类也不会进行实例化</p><p><img src="https://image.leidl.top/img/20210812190428.png" alt="image-20210812190428211"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>springboot在启动的时候会实例化自动配置包下的组件和我们自定义的组件</p><p><img src="https://image.leidl.top/img/20210812185624.png" alt="image-20210812185624610"></p><p>我们可以自定义组件也可以按需加载组件，还可以重写spring的组件，因为会优先取用户的配置，没有才会给你默认装配，以上就是关于springboot自动配置的一些原理</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Butterfly美化</title>
      <link href="/post/6016428b.html"/>
      <url>/post/6016428b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于我博客的整个搭建过程可以参照我知乎<a href="https://zhuanlan.zhihu.com/p/397544165">这篇文章</a></p><p>有涉及到修改源码的部分，Butterfly 版本<mark class="hl-label orange">3.8.3</mark> </p><p>优先考虑顺序：插件 &gt; 自定义css &gt; 魔改（改源码）</p><h2 id="背景板"><a href="#背景板" class="headerlink" title="背景板"></a>背景板</h2><p>该调整不涉及源码修改。原先的主题分为了上中下三层结构，我觉得过于花了，统一改为了一种背景，<del>文章栏与侧边栏透明思路也简单，只留背景，其余部分去色</del>，替换为背景图的方式，背景0.9透明，主题色做出了调整，可以在主题文件中的theme_color中修改</p><details ><summary> 效果预览（旧） </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210808145947.png" alt="image-20210808145943484"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <p>在themes/source/css下创建自己的css文件<br><img src="https://image.leidl.top/img/20210808150305.png" alt="image-20210808150305780"><br>加入以下代码，前提是将_config.butterfly文件中的background不能为空且与index_img一致<br>首先是调整背景板为一体（但在暗黑模式下，页脚还会出现阴影快）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页脚去色 */</span></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用opacity可以设置当前透明度，避免切换dark模式产生颜色单一的问题 */</span></span><br><span class="line"><span class="comment">/* 文章栏变色 */</span></span><br><span class="line"><span class="selector-id">#recent-posts</span>&gt;<span class="selector-class">.recent-post-item</span>,<span class="selector-class">.layout_page</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child<span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>),<span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#page</span>,<span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>,<span class="selector-class">.read-mode</span> <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 侧边栏去色 */</span></span><br><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.card-widget</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="替换为阿里图标"><a href="#替换为阿里图标" class="headerlink" title="替换为阿里图标"></a>替换为阿里图标</h2><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210808151146.png" alt="image-20210808151146237"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <p>阿里巴巴矢量图标库提供了三种引入方案，其实也就是两种，一种单色，一种多色（需要改源码）<del>既然都是引入，不会真有人自己写css吧</del><br>推荐symbol引入这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。本教程来源于<a href="https://akilar.top/posts/d2ebecef/">这篇文章</a></p><h3 id="新建图标"><a href="#新建图标" class="headerlink" title="新建图标"></a>新建图标</h3><ol><li>进入<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a> , 注册登录</li><li>加入自己需要的图标</li><li>添加到项目中<br><img src="https://image.leidl.top/img/20210908211946.png" alt="image-20210908211946137"></li></ol><h3 id="引入图标"><a href="#引入图标" class="headerlink" title="引入图标"></a>引入图标</h3><p>官方提供了三种方式，我只列举我的彩色实现方案，彩色的本质是因为它是一个<code>svg</code>，源码中不支持这种能力，所以需要调整源码</p><ol><li>修改 [root]\themes\butterfly\layout\includes\header\menu_item.pug<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  if theme.menu</span><br><span class="line">    //- for mobile sidebar</span><br><span class="line">    - let sidebarChildHide = theme.hide_sidebar_menu_child ? &#x27;hide&#x27; : &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    .menus_items</span><br><span class="line">      each value, label in theme.menu</span><br><span class="line">        if typeof value !== &#x27;object&#x27;</span><br><span class="line">          .menus_item</span><br><span class="line">            a.site-page(href=url_for(trim(value.split(&#x27;||&#x27;)[0])))</span><br><span class="line">              if value.split(&#x27;||&#x27;)[1]</span><br><span class="line"><span class="deletion">-               i.fa-fw(class=trim(value.split(&#x27;||&#x27;)[1]))</span></span><br><span class="line"><span class="addition">+               - var icon_value = trim(value.split(&#x27;||&#x27;)[1])</span></span><br><span class="line"><span class="addition">+               if icon_value.substring(0,2)==&quot;fa&quot;      </span></span><br><span class="line"><span class="addition">+                 i.fa-fw(class=icon_value)</span></span><br><span class="line"><span class="addition">+               else if icon_value.substring(0,4)==&quot;icon&quot;          </span></span><br><span class="line"><span class="addition">+                 svg.icon(aria-hidden=&quot;true&quot;)</span></span><br><span class="line"><span class="addition">+                   use(xlink:href=`#`+ icon_value)</span></span><br><span class="line">              span=&#x27; &#x27;+label</span><br><span class="line">        else</span><br><span class="line">          .menus_item</span><br><span class="line">            a.site-page(href=&#x27;javascript:void(0);&#x27;)</span><br><span class="line">              if label.split(&#x27;||&#x27;)[1]</span><br><span class="line"><span class="deletion">-               i.fa-fw(class=trim(label.split(&#x27;||&#x27;)[1]))</span></span><br><span class="line"><span class="addition">+               - var icon_label = trim(label.split(&#x27;||&#x27;)[1])</span></span><br><span class="line"><span class="addition">+               if icon_label.substring(0,2)==&quot;fa&quot;      </span></span><br><span class="line"><span class="addition">+                 i.fa-fw(class=icon_label)</span></span><br><span class="line"><span class="addition">+               else if icon_label.substring(0,4)==&quot;icon&quot;    </span></span><br><span class="line"><span class="addition">+                 svg.icon(aria-hidden=&quot;true&quot;)</span></span><br><span class="line"><span class="addition">+                   use(xlink:href=`#`+ icon_label)</span></span><br><span class="line">              span=&#x27; &#x27;+ trim(label.split(&#x27;||&#x27;)[0])</span><br><span class="line">              i.fas.fa-chevron-down.expand(class=sidebarChildHide)</span><br><span class="line">            ul.menus_item_child</span><br><span class="line">              each val,lab in value</span><br><span class="line">                li</span><br><span class="line">                  a.faa-parent.animated-hover.site-page.child(href=url_for(trim(val.split(&#x27;||&#x27;)[0])))</span><br><span class="line">                    if val.split(&#x27;||&#x27;)[1]</span><br><span class="line"><span class="deletion">-                     i.fa-fw(class=trim(val.split(&#x27;||&#x27;)[1]))</span></span><br><span class="line"><span class="addition">+                     - var icon_val = trim(val.split(&#x27;||&#x27;)[1])</span></span><br><span class="line"><span class="addition">+                     if icon_val.substring(0,2)==&quot;fa&quot;      </span></span><br><span class="line"><span class="addition">+                       i.fa-fw(class=icon_val)</span></span><br><span class="line"><span class="addition">+                     else if icon_val.substring(0,4)==&quot;icon&quot;</span></span><br><span class="line"><span class="addition">+                       svg.icon(aria-hidden=&quot;true&quot;)</span></span><br><span class="line"><span class="addition">+                         use(xlink:href=`#`+ icon_val)</span></span><br><span class="line">                    span=&#x27; &#x27;+ lab</span><br></pre></td></tr></table></figure></li><li>直接复制版<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">if theme.menu</span><br><span class="line">  //- for mobile sidebar</span><br><span class="line">  - let sidebarChildHide = theme.hide_sidebar_menu_child ? &#x27;hide&#x27; : &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">  .menus_items</span><br><span class="line">    each value, label in theme.menu</span><br><span class="line">      if typeof value !== &#x27;object&#x27;</span><br><span class="line">        .menus_item</span><br><span class="line">          a.site-page(href=url_for(trim(value.split(&#x27;||&#x27;)[0])))</span><br><span class="line">            if value.split(&#x27;||&#x27;)[1]</span><br><span class="line">              - var icon_value = trim(value.split(&#x27;||&#x27;)[1])</span><br><span class="line">              if icon_value.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">                i.fa-fw(class=icon_value)</span><br><span class="line">              else if icon_value.substring(0,4)==&quot;icon&quot;          </span><br><span class="line">                svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">                  use(xlink:href=`#`+ icon_value)</span><br><span class="line">            span=&#x27; &#x27;+label</span><br><span class="line">      else</span><br><span class="line">        .menus_item</span><br><span class="line">          a.site-page(href=&#x27;javascript:void(0);&#x27;)</span><br><span class="line">            if label.split(&#x27;||&#x27;)[1]</span><br><span class="line">              - var icon_label = trim(label.split(&#x27;||&#x27;)[1])</span><br><span class="line">              if icon_label.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">                i.fa-fw(class=icon_label)</span><br><span class="line">              else if icon_label.substring(0,4)==&quot;icon&quot;    </span><br><span class="line">                svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">                  use(xlink:href=`#`+ icon_label)</span><br><span class="line">            span=&#x27; &#x27;+ trim(label.split(&#x27;||&#x27;)[0])</span><br><span class="line">            i.fas.fa-chevron-down.expand(class=sidebarChildHide)</span><br><span class="line">          ul.menus_item_child</span><br><span class="line">            each val,lab in value</span><br><span class="line">              li</span><br><span class="line">                a.site-page.child(href=url_for(trim(val.split(&#x27;||&#x27;)[0])))</span><br><span class="line">                  if val.split(&#x27;||&#x27;)[1]</span><br><span class="line">                    - var icon_val = trim(val.split(&#x27;||&#x27;)[1])</span><br><span class="line">                    if icon_val.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">                      i.fa-fw(class=icon_val)</span><br><span class="line">                    else if icon_val.substring(0,4)==&quot;icon&quot;</span><br><span class="line">                      svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">                        use(xlink:href=`#`+ icon_val)</span><br><span class="line">                  span=&#x27; &#x27;+ lab</span><br></pre></td></tr></table></figure></li><li>使用方式<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">icon-shouye_huaban</span></span><br><span class="line">  <span class="string">文章</span> <span class="string">||</span> <span class="attr">icon-wenzhang :</span></span><br><span class="line">    <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">icon-shijianzhou</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">icon-biaoqian-copy-copy</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">icon-ziyuan</span></span><br><span class="line">  <span class="string">闲言碎语:</span> <span class="string">/talk/</span> <span class="string">||</span> <span class="string">icon-liuyanban</span></span><br><span class="line">  <span class="string">友情链接:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">icon-lianjie</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/board/</span> <span class="string">||</span> <span class="string">icon-xiaoxi</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">icon-bixin1</span></span><br></pre></td></tr></table></figure>上面是菜单的，接下来替换social图标</li><li>修改 [root]\themes\butterfly\layout\includes\header\social.pug, 替换为以下代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">each value, title in theme.social</span><br><span class="line">  a.social-icon(href=url_for(trim(value.split(&#x27;||&#x27;)[0])) target=&quot;_blank&quot; title=title === undefined ? &#x27;&#x27; : trim(title))</span><br><span class="line">    if value.split(&#x27;||&#x27;)[1]</span><br><span class="line">      - var icon_value = trim(value.split(&#x27;||&#x27;)[1])</span><br><span class="line">      if icon_value.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">        i.fa-fw(class=icon_value)</span><br><span class="line">      else if icon_value.substring(0,4)==&quot;icon&quot;          </span><br><span class="line">        svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">          use(xlink:href=`#`+ icon_value)</span><br></pre></td></tr></table></figure></li><li>使用方式<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">gitee:</span> <span class="string">https://github.com/bigli97</span> <span class="string">||</span> <span class="string">icon-gitee</span></span><br><span class="line">  <span class="attr">zhihu:</span> <span class="string">https://www.zhihu.com/people/da-hu-you-55-56</span> <span class="string">||</span> <span class="string">icon-zhihu</span></span><br><span class="line">  <span class="attr">juejin:</span> <span class="string">https://juejin.cn/user/2093100615603101</span> <span class="string">||</span> <span class="string">icon-juejin</span></span><br></pre></td></tr></table></figure></li></ol>              </div>            </details><h2 id="说说"><a href="#说说" class="headerlink" title="说说"></a>说说</h2><p>不怕折腾的可以考虑。我这里配置了两套，一个手机发用于首页顶部显示，一个电脑发用于<a href="http://localhost:4000/talk/">闲言碎语</a></p><div class="tabs" id="talk"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#talk-1">Artitalk</button></li><li class="tab"><button type="button" data-href="#talk-2">哔哔</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="talk-1"><p><mark class="hl-label blue">前置要求</mark> 参照<a href="https://artitalk.js.org/doc.html">官方文档</a>的LeanCloud 的相关准备环节，一定要每一步都配置<br><mark class="hl-label orange">调用方式</mark> 采用插件的方式</p><blockquote><ol><li>前往 <a href="https://leancloud.app/">LeanCloud 国际版</a>，注册账号。</li><li>注册完成之后根据 LeanCloud 的提示绑定手机号和邮箱。</li><li>绑定完成之后点击<code>创建应用</code>，应用名称随意，接着在<code>结构化数据</code>中创建 <code>class</code>，命名为 <code>shuoshuo</code>。</li><li>在你新建的应用中找到<code>结构化数据</code>下的<code>用户</code>。点击<code>添加用户</code>，输入想用的用户名及密码。</li><li>回到<code>结构化数据</code>中，点击 <code>class</code> 下的 <code>shuoshuo</code>。找到权限，在 <code>Class 访问权限</code>中将 <code>add_fields</code> 以及 <code>create</code> 权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将 <code>delete</code> 和 <code>update</code> 也设置为跟它们一样的权限。</li><li>然后新建一个名为<code>atComment</code>的class，权限什么的使用默认的即可。</li><li>点击 <code>class</code> 下的 <code>_User</code> 添加列，列名称为 <code>img</code>，默认值填上你这个账号想要用的发布说说的头像url，这一项不进行配置，说说头像会显示为默认头像 —— Artitalk 的 logo。</li><li>在最菜单栏中找到设置-&gt; 应用 keys，记下来 <code>AppID</code> 和 <code>AppKey</code> ，一会会用。</li><li>最后将 <code>_User</code> 中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据已达到强制发布说说。</li></ol></blockquote><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210808155431.png" alt="image-20210808155431123"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <p>安装Artitalk插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-artitalk</span><br></pre></td></tr></table></figure><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">artitalk:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">appId:</span> <span class="string">你的appId</span></span><br><span class="line">    <span class="attr">appKey:</span> <span class="string">你的appKey</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">talk（标签路径，如果没有会给你自动生成）</span></span><br><span class="line">    <span class="attr">js:</span></span><br><span class="line">    <span class="attr">option:</span></span><br><span class="line">        <span class="attr">serverURL:</span> <span class="string">国内用户必填，对应</span> <span class="string">LeanCloud</span> <span class="string">创建的应用中绑定的</span> <span class="string">API</span> <span class="string">域名</span></span><br><span class="line">    <span class="attr">front_matter:</span></span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="talk-2"><p><mark class="hl-label blue">前置要求</mark> 参照<a href="https://immmmm.com/bb-by-wechat-pro">该作者的教程</a>配置好所需的云函数<br>涉及到了腾讯云存储，其实最后也就是需要调用请求的一个方式就可以随时随地发送了<br><mark class="hl-label orange">调用方式</mark> 我目前找到的有一个edge插件发送，还有ios的快捷指令发送，相关文档可查看<a href="https://www.antmoe.com/posts/7ec820ee/">小康</a>和<a href="https://blog.zhheo.com/p/a6947667.html">HEO</a>的文章</p><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210808161528.png" alt="image-20210808161528776"></p>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>前期用的valine，后来换为了twikoo，主要是valine不好管理，但配置起来挺快的，而twikoo配置起来会麻烦一点，不怕折腾的推荐twikoo<br>这里就只说下twikoo吧，valine有兴趣可以看<a href="https://github.com/xCss/Valine">官方文档</a></p><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210808162322.png" alt="image-20210808162322884"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <p>twikoo<a href="https://twikoo.js.org/quick-start.html">官方文档</a>推荐了4种云函数部署方式，官方建议<mark class="hl-label orange">Vercel部署</mark> ，优点是免费<br>同样，严格按照步骤来，不过这里我推荐观看<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">视频教程</a>，我当时就给整晕了</p><blockquote><ol><li>申请 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB (opens new window)</a>账号</li><li>创建免费 MongoDB 数据库，区域推荐选择 <code>AWS / N. Virginia (us-east-1)</code></li><li>在 Clusters 页面点击 CONNECT，按步骤设置允许所有 IP 地址的连接（<a href="https://vercel.com/support/articles/how-to-allowlist-deployment-ip-address">为什么？ (opens new window)</a>），创建数据库用户，并记录数据库连接字符串，请将连接字符串中的 <code>&lt;password&gt;</code> 修改为数据库密码</li><li>申请 <a href="https://vercel.com/signup">Vercel (opens new window)</a>账号</li><li>点击以下按钮将 Twikoo 一键部署到 <mark class="hl-label blue">Vercel</mark> </li><li>添加环境变量 <code>MONGODB_URI</code> 到 Vercel，值为第 3 步的数据库连接字符串</li><li>Vercel 环境地址（包含 <code>https://</code> 前缀）即为您的环境 id</li></ol></blockquote>              </div>            </details><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>加了一个效果，npm插件的方式，很奈斯，来源于作者Akilar</p><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="/../../../img/board.gif" alt="image-20210808163935"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <p>安装插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-envelope --save</span><br></pre></td></tr></table></figure><p>主题配置文件添加如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">envelope_comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cover:</span> <span class="string">https://ae01.alicdn.com/kf/U5bb04af32be544c4b41206d9a42fcacfd.jpg</span> <span class="comment"># 信笺封面图</span></span><br><span class="line">  <span class="attr">message:</span>  <span class="comment"># 信笺内容，支持多行</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想问的？</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想说的？</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想吐槽的？</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="string">自动书记人偶竭诚为您服务！</span>   <span class="comment"># 信笺结束语，只能单行</span></span><br><span class="line">  <span class="attr">height:</span>                          <span class="comment"># 调整信笺划出高度，默认1050px</span></span><br><span class="line">  <span class="attr">path:</span>                            <span class="comment"># 【可选】comments 的路径名称。默认为 comments ， 生成的页面为 comments/index.html</span></span><br><span class="line">  <span class="attr">front_matter:</span>                    <span class="comment"># 【可选】comments页面的 front_matter 配置</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">留言板</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">aside:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id=""><a href="#" class="headerlink" title=""></a><del>古诗词</del></h2><p>来源于HEO，需要修改源码，我把诗词这块转移到了banner图中</p><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210808164644.png" alt="image-20210808164644725"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <p>在themes/butterfly/layout/includes/widget下新建<code>card_poem.pug</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#card-poem.card-widget</span><br><span class="line">    #poem_sentence</span><br><span class="line">    #poem_info</span><br><span class="line">        #poem_dynasty</span><br><span class="line">        #poem_author</span><br><span class="line">script(src=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/poem/jinrishici.js&#x27;</span>, charset=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">script(type=<span class="string">&#x27;text/javascript&#x27;</span>).</span><br><span class="line">  jinrishici.load(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sentence = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#poem_sentence&quot;</span>)</span><br><span class="line">  <span class="keyword">var</span> author = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#poem_author&quot;</span>)</span><br><span class="line">  <span class="keyword">var</span> dynasty = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#poem_dynasty&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sentenceText = result.data.content</span><br><span class="line">  sentenceText = sentenceText.substr(<span class="number">0</span>, sentenceText.length - <span class="number">1</span>);</span><br><span class="line">  sentence.innerHTML = sentenceText</span><br><span class="line">  dynasty.innerHTML = result.data.origin.dynasty</span><br><span class="line">  author.innerHTML = result.data.origin.author + <span class="string">&#x27;《&#x27;</span> + result.data.origin.title + <span class="string">&#x27;》&#x27;</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在themes/butterfly/layout/includes/widget/index.pug下添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!=partial(<span class="string">&#x27;includes/widget/card_poem&#x27;</span>, &#123;&#125;, &#123;<span class="attr">cache</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>位置如下</p><p><img src="https://image.leidl.top/img/20210808165528.png" alt="image-20210808165528320"></p><p>在主题中引入两个css</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">type=&quot;text/css&quot;</span> <span class="string">href=&quot;https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/mainColor/heoMainColor.css&quot;&gt;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">type=&quot;text/css&quot;</span> <span class="string">href=&quot;https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/poem/poem.css&quot;&gt;</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="历史上的今天"><a href="#历史上的今天" class="headerlink" title="历史上的今天"></a>历史上的今天</h2><p>一个很有意思的插件，来源于<a href="https://zfe.space/post/hexo-history-calendar.html">小冰</a></p><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210827173219.png"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-history-calendar --save</span><br></pre></td></tr></table></figure><p>在hexo的配置文件中添加如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">history_calendar:</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">4</span> <span class="comment">#优先级</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment">#all表示全站，/表示仅主页</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment">#保持默认</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">temple_html:</span> <span class="string">&#x27;&lt;div class=&quot;card-widget card-history&quot;&gt;&lt;div class=&quot;card-content&quot;&gt;&lt;div class=&quot;item-headline&quot;&gt;&lt;i class=&quot;fas fa-clock fa-spin&quot;&gt;&lt;/i&gt;&lt;span&gt;那年今日&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;history-baidu&quot; style=&quot;height: 100px;overflow: hidden&quot;&gt;&lt;div class=&quot;history_swiper-container&quot; id=&quot;history-container&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;div class=&quot;swiper-wrapper&quot; id=&quot;history_container_wrapper&quot; style=&quot;height:20px&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="微博热搜"><a href="#微博热搜" class="headerlink" title="微博热搜"></a>微博热搜</h2><p>对于我这种不想下微博，又只想看热搜的人来说是再适合不过了，来源于<a href="https://blog.eurkon.com/post/38b005e1.html">这篇文章</a><br>该技术通过增加侧边栏模块，爬虫的方式实现，同理知乎的热搜如果能爬到，也可用同样的方式</p><details ><summary> 效果预览 </summary>              <div class='content'>              <p><img src="https://image.leidl.top/img/20210908221117.png" alt="image-20210908221117188"></p>              </div>            </details><details ><summary> 配置 </summary>              <div class='content'>              <ol><li><p>创建card_weibo.js，或者直接引用现成的js路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://weibo-top-api.vercel.app/api&#x27;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> data.json()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">&#x27;&lt;style&gt;.weibo-new&#123;background:#ff3852&#125;.weibo-hot&#123;background:#ff9406&#125;.weibo-jyzy&#123;background:#ffc000&#125;.weibo-recommend&#123;background:#00b7ee&#125;.weibo-adrecommend&#123;background:#febd22&#125;.weibo-friend&#123;background:#8fc21e&#125;.weibo-boom&#123;background:#bd0000&#125;.weibo-topic&#123;background:#ff6f49&#125;.weibo-topic-ad&#123;background:#4dadff&#125;.weibo-boil&#123;background:#f86400&#125;#weibo-container&#123;overflow-y:auto;-ms-overflow-style:none;scrollbar-width:none&#125;#weibo-container::-webkit-scrollbar&#123;display:none&#125;.weibo-list-item&#123;display:flex;flex-direction:row;justify-content:space-between;flex-wrap:nowrap&#125;.weibo-title&#123;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-right:auto&#125;.weibo-num&#123;float:right&#125;.weibo-hotness&#123;display:inline-block;padding:0 6px;transform:scale(.8) translateX(-3px);color:#fff;border-radius:8px&#125;&lt;/style&gt;&#x27;</span></span><br><span class="line">  html += <span class="string">&#x27;&lt;div class=&quot;weibo-list&quot;&gt;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> hotness = &#123;</span><br><span class="line">    <span class="string">&#x27;爆&#x27;</span>: <span class="string">&#x27;weibo-boom&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;热&#x27;</span>: <span class="string">&#x27;weibo-hot&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;沸&#x27;</span>: <span class="string">&#x27;weibo-boil&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;新&#x27;</span>: <span class="string">&#x27;weibo-new&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;荐&#x27;</span>: <span class="string">&#x27;weibo-recommend&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;影&#x27;</span>: <span class="string">&#x27;weibo-jyzy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;剧&#x27;</span>: <span class="string">&#x27;weibo-jyzy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;综&#x27;</span>: <span class="string">&#x27;weibo-jyzy&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> data) &#123;</span><br><span class="line">    html += <span class="string">&#x27;&lt;div class=&quot;weibo-list-item&quot;&gt;&lt;div class=&quot;weibo-hotness &#x27;</span> + hotness[(item.hot || <span class="string">&#x27;荐&#x27;</span>)] + <span class="string">&#x27;&quot;&gt;&#x27;</span> + (item.hot || <span class="string">&#x27;荐&#x27;</span>) + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">      + <span class="string">&#x27;&lt;span class=&quot;weibo-title&quot;&gt;&lt;a title=&quot;&#x27;</span> + item.title + <span class="string">&#x27;&quot;href=&quot;&#x27;</span> + item.url + <span class="string">&#x27;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer&quot;&gt;&#x27;</span> + item.title + <span class="string">&#x27;&lt;/a&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">      + <span class="string">&#x27;&lt;div class=&quot;weibo-num&quot;&gt;&lt;span&gt;&#x27;</span> + item.num + <span class="string">&#x27;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  html += <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;weibo-container&#x27;</span>).innerHTML = html</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在 config.butterfly.yml 增加以下内容</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">aside:</span><br><span class="line">  enable: true</span><br><span class="line">  hide: true</span><br><span class="line">  button: true</span><br><span class="line">  ...</span><br><span class="line"><span class="addition">+  card_weibo:</span></span><br><span class="line"><span class="addition">+    enable: true</span></span><br><span class="line"></span><br><span class="line"># CDN</span><br><span class="line"># Don&#x27;t modify the following settings unless you know how they work</span><br><span class="line"># 非必要請不要修改</span><br><span class="line">CDN:</span><br><span class="line">  # main</span><br><span class="line">  main_css: /css/index.css</span><br><span class="line">  jquery: https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js</span><br><span class="line">  main: /js/main.js</span><br><span class="line">  utils: /js/utils.js</span><br><span class="line"></span><br><span class="line"><span class="addition">+  #weibo</span></span><br><span class="line"><span class="addition">+  card_weibo: https://cdn.jsdelivr.net/gh/Eurkon/CDN/hexo/js/card_weibo.js</span></span><br></pre></td></tr></table></figure></li><li><p>在 [root]\themes\butterfly\layout\includes\widget 目录下创建 card_weibo.pug 文件，添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_weibo.enable</span><br><span class="line">  .card-widget.card-weibo</span><br><span class="line">    .card-content</span><br><span class="line">      .item-headline</span><br><span class="line">        i.fab.fa-weibo</span><br><span class="line">        span= _p(&#x27;微博热搜&#x27;)</span><br><span class="line">      #weibo-container(style=&quot;width: 100%; height: 150px;font-size: 95%;&quot;)</span><br><span class="line">  script(defer data-pjax src=url_for(theme.CDN.card_weibo))</span><br></pre></td></tr></table></figure></li><li><p>在 [Blogroot]\themes\butterfly\layout\includes\widget\index.pug 文件中增加以下内容。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  #aside-content.aside-content</span><br><span class="line">    //- post</span><br><span class="line">    if is_post()</span><br><span class="line">      if showToc &amp;&amp; theme.toc.style_simple</span><br><span class="line">        .sticky_layout</span><br><span class="line">          include ./card_post_toc.pug</span><br><span class="line">      else</span><br><span class="line">        !=partial(&#x27;includes/widget/card_author&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        .sticky_layout</span><br><span class="line">          if showToc</span><br><span class="line">            include ./card_post_toc.pug</span><br><span class="line"><span class="addition">+         !=partial(&#x27;includes/widget/card_weibo&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span></span><br><span class="line">          !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">          !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    else</span><br><span class="line">      //- page</span><br><span class="line">      !=partial(&#x27;includes/widget/card_author&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      .sticky_layout</span><br><span class="line"><span class="addition">+       !=partial(&#x27;includes/widget/card_weibo&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span></span><br><span class="line">        !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_newest_comment&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_categories&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_tags&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_archives&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_webinfo&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure></li><li><p>hexo三连</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Eurkon/weibo-top-api">附加git代码地址</a></p></li></ol>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法归类</title>
      <link href="/post/f79807ee.html"/>
      <url>/post/f79807ee.html</url>
      
        <content type="html"><![CDATA[<ol><li>二分查找（非递归）</li><li>分治算法</li><li>动态规划</li><li>KMP算法</li><li>贪心算法</li><li>回溯算法</li></ol><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src.git">leidl97/algorithm-src</a></p><h2 id="二分查找（非递归）"><a href="#二分查找（非递归）" class="headerlink" title="二分查找（非递归）"></a>二分查找（非递归）</h2><p>非递归的话肯定使用while了</p><p><strong>难点</strong></p><p>注意边界值条件，只有当左边的值大于右边才跳出循环</p><p>当目标值小于mid时，应该让right = mid + 1，需要加1，</p><p>同样的，相反情况也需要 -1 。</p><p><strong>方法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> act)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = a.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == act) &#123;</span><br><span class="line">            <span class="comment">//找到该值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;找到该值&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (act &lt; a[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到该值&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>分而治之，将一个大问题分解成小问题去解决，再将子问题的解合并就是原问题的解。</p><p>经典的应用有：归并排序，快速排序，傅里叶变换（快速傅里叶变换），汉诺塔等</p><p>以汉诺塔（hannoiTower）为例</p><p><strong>解题思路</strong></p><p>如果只有1个盘，直接从A移到C</p><p>如果两个盘</p><p>①那么将最上面部分看作一个整体，先移动到辅助柱子B（递归）</p><p>②在将最后一个盘移动到C</p><p>③最后将B上的盘移动到C，此时A作为辅助柱子（递归）</p><p><img src="https://pic2.zhimg.com/v2-9ed9eff7a4b0442808f4544e31934a59_b.png" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 汉诺塔移动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 几个盘子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 源柱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 辅助柱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 目标柱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第1个盘从&quot;</span>+a+<span class="string">&quot;移到&quot;</span>+c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        merge(n-<span class="number">1</span>,a,c,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+n+<span class="string">&quot;个盘从&quot;</span>+a+<span class="string">&quot;移到&quot;</span>+c);</span><br><span class="line">        merge(n-<span class="number">1</span>,b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h2><p>比如经典的01背包问题</p><p><img src="https://pic3.zhimg.com/v2-41f27692ac937e0c9884ef8d39d9cf46_b.png" alt="img"></p><p>（Dynamic Programing）可以看b站的一个视频，讲的很清楚</p><p>【动态规划】背包问题_哔哩哔哩_bilibili<a href="http://www.bilibili.com![图标](https://pic3.zhimg.com/v2-d68245a9d65efe6d38ffb7efdf8c18fe_180x120.jpg)">www.bilibili.com![图标](https://pic3.zhimg.com/v2-d68245a9d65efe6d38ffb7efdf8c18fe_180x120.jpg)</a></p><p><strong>介绍</strong></p><p>就是分步缓存，减少重复计算的过程，增加运行效率，<strong>找到最优解</strong></p><p>继续回到背包问题，又分为01背包和完全背包，01背包表示放入的东西不能够重复，完全可以放入多件</p><p>涉及到两个维度的dp问题，直接考虑构建二维数组解决（大小+1，第0行0列值都是不计入）</p><p><img src="https://pic4.zhimg.com/v2-b07f98894d2fc414fa5ba8f49ea6bdc7_b.png" alt="img"></p><p>根据重量及价格构建一个5 x 4的表格</p><p><img src="https://pic1.zhimg.com/v2-e84cd76c1a29917d44b8ef0bc3e52f78_b.png" alt="img"></p><p><strong>思路</strong></p><p>1、第一行列均置为0</p><p>当背包容量为0的时候不能让任何有价值的东西，当这个价值为0的时候，装多少重量价值都为0</p><p><strong>都是0的话，为什么需要创建有0的数组，有什么意义吗？</strong></p><p>为了后面的计算时候使用</p><p>2、for循环遍历，从第一行，第一列开始，逐渐填充该数组</p><p>二维数组的每个格子都有两种选择，一种是装入物品，另一种则不装入</p><p>①如果装不下，只能选择不填入物品，思路</p><p>1、第一行列均置为0，因为当背包容量为0的时候不能让任何有价值的东西，当这个价值为0的时候，装多少重量都为0</p><p>都是0的话，为什么需要创建有0的数组，有什么意义吗？</p><p>为了后面的计算时候使用</p><p>2、for循环遍历，从第一行，第一列开始，逐渐填充该数组</p><p>二维数组的每个格子都有两种选择，或者填入物品，或者不填入物品</p><p>首先进行判断如果装不下，此时只能选择不填入物品</p><p>①当我们选择填入该物品的使用，那么此时这个格子的价值为当前商品的价值+去除这个重量后的价值【1】</p><p>解释【1】：先将背包总容量-当前物品的重量获得一个值。然后取前一个物品此重量下的最大价值</p><p>②如果不选择该物品，此时物品的价值和前一个物品价值相同</p><p>最后取他们两个中较大的那个</p><p><strong>代码思路</strong></p><p>定义重量数组w[]，价格数组v[]，二维记录数组result[] [] 行表示重量，列表示价格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//价值</span><br><span class="line">int[] v = &#123;1500,3000,2000&#125;;</span><br><span class="line">//重量</span><br><span class="line">int[] w = &#123;1,4,3&#125;;</span><br><span class="line">//结果数组</span><br><span class="line">int[][] result = new int[v.length + 1][4 + 1];</span><br></pre></td></tr></table></figure><p>①result[0] [j] = 0， result[i] [0] = 0 表示第一行第一列为0</p><p>②不可以选择（重量超出）：result[i] [j] = result[i-1] [j]（上一行的值）</p><p>③可以选择：当前商品价值 + 背包容量除去当前物品重量的最大价值。</p><p>result[i][j] = Math.<em>max</em>(result[i-1][j], v[i-1] + result[i-1][j - w[i-1]]);</p><p><strong>最大价值如何计算？</strong></p><p>比如此例的最后一个格，值应为2000+1500=3500</p><p>max(result[3-1] [4] , v[2] + result[3-1] [4 - w[3-1]])</p><p>result[3-1] [4] = 同列上行的值也就是1500</p><p>result[3-1] [4 - w[3-1]] =  result[2] [4 - 3] = </p><p>上行重量为4-3也就是result[2] [1]处的最大价值1500 + 当前物品的价值v[2]2000 = 3500</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; result[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        <span class="comment">//判断重量</span></span><br><span class="line">        <span class="keyword">if</span> (w[i-<span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">            <span class="comment">//大于给定重量，那么只能不选，采用上方的</span></span><br><span class="line">            result[i][j] = result[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在不选和选取较大值</span></span><br><span class="line">            result[i][j] = Math.max(result[i-<span class="number">1</span>][j], v[i-<span class="number">1</span>] + result[i-<span class="number">1</span>][j - w[i-<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在只是可以获得最大值，但是不知道具体方案，所以需要进行<strong>回溯</strong></p><p>从二维数组的最后一个数字开始遍历，与上一行的值进行对比，如果相等说明该物品没有加入背包(行–)，</p><p>如果不相等说明该物品加入背包，此时行–，</p><p>判断上个物品有没有，重量得从总重量减去当前物品的重量，所以列 = 列 - 当前物品的重量</p><p>方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = result.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = result[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result[i][j] != result[i-<span class="number">1</span>][j]) &#123;</span><br><span class="line">        <span class="comment">//不等于上面的，那么该物品装入背包</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;号物品装入背包&quot;</span>);</span><br><span class="line">        j -= w[i-<span class="number">1</span>];</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://pic2.zhimg.com/v2-cc9dad3827e7fd8382ad5a1a86447cdd_b.png" alt="img"></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><strong>名字的由来</strong></p><p>由三个人研究出的字符串查找算法分别是Knuth-Morris-Pratt，简称为KMP算法</p><p><strong>干什么的</strong></p><p>匹配字符串用的，效率相较于传统的暴力破解效率很高</p><p>暴力破解：指一位一位的进行对比，不匹配向后移一位，直到匹配成功，或者匹配失败</p><p>总之<strong>KMP算法不死板,不像暴力破解总是不匹配向后移动一位</strong>，<strong>然后一位一位比</strong>。</p><p>而是利用自身的算法来实现移动多位，来减少匹配次数，提高运行效率</p><p><strong>重点</strong></p><p>找前缀和后缀的共同部分的最大长度</p><p><strong>什么是前缀，什么是后缀</strong></p><p>前缀就是含头不含尾，后缀就是含尾不含头</p><p>以APPLE为例</p><p>前缀分别为：A | AP | APP | APPL</p><p>后缀分别为：E | LE | PLE | PPLE</p><p>需要找出模式串的部分匹配值，存入next表中</p><p>什么是部分匹配值</p><p><img src="https://pic1.zhimg.com/v2-bd5e434cdd23bef6bcc75aac27095530_b.png" alt="img"></p><p>一个串的前缀后缀相等的最大长度就是部分匹配值</p><p>如图所示</p><p>A没有前后缀就是 0 </p><p>AB前缀为A，后缀为B，没有相同部分为0</p><p>ABC前缀为A,AB后缀为 C,BC，没有相同部分为0</p><p>同理0的就不举例了</p><p>ABCDA前缀 A, AB,ABC,ABCD,后缀A,DA,CDA,BCDA,有公共的A，且长度为1，所以值为1</p><p>移动位数 = 已匹配的字符数（当前目标串下标） - next表的匹配值（不匹配的表中下标对应的值） </p><p><strong>难点</strong></p><p><strong>1、如何创建部分匹配表，容易理解，怎么去实现写出来</strong></p><p>数组第一个为0，如果第二个数与第一个字符相等，则匹配值+1，并且next[第二个数的下标] = 匹配值。此时 AAA 得到的数组为【0，1，2】</p><p><strong>如果不相等该怎么办</strong></p><p>第一想法是让匹配值归0，重新遍历。</p><p>但KMP算法精髓在于 匹配值 = next[当前匹配值下标 - 1] 而不是直接为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j)) &#123;</span><br><span class="line"><span class="comment">//     j = result[j - 1];</span></span><br><span class="line">       j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例“AACDAAA” </p><p>如果是j=0的方式，得到的结果为[0, 1, 0, 0, 1, 2, 1]，这个值是错的</p><p>如果是j = result[j - 1]的方式，得到的结果为[0, 1, 0, 0, 1, 2, 2]</p><p><strong>2、如何将目标串与模式串匹配</strong></p><p><strong>过程思路</strong></p><p>假设目标串为 “BBC ABCDAB ABCDABCDABDE”，模式串为“ABCDABD”</p><p>该模式串的匹配表为next = [0, 0, 0, 0, 1, 2, 0]</p><p>如果模式串指针位为0，那么当目标串第一位始终不匹配的时候，目标串的指针始终向后移动1位</p><p>第一次开始匹配的位置如下：</p><p><img src="https://pic2.zhimg.com/v2-bd6e0c4b1990fe258f1dd48b167930e5_b.png" alt="img"></p><p>D与空格不符，那么模式串的指针由空格位 - next[模式串下标-1]</p><p>也就是next[6-1] = 移动2位，位置如下</p><p><img src="https://pic2.zhimg.com/v2-7a0f36c136755dfd847df4a678eb4f25_b.png" alt="img"></p><p>C与空格不匹配，向后移动next[2-1] = 0位，这里程序做了处理，如果移动为0位，那么直接向后挪一位进行比较，直到下一次匹配到的位置</p><p><img src="https://pic1.zhimg.com/v2-dedfec3284fd2d7ee4f0360948f1bc70_b.png" alt="img"></p><p>发现D!=C，移动next[6-1] = 2位，此时逐个比较，发现完全匹配，返回第一次位置的下标</p><p><img src="https://pic2.zhimg.com/v2-7b2a101e5ff0745fc9a9a787d36089c5_b.png" alt="img"></p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标串指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建模式串指针</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获得匹配表</span></span><br><span class="line">        <span class="keyword">int</span>[] next = next(str2);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line"><span class="comment">//                return i - str2.length();</span></span><br><span class="line">                <span class="comment">//换为下面的更有效率</span></span><br><span class="line">                <span class="keyword">return</span> i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//如果没有匹配成功，那么直接将i向后移动</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则表示匹配过程中失败，将i退回到相应的位置</span></span><br><span class="line">                <span class="comment">//利用先前的公式</span></span><br><span class="line">                i = i - next[j-<span class="number">1</span>];</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成next数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] next(String str) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j)) &#123;</span><br><span class="line">                j = result[j - <span class="number">1</span>];</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == str.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p><strong>什么是贪心算法</strong></p><p>对问题求解时，每一步都选择用最好或最优的方式，从而使结果达到最好的一种算法</p><p>但得到的结果不一定是最优解，是相对接近最优解的结果。<strong>求最合适的解，但不一定是最优解</strong></p><p><strong>举个场景说明</strong></p><p><img src="https://pic2.zhimg.com/v2-f4868ac40a9ab54845153990fcf0f16d_b.png" alt="img"></p><p>如图所示，有5个广播台，得出一种方案使得，选择<strong>最少</strong>的广播台来覆盖所有的地区</p><p><strong>难点</strong></p><p><strong>1、怎么遍历才能获得覆盖地区最多的广播台</strong></p><p>每次都找覆盖最大的一个广播台，找到之后从总集合重去除，在按这种方式继续，直到总广播台被找完，这也是贪心的思想，总是去找相对大或者相对好的。为什么是相对？比如此例中，有3个广播台都是覆盖3个城市，那么选到的不一定是最优的，但总比覆盖2个城市的优先级要高</p><p><strong>2、什么情况下需要覆盖最大广播台</strong></p><p>当这个广播台还有未覆盖地区的时候（size&gt;0）并且 （ 当定义的max没有初始值的时候  或者  当前遍历的广播台所覆盖的地区数量大于之前的广播台数量 ）</p><p>此时当前广播台为最优选择，这也是贪心算法的思想</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (allArea.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            String max = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry : radio.entrySet()) &#123;</span><br><span class="line">                String k = entry.getKey();</span><br><span class="line">                String v = entry.getValue();</span><br><span class="line">                String[] ss = v.split(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String str : ss) &#123;</span><br><span class="line">                    temp.add(str);</span><br><span class="line">                &#125;</span><br><span class="line">                temp.retainAll(allArea);</span><br><span class="line">                <span class="keyword">if</span> (temp.size() &gt; <span class="number">0</span> &amp;&amp; (max == <span class="keyword">null</span> || temp.size() &gt; radio.get(max).split(<span class="string">&quot;，&quot;</span>).length)) &#123;</span><br><span class="line">                    max = k;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将方案添加到结果集中</span></span><br><span class="line">            result.add(max);</span><br><span class="line">            <span class="keyword">for</span> (String str : radio.get(max).split(<span class="string">&quot;，&quot;</span>)) &#123;</span><br><span class="line">                allArea.remove(str);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            radio.remove(max);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>场景举例</p><p>马踏棋盘是一个经典的回溯问题</p><p>小游戏地址：<a href="https://u.ali213.net/games/horsesun/index.html?game_code=403">马踏飞棋</a></p><p><strong>问题描述</strong></p><p>如果给定一个m x n的棋盘，在给定一个马儿棋子的初始位置，按照马走日的规则，如何可以在每个方格只进入一次的情况下，走完整个棋盘。</p><p>当然，存在棋盘或者有些起始点不能使马儿走完整个棋盘的情况。</p><p><strong>问题解析</strong></p><p>马儿在任意一个点，总是会有可走的选择，如果可以走的话，选取一个点走，走不通的话就返回上一步，重新考虑下一个点进行尝试</p><p>如何获取当前点的下一个可选点？</p><p>根据马走日原则，如果满足原始点{1,2}的距离，并且返回当前可使用的点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i，j表示马的位置</span></span><br><span class="line"><span class="function">List&lt;Luozi&gt; <span class="title">next</span><span class="params">(<span class="keyword">int</span>[][] act, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = act.length;</span><br><span class="line">    List&lt;Luozi&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//四象限</span></span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span> &lt; size &amp;&amp; j+<span class="number">2</span> &lt; size &amp;&amp; act[i+<span class="number">1</span>][j+<span class="number">2</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i+<span class="number">1</span>,j+<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">2</span> &lt; size &amp;&amp; j+<span class="number">1</span> &lt; size &amp;&amp; act[i+<span class="number">2</span>][j+<span class="number">1</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i+<span class="number">2</span>,j+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三象限</span></span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span> &lt; size &amp;&amp; j-<span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; act[i+<span class="number">1</span>][j-<span class="number">2</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i+<span class="number">1</span>,j-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">2</span> &lt; size &amp;&amp; j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; act[i+<span class="number">2</span>][j-<span class="number">1</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i+<span class="number">2</span>,j-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一象限</span></span><br><span class="line">    <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j-<span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; act[i-<span class="number">1</span>][j-<span class="number">2</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i-<span class="number">1</span>,j-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-<span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; act[i-<span class="number">2</span>][j-<span class="number">1</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i-<span class="number">2</span>,j-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二象限</span></span><br><span class="line">    <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j+<span class="number">2</span> &lt; size &amp;&amp; act[i-<span class="number">1</span>][j+<span class="number">2</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i-<span class="number">1</span>,j+<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-<span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; j+<span class="number">1</span> &lt; size &amp;&amp; act[i-<span class="number">2</span>][j+<span class="number">1</span>] ==<span class="number">0</span>) &#123;</span><br><span class="line">        ls.add(<span class="keyword">new</span> Luozi(i-<span class="number">2</span>,j+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有规则之后，直接使用该规则进行编写代码</p><p>1、首先将马儿当前的坐标点置为step（当前步数）</p><p>2、根据刚才的next方法来获取可选的坐标点</p><p>3、遍历所有的坐标点，递归调用当前方法继续执行12操作</p><p>4、如果遍历完之后没有达到预定步数，那么将当前坐标点置为0（未使用）进行回溯</p><p>5、如果步数达到预定步数或者程序执行完（for循环是可以执行完的，是有出口的）程序结束。（因为不一定只有一种方案，全部遍历完需要花很长的时间）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[][] act,<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    act[i][j] = step;</span><br><span class="line">    <span class="keyword">if</span> (step == act.length * act.length) &#123;</span><br><span class="line">        <span class="comment">//如果达到预定步数，则打印</span></span><br><span class="line">        print(act);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到可以落子的坐标集合</span></span><br><span class="line">    List&lt;Luozi&gt; ls = next(act, i, j);</span><br><span class="line">    <span class="comment">//贪心思想，每次都尽量选取返回数量最小的，以减少回溯的次数</span></span><br><span class="line">    <span class="comment">//先注释</span></span><br><span class="line">    <span class="comment">//sort(ls,act);</span></span><br><span class="line">    <span class="keyword">for</span> (Luozi l : ls) &#123;</span><br><span class="line">        <span class="comment">//递归调用可用坐标</span></span><br><span class="line">        DFS(act,l.i,l.j,step+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有达到预定步数，将此点置为0，进行回溯</span></span><br><span class="line">    <span class="keyword">if</span> (step &lt; act.length * act.length) &#123;</span><br><span class="line">        act[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在的问题</strong></p><p>该算法不足的点在于由于每个人在编写规则顺序不同，返回的list不同，走的路径也会不同。导致执行的时间往往会很长。上述算法通过计数器可得到，在6 x 6 棋盘，起始点{1,3}的情况下，找到第一种方案，需要执行该方法11195506次！如果我使用8 x 8的棋盘，根本走不完。</p><p><strong>那么如果提高效率？</strong></p><p>贪心思想</p><p>如图，在6个点中，选哪一个点更加合适，这个就是提高算法效率的点。之前算法没有去定义，只按照了规则中的判断顺序得到</p><p><img src="https://pic2.zhimg.com/v2-bceaa466b43a02828988fa0843a8cc91_b.png" alt="img"></p><p>可以直接将这6个点的下一个可走的点得到，看这6个点哪一个的下一个可选点最少，哪一个点就是<strong>相对</strong>最优选。这样选择“出口”最少的点进行搜索，是一种局部调优的做法，回溯的次数也会减少。测试可知，用贪心思想执行方法的次数变为了36次！8 x 8的也仅用64次！</p><p><strong>回溯的次数与找到点有什么关系？</strong></p><p>选择少的点遍历，少的点会越来越少，成功的机率会越来越大？</p><p>其实我想它这种遍历方式，应该是从外圈到内圈的遍历方式，是一种循序的遍历过程，回溯过程缺失变少，试想如果任由自己跳，到最后阶段往往会不断进行回溯来调整之前的位置，也许这就是回溯少带来的优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行递增排序，贪心思想</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Luozi&gt; ls,<span class="keyword">int</span>[][] act)</span> </span>&#123;</span><br><span class="line">    ls.sort(<span class="keyword">new</span> Comparator&lt;Luozi&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Luozi o1, Luozi o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = next(act, o1.i, o1.j).size();</span><br><span class="line">            <span class="keyword">int</span> b = next(act, o2.i, o2.j).size();</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后只需要将之前得到的ls进行排序即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Luozi&gt; ls = next(act, i, j);</span><br><span class="line"><span class="comment">//贪心思想，每次都尽量选取返回数量最小的，以减少回溯的次数</span></span><br><span class="line"><span class="comment">//打开注释</span></span><br><span class="line">sort(ls,act);</span><br><span class="line"><span class="keyword">for</span> (Luozi l : ls) &#123;</span><br><span class="line">    <span class="comment">//递归调用可用坐标</span></span><br><span class="line">    DFS(act,l.i,l.j,step+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报考软件设计师的经历</title>
      <link href="/post/bf7f3b65.html"/>
      <url>/post/bf7f3b65.html</url>
      
        <content type="html"><![CDATA[<p>本人科班出身，工作后公司鼓励考，21年3月份报名，5月底考试，用了一个月时间复习，7月查成绩飘过，之前表示如果过了就做个总结帖，现在兑现诺言</p><p><img src="https://pic2.zhimg.com/v2-06f7f4e2921a500f2faac3a712780219_b.png" alt="img"></p><p>快拿我的速效救心丸来</p><h2 id="含金量？"><a href="#含金量？" class="headerlink" title="含金量？"></a>含金量？</h2><p>IT这行认证满天飞，但基本都没什么实际用处，大多都属于花钱买证的性质，像这种的含金量还用到处网上搜？高不高的自己心里没点数吗。软考这个证虽然也不怎么样，但别的不说一是国家认证，二是实打实考的。多的也不说了，既然决心要考一个了，那就认真备考吧，进入做功课环节，一贴一条龙服务，建议收藏</p><p>引用信息摘取官网，可以直接空降查看</p><h2 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h2><p>中国计算机技术职业资格网<a href="http://www.ruankao.org.cn![图标](https://pic1.zhimg.com/v2-9351dcc1b8fd87db73bb8dc3912d56d0_180x120.jpg)">www.ruankao.org.cn![图标](https://pic1.zhimg.com/v2-9351dcc1b8fd87db73bb8dc3912d56d0_180x120.jpg)</a></p><h2 id="报考要求"><a href="#报考要求" class="headerlink" title="报考要求"></a>报考要求</h2><blockquote><p>报考任何级别不需要学历、资历条件，只要达到相应的专业技术水平就可以报考相应的级别</p></blockquote><p>翻译一下就是没什么限制，想考就能考</p><h2 id="报考条件"><a href="#报考条件" class="headerlink" title="报考条件"></a>报考条件</h2><blockquote><p>考试要求 （1）掌握数据表示、算术和逻辑运算； （2）掌握相关的应用数学、离散数学的基础知识； （3）掌握计算机体系结构以及各主要部件的性能和基本工作原理；  （4）掌握操作系统、程序设计语言的基础知识，了解编译程序的基本知识； （5）熟练掌握常用数据结构和常用算法； （6）熟悉数据库、网络和多媒体的基础知识； （7）掌握C程序设计语言，以及C++、Java、Visual Basic、Visual C++中的一种程序设计语言； （8）熟悉软件工程、软件过程改进和软件开发项目管理的基础知识； （9）熟练掌握软件设计的方法和技术； （10）掌握常用信息技术标准、安全性，以及有关法律、法规的基本知识； （11）了解信息化、计算机应用的基础知识； （12）正确阅读和理解计算机领域的英文资料。</p></blockquote><p>大概是科班的必修课程，涵盖广，深度浅</p><p>具体包括机组，数据结构，程序语言，操作系统，计算机基础知识，计算机网络，面向对象技术</p><h2 id="科目情况"><a href="#科目情况" class="headerlink" title="科目情况"></a>科目情况</h2><blockquote><p>（1）计算机与软件工程知识，考试时间为150分钟，笔试，选择题； （2）软件设计，考试时间为150分钟，笔试，问答题。</p></blockquote><h3 id="证书样本"><a href="#证书样本" class="headerlink" title="证书样本"></a><strong>证书样本</strong></h3><p><img src="https://pic3.zhimg.com/v2-82a63e284eaf8ba1079a1721ffd863f2_b.png" alt="img"></p><p>来源官网</p><p><img src="https://pic2.zhimg.com/v2-2f09fd6256fec9c5a690f92f13444ec1_b.png" alt="img"></p><p>来源官网</p><h2 id="报考时间"><a href="#报考时间" class="headerlink" title="报考时间"></a>报考时间</h2><p>每年两次，一般在每年的5月、11月考试，提前两个月报名，具体以官网信息为准</p><h2 id="合格条件"><a href="#合格条件" class="headerlink" title="合格条件"></a>合格条件</h2><p>满分75，合格45</p><p>不像高考，好的上清华，差的专科，只要过了45都是那本证书，上面没分数，也没级别</p><h2 id="难度如何"><a href="#难度如何" class="headerlink" title="难度如何"></a>难度如何</h2><p>高达10%，也有说25%的，我个人感觉只要好好准备了，也不是很难</p><h2 id="如何备考"><a href="#如何备考" class="headerlink" title="如何备考"></a>如何备考</h2><p>我没有买教材，也没有报班，从头到尾只花了报名费</p><p><strong>看视频（热身）</strong></p><p>目的是对考点有个大致的认识，知道考题范围，侧重点在哪里，过一遍就行，我看的b站的这个，这个老师应该是希赛的，就是语速太慢了，2倍一点也不快</p><p>软考中级软件设计师_哔哩哔哩_bilibili<a href="http://www.bilibili.com![图标](https://pic1.zhimg.com/v2-9dd9c03a3c0d2f721784f2996bb525dc_180x120.jpg)">www.bilibili.com![图标](https://pic1.zhimg.com/v2-9dd9c03a3c0d2f721784f2996bb525dc_180x120.jpg)</a></p><p><strong>刷题（核心）</strong></p><p>能不能过，靠的就是刷题。一定要把近5年的真题全部刷了，可能会遇到原题（真题不会重复，这里指题库中的，所以题量很重要）</p><p>刷题方式主要有三种，我选择了PC+手机</p><ul><li>PC</li><li>手机</li><li>打印</li></ul><p>PC端刷题，遇到不会的直接百度（搜不到的带个希赛关键字），或者群里问，我找到一个的网站可以在线练题，UI除了丑一点，功能是够用了，我还在想别人的文章贴怎么没发，我是第一个找到的吗，不推荐去某赛的官网刷，各种收费</p><p>理木客在线考试系统- 登录limuke.top:86</p><p>手机端，推荐下载软考通，有广告但免费。感觉跟刷驾照的题差不多，有真题，有各种模拟题，肝帝直接全量刷，在做错题。不推荐希赛，不仅不全还想着法收费，不过比PC的希赛良心，PC的只要是真题就收费</p><p>有些人热衷于做试卷，不然没感觉。这需要pdf或者word，然后去打印，网上到处都是资源，有让你私的，有让关注公众号取得（我当时就是关注公众号取得）我就没那么多套路了，没有的直接去我网盘取</p><p><img src="https://pic2.zhimg.com/v2-cd3565fc5ac7eb75f03c650670d66019_b.png" alt="img"></p><p>网盘链接：<a href="https://pan.baidu.com/s/1jPECjF-7I6YqKf8WwIP7zw">https://pan.baidu.com/s/1jPECjF-7I6YqKf8WwIP7zw</a>  提取码：go6w</p><p><strong>教材（辅助）</strong></p><p>可以当个字典，它囊括了所有课程的东西，我想用来盖泡面一定香，确实厚实。能读下来的相信60以上轻轻松松。题都是基于这本书出的，售价100多，太黑了，我当时也没买</p><p><img src="https://pic2.zhimg.com/v2-3e90b6e408a5e30b6856ae6dc5c14f09_b.png" alt="img"></p><p>某宝和某东均售卖</p><p><strong>QQ群（辅助）</strong></p><p>我从b站学习时加的，大概1000人左右。作用就是可以在里面吹牛（doge）</p><p>扯远了，你有不会的发群里会有很多人解决的，这是最大的用处。在临考那几天也会有菩萨发模拟题，还有一些速记手册资料什么的，但别一直看，总有一些人给你贩卖焦虑，正所谓群内发言者人均70（这也不会？）尤其是考试当天，怕受影响的建议当天退群</p><p><strong>报班（不推荐）</strong></p><p>参照某赛差不多3k左右，我也不去评价课程好坏，土豪随意，报个班当然更好</p><p>报班适合那些自制力差的人，毕竟报名到考试差不多3个月，期间全靠自觉</p><h2 id="刷题攻略"><a href="#刷题攻略" class="headerlink" title="刷题攻略"></a>刷题攻略</h2><p>一句话总结：保证量（近五年真题必做），加上一些技巧</p><p><strong>上午攻略</strong></p><p>上午都是选择题，有单选和多选，每空都是1分，特殊难建议先跳过，最后一道专业英语看个人水平（5空），我就是天意选手，拿多少分我说了不算，所以在我眼里他的满分只有70分。</p><p>一些需要掌握技巧的反而好拿分，比如计算部分，都有一定的公式和模板，练几道就掌握了，到时候就是变个数据，这种题一定要尽量拿分，基本是白给</p><p>另一部分是概念题，这部分没什么好的方法只能背，比如哪些协议位于什么层，默认端口是什么，有哪些应用等，这分属于那种下多少功夫就会拿多少分</p><p><img src="https://pic1.zhimg.com/v2-4cb48da41ab8d3d22dcd8e7307a08740_b.png" alt="img"></p><p>还有极少数的新题型，这种就完全看个人的水平了，属于附加分</p><p>总之把握住前两部分基本就稳了，不要总去刷一些模拟题，真题足够了</p><p>多说一嘴，有些答案选项可能不理解，或者觉得这不是答案。不用去纠结，知道这空选它能拿分就可以了，它是让你在4个选项中选那个相对合适的，而不是绝对正确的。这就属于应试技巧了。这也是官方每次考完也不会公布参考答案一样，我认为主要是争议太大，那些所谓的答案都是教育机构自己定的，不过一般也没什么错，可以按正确答案去看。</p><p><strong>下午攻略</strong></p><p>下午标准6道问答题（有选做题，其实为5道），需要有Java或C的能力，每道题15分</p><p>第一题：数据流图</p><p>前3小问应该没什么问题，让你补全数据流图的信息，第四问总会刁难一下，已经连续三年考那个程序语言了，我是吐了。应该稳拿12分</p><p>第二题：E-R图</p><p>同样也是送分题，最后一问比较灵活，应该稳拿12分</p><p>第三题：UML图</p><p>以类图居多，我考的也是类图，也是需要去补全图中信息，因为UML变化多样，可能做起来也没前两道题舒服，但也要尽量拿到10分以上</p><p>第四题：代码填空题</p><p>拉分题，多练多拿。会的和不会的是极端。程序语言为C语言，不过填的空学Java的也会填，语言不是问题</p><p>这种题只能靠刷算法题来加强，常考的有分治，动态规划，回溯，贪心，我这里也总结了常用的一些算法，可以看看，或者自己找也行</p><p><a href="https://leidl.top/post/f79807ee">常用算法</a></p><p>没题感的，靠后面几个空蒙几分吧（时间复杂度，设计策略什么的）最少还不拿3、4分</p><p>第五题/第六题：面向对象设计</p><p>选一道Java或C，需要写补充代码片段，也是多练多得，比上面的算法题好拿分一点，有一定技巧可循，不要瞎选，不要漏选（不涂卡）。不像上一题，这道题讲究语法，学Java的就选Java</p><p>上述5道题，讲道理每题平均9分就过了，但要没这把握，前三道一定要多拿分，将后两道的拉上来，只想过的按我这个思路没什么问题，当然大牛我就不说了</p><p><strong>小总结</strong></p><p>上午题型多，需要一定的刷题量，量上去了，上午题一般不会有什么问题，下午比较考验技巧，题型固定，刷一定题量后，再刷不会有什么质的提升，主要是多回顾做过的题，多琢磨每种题型的技巧</p><h2 id="考试那点事"><a href="#考试那点事" class="headerlink" title="考试那点事"></a>考试那点事</h2><p><strong>必备装备</strong></p><p>准考证必备（多打印两张，当草稿用，因为考试发的草稿纸是在试题集后面的，不给撕下来用，我是真滴服）差不多考前一周可以打印，具体每个省份看官网信息</p><p>中性笔（黑），2B铅笔，橡皮，身份证，核酸证明（这个看要求，需要短信会通知）</p><p><strong>考试现场</strong></p><p>我那场俩老师监考，仅次于高考，真的严，屏蔽器什么的都有，一间教室30个座，跟高考差不多，不过有一半人都不来考，所以加油，来了已经胜利一半了</p><p><strong>注意事项</strong></p><p>上午一定要提前准备好2B（削好），上午就一张答题卡，都是涂的，不拿2B成2B。一般90分钟就做完了，剩下的时间检查，检查下有无图错行的情况，答案别请轻易改，相信第一直觉，只准提前30分钟交卷，考前10分钟不准交卷。<strong>我竟然发现喵的有原题！</strong>同志们一定要多刷题</p><p>中午挑个地方搓一顿，估计也没地方休息，回来也不开门，直接找个凉快的地儿，吃完看会儿笔记</p><p>下午时间往往不够，建议先不做第四题，别的都做完在回来做</p><p>我两门都提前30分钟就交了，坐不住了，考完腰酸背痛的，在奖励自己搓一顿</p><p>这时候看了下群消息，一堆人在那里刷，”距离下次软考还有162天，加油！”</p><p>这群沙雕，乐死我了，感情70分的都成40分了</p><h2 id="考试查询"><a href="#考试查询" class="headerlink" title="考试查询"></a>考试查询</h2><p>官网才可以跳转查，直接访问是非法的。希望大家都能过，加油！</p><p><a href="https://www.ruankao.org.cn/">中国计算机技术职业资格网 (ruankao.org.cn)</a></p><p><img src="https://pic2.zhimg.com/v2-72140769fd75c60aa21687ee188d20b5_b.png" alt="img"></p><h2 id="证书领取"><a href="#证书领取" class="headerlink" title="证书领取"></a>证书领取</h2><p>像我这批次的估计就到11月份了或者明年，差不多是下一次软考时间</p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/post/91ad9ce3.html"/>
      <url>/post/91ad9ce3.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>什么是原型模式</li><li>使用场景</li><li>常见应用场景</li><li>什么是浅拷贝？</li><li>什么是深拷贝？</li><li>两种拷贝方式怎么实现？</li></ol><h2 id="什么是原型模式"><a href="#什么是原型模式" class="headerlink" title="什么是原型模式"></a>什么是原型模式</h2><p>原型模式就是去克隆对象，又涉及到创建对象了，为创建者模式</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、类初始化需要消化非常多的资源,这个资源包括数据、硬件资源等，原型可以简化创建过程，提高创建效率</p><p>2、需要对对象中的部分属性进行修改，而其他属性不需要改变</p><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><p>spring中的bean对象创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Hi&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其方法实现（摘取部分）来源于抽象类AbstractBeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    var12 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Object prototypeInstance;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bean = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ��&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Scope scope = (Scope)<span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>克隆对象就分为浅拷贝和深拷贝两种</p><p><strong>什么是浅拷贝？</strong></p><p><img src="https://pic4.zhimg.com/v2-e294693befb0a767d39311c4589913d3_b.png" alt="img"></p><p>基本类型的值会复制一份开辟一个新空间，而引用类型则共用一个地址，这就表示如果修改数组中的一个值，另一个对象也会受到影响</p><p><strong>什么是深拷贝？</strong></p><p>基本类型与引用类型都会开辟一个空间，互相之间不受影响</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h3><p>实现cloneable接口，告诉jvm此类被标记，可以使用克隆方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">A clone = (A) a.clone();</span><br><span class="line">System.out.println(clone);</span><br></pre></td></tr></table></figure><p><strong>夺命三连问</strong></p><p>1、克隆是否调用构造器方法？</p><p>不会，clone方法直接复制内存中的二进制，效率高</p><p>2、克隆出的对象和之前的是否一致？</p><p>不一致</p><p>3、改变克隆对象的值，原对象是否会变？</p><p>基本类型不变，引用类型随之改变</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h3><p>实现Serializable,Cloneable两个接口</p><p>方式一：在本方法内重写clone方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">//全部克隆</span></span><br><span class="line">    Object deep = <span class="keyword">super</span>.clone();</span><br><span class="line">    Deep deep1 = (Deep) deep;</span><br><span class="line">    <span class="comment">//对象引用类型克隆</span></span><br><span class="line">    deep1.cloneArr = cloneArr.clone();</span><br><span class="line">    <span class="keyword">return</span> deep1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写起来方便，不好扩展</p><p>方式二：通过序列化的方式（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Deep <span class="title">getDeep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建流对象</span></span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    Deep deep = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读出</span></span><br><span class="line">        bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        deep = (Deep) ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            ois.close();</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方式1</span></span><br><span class="line">Deep deep1 = <span class="keyword">new</span> Deep();</span><br><span class="line">Deep deep2 = (Deep) deep1.clone();</span><br><span class="line">deep1.cloneArr[<span class="number">0</span>] = <span class="string">&quot;peed&quot;</span>;</span><br><span class="line">System.out.println(deep1.cloneArr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(deep2.cloneArr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试方式2</span></span><br><span class="line">Deep deep3 = <span class="keyword">new</span> Deep();</span><br><span class="line">Deep deep4 = deep3.getDeep();</span><br><span class="line">deep3.cloneArr[<span class="number">0</span>] = <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">System.out.println(deep3.cloneArr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(deep4.cloneArr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方式一</span><br><span class="line">peed</span><br><span class="line">deep</span><br><span class="line">方式二</span><br><span class="line">pig</span><br><span class="line">deep</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/post/f1601c3e.html"/>
      <url>/post/f1601c3e.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>什么是单例模式</li><li>使用场景</li><li>常见的应用场景</li><li>实现套路</li><li>八大实现方式</li></ol><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例模式指某个类中只存在一个对象实例，创建对象的，属于创建者模式</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于一些频繁创建销毁的对象来说，创建对象耗时或者消耗资源多，工具类对象</p><h2 id="常见的应用场景"><a href="#常见的应用场景" class="headerlink" title="常见的应用场景"></a>常见的应用场景</h2><p>①Runtime类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the runtime object associated with the current Java application.</span></span><br><span class="line"><span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span></span><br><span class="line"><span class="comment">     * methods and must be invoked with respect to the current runtime object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span></span><br><span class="line"><span class="comment">     *          Java application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②数据库连接池</p><p>数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗</p><p>③spring的对象管理默认为单例模式</p><h2 id="实现套路"><a href="#实现套路" class="headerlink" title="实现套路"></a>实现套路</h2><p>虽然实现方式众多，但核心绕不开两点</p><p>1、私有化构造方法，防止外部类去new</p><p>2、静态变量定义，保证唯一性</p><h2 id="八大实现方式"><a href="#八大实现方式" class="headerlink" title="八大实现方式"></a>八大实现方式</h2><p>饿汉两种，懒汉三种，双重检查，静态内部，枚举</p><p>饿汉可以理解为：刚加载类就迫不及待创建对象，急</p><p>懒汉可以理解为：只有需要的时候才创建对象，不急</p><h3 id="1、饿汉式（静态常量）"><a href="#1、饿汉式（静态常量）" class="headerlink" title="1、饿汉式（静态常量）"></a><strong>1、饿汉式（静态常量）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部不能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">EHan1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//创建一个对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> EHan1 instance = <span class="keyword">new</span> EHan1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对外提供接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EHan1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单，类装载时加载，避免线程同步问题</p><p>缺点：没有达到懒加载，如果没用到，会造成内存浪费</p><h3 id="2、饿汉式（静态代码块）"><a href="#2、饿汉式（静态代码块）" class="headerlink" title="2、饿汉式（静态代码块）"></a><strong>2、饿汉式（静态代码块）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码块创建</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> EHan2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部不能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">EHan2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EHan2 instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对外提供接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EHan2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点相同</p><h3 id="3、懒汉式（线程不安全）"><a href="#3、懒汉式（线程不安全）" class="headerlink" title="3、懒汉式（线程不安全）"></a><strong>3、懒汉式（线程不安全）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防外部new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LanHan1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//静态定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LanHan1 instance;</span><br><span class="line"><span class="comment">//返回对象时获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LanHan1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> LanHan1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法相同</p><p>优点：简单，起到了懒加载效果，使用对象时才创建，</p><p>缺点：线程不安全（只能在单线程下使用），实际开发时不建议</p><h3 id="4、懒汉式（线程安全，同步方法）"><a href="#4、懒汉式（线程安全，同步方法）" class="headerlink" title="4、懒汉式（线程安全，同步方法）"></a><strong>4、懒汉式（线程安全，同步方法）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防外部new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LanHan2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//静态定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LanHan2 instance;</span><br><span class="line"><span class="comment">//返回对象时获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LanHan2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> LanHan2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：每个线程想要获取类的时候，都需要进行getInstance()方法获取，等待时间过长，效率低下，实际开发不建议使用这种方式</p><h3 id="5、懒汉式（线程安全，同步代码块）"><a href="#5、懒汉式（线程安全，同步代码块）" class="headerlink" title="5、懒汉式（线程安全，同步代码块）"></a><strong>5、懒汉式（线程安全，同步代码块）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防外部new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LanHan3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//静态定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LanHan3 instance;</span><br><span class="line"><span class="comment">//返回对象时获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LanHan3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LanHan3.class) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LanHan3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：对于效率低的问题，放入了代码块中执行，实际上不能起到线程同步的问题，实际开发中不能使用</p><h3 id="6、双重检查（推荐）"><a href="#6、双重检查（推荐）" class="headerlink" title="6、双重检查（推荐）"></a><strong>6、双重检查（推荐）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有变化立马刷新，不会重排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheck instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个判断，一个同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果此时已经有实例，那么直接返回实例，保证效率</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DoubleCheck.class) &#123;</span><br><span class="line">            <span class="comment">//假设两个线程AB，A此时走到了这行，B在synchronized的上行，但已经判断为空了，A在走完创建实例方法之后</span></span><br><span class="line">            <span class="comment">//如果没有判断，那么B会再次创建一次实例，那么就会存在多线程多个实例的情况</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> DoubleCheck();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：懒加载，线程安全，保证效率。推荐使用</p><p><strong>两个判断的意义</strong>：第一个保证效率，如果有实例那么直接返回</p><p>volatile：保证可见性，防止小概率指令重排造成的失败</p><p>第二个为了保证线程安全，不然可能会出现多线程多实例的情况</p><h3 id="7、静态内部类（推荐）"><a href="#7、静态内部类（推荐）" class="headerlink" title="7、静态内部类（推荐）"></a><strong>7、静态内部类（推荐）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">NeiBu</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">getInstanceClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NeiBu INSTANCE = <span class="keyword">new</span> NeiBu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NeiBu <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInstanceClass.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM在装载类的时候，线程是安全的，使用了类装载机制</p><p>在加载NeiBu类时，内部类getInstanceClass不会被加载，只有在调用getInstance的时候才会进行加载</p><p>优点：懒加载，线程安全。推荐使用</p><h3 id="8、枚举类（推荐）"><a href="#8、枚举类（推荐）" class="headerlink" title="8、枚举类（推荐）"></a><strong>8、枚举类（推荐）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">instance</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance instance1 = singleton.instance.INSTANCE;</span><br><span class="line">instance instance2 = singleton.instance.INSTANCE;</span><br><span class="line">System.out.println(instance1 == instance2);</span><br></pre></td></tr></table></figure><p>借助jdk5提出的枚举类来实现到单例模式，不仅能避免同步问题，还能防止反序列化创建对象。推荐使用</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/post/fe816c3c.html"/>
      <url>/post/fe816c3c.html</url>
      
        <content type="html"><![CDATA[<ol><li>什么是建造者模式</li><li>解决了什么问题</li><li>使用场景</li><li>常见的实现场景</li><li>场景案例</li><li>使用流行的建造者模式解决问题</li><li>不适用建造者模式解决问题</li><li>使用传统的建造者模式解决问题</li></ol><h2 id="什么是建造者模式"><a href="#什么是建造者模式" class="headerlink" title="什么是建造者模式"></a>什么是建造者模式</h2><p>隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p><h2 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h2><p>该模式解决的是<strong>如何将一个复杂对象（属性多）赋值的问题</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>大家想想，平时如何一个对象赋值？</p><p><strong>1、构造器</strong></p><p>平时常用的方式，虽然构造器用起来很方便，但随着属性增多，那么需要写的构造器也会增多多，而且容易传混</p><p><strong>2、set方式</strong></p><p>缺点：对象状态易发生变化，也是一长串，实现起来不美观</p><h2 id="常用的实现场景"><a href="#常用的实现场景" class="headerlink" title="常用的实现场景"></a>常用的实现场景</h2><p>①lombok中的@Builder注解</p><p>比如刚才House对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String base;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译后（与我们手动实现的相似）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String base;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String cell;</span><br><span class="line">    House(String base, String wall, String cell) &#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base; </span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">        <span class="keyword">this</span>.cell = cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> House.<span class="function">HouseBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> House.HouseBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String base;</span><br><span class="line">        <span class="keyword">private</span> String wall;</span><br><span class="line">        <span class="keyword">private</span> String cell;</span><br><span class="line">        HouseBuilder() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> House.<span class="function">HouseBuilder <span class="title">base</span><span class="params">(String base)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.base = base;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> House.<span class="function">HouseBuilder <span class="title">wall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.wall = wall;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> House.<span class="function">HouseBuilder <span class="title">cell</span><span class="params">(String cell)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cell = cell;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> House <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> House(<span class="keyword">this</span>.base, <span class="keyword">this</span>.wall, <span class="keyword">this</span>.cell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//toString</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②StringBuilder类，相信大部分人都使用过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(<span class="number">1</span>)</span><br><span class="line">    .append(<span class="number">2</span>)</span><br><span class="line">    .append(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>源码中也是采用return this的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/v2-a082ccf6e9d1d5b74902a62bb9a8184d_b.png" alt="img"></p><p>append()的方法由接口Appendable定义（该接口类似抽象建造者）</p><p>由抽象类AbstractStringBuilder实现该接口 （该抽象类 类似具体建造者，但不能实例化）</p><p>最后给StringBuilder去调用append方法 （类似指挥者/调用方）</p><p>这样的话与上方的设计模式不同了，这个就是境界，只能说写JDK源码的大佬在第五层</p><h2 id="建造者模式，实现的方式有两种"><a href="#建造者模式，实现的方式有两种" class="headerlink" title="建造者模式，实现的方式有两种"></a>建造者模式，实现的方式有两种</h2><p><strong>①流行的实现方式—链式编程</strong></p><p>通过在对象中添加静态类的方式去创建对象</p><p>假设我需要建造一个房子，给房子的一些属性赋值</p><p>房子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="comment">//地基</span></span><br><span class="line">    <span class="keyword">private</span> String base;</span><br><span class="line">    <span class="comment">//墙</span></span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="comment">//吊顶</span></span><br><span class="line">    <span class="keyword">private</span> String cell;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">House</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = builder.base;</span><br><span class="line">        <span class="keyword">this</span>.wall = builder.wall;</span><br><span class="line">        <span class="keyword">this</span>.cell = builder.cell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="comment">//地基</span></span><br><span class="line">        <span class="keyword">private</span> String base;</span><br><span class="line">        <span class="comment">//墙</span></span><br><span class="line">        <span class="keyword">private</span> String wall;</span><br><span class="line">        <span class="comment">//吊顶</span></span><br><span class="line">        <span class="keyword">private</span> String cell;</span><br><span class="line">        <span class="comment">//set</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">base</span><span class="params">(String base)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.base = base;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">wall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.wall = wall;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">cell</span><span class="params">(String cell)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cell = cell;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> House <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> House(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString方法忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">House house = <span class="keyword">new</span> House.Builder()</span><br><span class="line">    .base(<span class="string">&quot;流行房子的地基&quot;</span>)</span><br><span class="line">    .wall(<span class="string">&quot;流行方式的墙&quot;</span>)</span><br><span class="line">    .cell(<span class="string">&quot;流行方式的顶子&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>这种方式就一个类，调用起来也美观，线程安全，强烈推荐</p><h3 id="②传统的建造者模式"><a href="#②传统的建造者模式" class="headerlink" title="②传统的建造者模式"></a><strong>②传统的建造者模式</strong></h3><p>也是经典的build模式，网上一搜一大把，看着高大上，但不实用，感兴趣可以看看</p><p>如果不适用建造者模式，我们怎么进行对象赋值？</p><p>传统的建造者模式又怎么赋值？下面是代码对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通方式盖房子</span></span><br><span class="line">House house1 = <span class="keyword">new</span> House();</span><br><span class="line">house1.setBase(<span class="string">&quot;普通房子的地基&quot;</span>);</span><br><span class="line">house1.setWall(<span class="string">&quot;普通房子的墙&quot;</span>);</span><br><span class="line">house1.setCell(<span class="string">&quot;普通房子的吊顶&quot;</span>);</span><br><span class="line">System.out.println(house1);</span><br><span class="line"><span class="comment">//建造者模式盖房子(Director相当于client)</span></span><br><span class="line">Director director = <span class="keyword">new</span> Director();</span><br><span class="line">House house = director.build(<span class="keyword">new</span> FiveBuilder());</span><br><span class="line">System.out.println(house);</span><br></pre></td></tr></table></figure><p>优势在于不论多少个属性赋值，都是一句话去创建，值在具体建造者中已设置，后面说</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>产品，产品对象，抽象建造者，具体建造者</p><p>相当于一个对象需要4个类，而仅仅是为了解耦，没感觉到好处</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a><strong>UML类图</strong></h3><p><img src="https://pic2.zhimg.com/v2-aafe3baa153523c0d128376485a63be1_b.png" alt="img"></p><p>可以看到调用方（Director）确实与产品（House）进行了解耦，应该也是唯一的好处了</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>房子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="comment">//地基</span></span><br><span class="line">    <span class="keyword">private</span> String base;</span><br><span class="line">    <span class="comment">//墙</span></span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="comment">//吊顶</span></span><br><span class="line">    <span class="keyword">private</span> String cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set get toString方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//地基赋值</span></span><br><span class="line">    <span class="function">HouseBuilder <span class="title">buildBase</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//墙赋值</span></span><br><span class="line">    <span class="function">HouseBuilder <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//吊顶赋值</span></span><br><span class="line">    <span class="function">HouseBuilder <span class="title">buildCell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得房子</span></span><br><span class="line">    <span class="function">House <span class="title">getHouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiveBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个建造者给房子赋的值</span></span><br><span class="line">    <span class="keyword">private</span> String base = <span class="string">&quot;五角大楼的地基&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String wall = <span class="string">&quot;五角大楼的墙&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String cell = <span class="string">&quot;五角大楼的吊顶&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> House house;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FiveBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house = <span class="keyword">new</span> House();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HouseBuilder <span class="title">buildBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setBase(base);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HouseBuilder <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setWall(wall);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HouseBuilder <span class="title">buildCell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setCell(cell);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指挥者/客户端（调用方）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据给定的建造者建造不同的房子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">build</span><span class="params">(HouseBuilder builder)</span> </span>&#123;</span><br><span class="line">        builder.buildBase()</span><br><span class="line">                .buildWall()</span><br><span class="line">                .buildCell();</span><br><span class="line">        <span class="keyword">return</span> builder.getHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的解耦思想可以借鉴，也属于面向接口编程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模式学的终归是一种思想，不必生搬硬套，也不用死记UML类图，重要的是体会每个设计模式的思想，并通过大量的业务来累积经验，来不断证明设计模式的好处</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/post/e19da94a.html"/>
      <url>/post/e19da94a.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>为什么要用享元模式</li><li>内部状态与外部状态</li><li>应用场景</li><li>场景举例</li><li>总结</li></ol><h2 id="为什么要用享元模式"><a href="#为什么要用享元模式" class="headerlink" title="为什么要用享元模式"></a>为什么要用享元模式</h2><p>有大量对象可复用，在服务端减少接口的调用，在客户端减少内存的占用</p><h2 id="内部状态与外部状态"><a href="#内部状态与外部状态" class="headerlink" title="内部状态与外部状态"></a>内部状态与外部状态</h2><p>了解享元模式就避不开内部状态与外部状态</p><p>内部状态：不随环境的变化而变化，在各个对象间共享</p><p>外部状态：随环境的改变而改变，由客户端传入</p><p>举例说明，在五子棋中，棋子的颜色就是内部状态，只有黑白两色，落子位置（坐标）是外部状态，每次位置都不一样</p><p>如果每一个棋子都是一个对象的话，一个棋盘可以放两三百个对象，极大的浪费内存空间，但如果使用享元模式，则可以很好的解决对象的开销问题</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>数据库连接池，String常量池，缓冲池</p><p>比如在Integer的源码中有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[]; <span class="comment">//定义常量数组</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//....省略，cache的范围在-128~127之间</span></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>按照棋子举例，类图比较简单就不画了</p><p>抽象接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Chess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黑白棋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackChess</span> <span class="keyword">implements</span> <span class="title">Chess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String COLOR = <span class="string">&quot;黑&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(COLOR + <span class="string">&quot;棋子落在(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)处&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteChess</span> <span class="keyword">implements</span> <span class="title">Chess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String COLOR = <span class="string">&quot;白&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(COLOR + <span class="string">&quot;棋落在(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)处&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Chess&gt; chessMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chess <span class="title">getChess</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        Chess chess = chessMap.get(color);</span><br><span class="line">        <span class="keyword">if</span> (chess == <span class="keyword">null</span>) &#123;</span><br><span class="line">            chess = <span class="string">&quot;黑&quot;</span>.equals(color) ? <span class="keyword">new</span> BlackChess() : <span class="keyword">new</span> WhiteChess();</span><br><span class="line">            chessMap.put(color,chess);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Chess white1 = ChessFactory.getChess(<span class="string">&quot;白&quot;</span>);</span><br><span class="line">Chess white2 = ChessFactory.getChess(<span class="string">&quot;白&quot;</span>);</span><br><span class="line">Chess black1 = ChessFactory.getChess(<span class="string">&quot;黑&quot;</span>);</span><br><span class="line">Chess black2 = ChessFactory.getChess(<span class="string">&quot;黑&quot;</span>);</span><br><span class="line">white1.draw(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">white2.draw(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">black1.draw(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">black2.draw(<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(white1.hashCode());</span><br><span class="line">System.out.println(white2.hashCode());</span><br><span class="line">System.out.println(black1.hashCode());</span><br><span class="line">System.out.println(black2.hashCode());</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">白棋落在(1,3)处</span><br><span class="line">白棋落在(2,4)处</span><br><span class="line">黑棋子落在(3,3)处</span><br><span class="line">黑棋子落在(2,6)处</span><br><span class="line">21685669</span><br><span class="line">21685669</span><br><span class="line">2133927002</span><br><span class="line">2133927002</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要区分状态，内部状态不可以从客户端设置，而外部状态必须从客户端设置，该模式可以提高内存使用率</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/post/54788f73.html"/>
      <url>/post/54788f73.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>引子</li><li>使用场景</li><li>常见应用场景</li><li>场景案例</li><li>常规思路</li><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ol><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>相信大家也经常在spring中见到xxxFactoty的字样，工厂模式也算是一个比较常用的设计模式，很有必要掌握</p><p>工厂模式分为三种，简单工厂，工厂方法，抽象工厂。其中简单工厂不属于23种设计模式</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>不想直接new对象，如果类改变，需要改代码，如果依赖该类的很多，那将是很痛苦的事情</p><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><p>spring中的工厂模式的继承图，之后文章中分析</p><p><img src="https://pic3.zhimg.com/v2-5f391bd24b9917769ec789d6150e5faa_b.png" alt="img"></p><h2 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h2><p>假如要生产电脑，比如华为，苹果电脑，如何实现业务？</p><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><p>定义属性，创建方法，调用展示。</p><p>伪代码，一个类就可以实现，给我A创建A电脑，给B创建B电脑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;A&quot;</span>.equlas(type)) &#123;</span><br><span class="line">    <span class="comment">//生产A电脑</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;B&quot;</span>.equlas(type)) &#123;</span><br><span class="line">    <span class="comment">//生产B电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设在添加一个C电脑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;A&quot;</span>.equlas(type)) &#123;</span><br><span class="line">    <span class="comment">//生产A电脑</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;B&quot;</span>.equlas(type)) &#123;</span><br><span class="line">    <span class="comment">//生产B电脑</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;C&quot;</span>.equlas(type)) &#123;</span><br><span class="line">    <span class="comment">//生产B电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，所有逻辑都写到一个类中，显然是不合适的，逐渐会形成屎山</p><h2 id="简单工厂模式思路"><a href="#简单工厂模式思路" class="headerlink" title="简单工厂模式思路"></a>简单工厂模式思路</h2><p>将实现逻辑抽离出去，该类只做调用</p><h2 id="先上UML类图，有个整体认知"><a href="#先上UML类图，有个整体认知" class="headerlink" title="先上UML类图，有个整体认知"></a>先上UML类图，有个整体认知</h2><p><img src="https://pic2.zhimg.com/v2-a30ee293ef28df722ee052f20896c309_b.png" alt="img"></p><p>抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IComputer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产电脑</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品A实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiIComputer</span> <span class="keyword">implements</span> <span class="title">IComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产华为电脑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品B实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleIComputer</span> <span class="keyword">implements</span> <span class="title">IComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产苹果电脑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IComputer <span class="title">getService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    IComputer service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(type)) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> HuaWeiIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(type)) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> AppleIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产电脑</span></span><br><span class="line">    service.method();</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然实现了一定的解耦，不将代码都放一块了，但如果添加产品C，工厂中的方法得改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    IComputer service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(type)) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> HuaWeiIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(type)) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> AppleIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;C&quot;</span>.equals(type)) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> XiaoMiIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产电脑</span></span><br><span class="line">    service.method();</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，违反了开闭原则，不适用于变化，如果产品改变（比如类名改变）,也得改工厂的具体方法，于是引出了工厂方法模式</p><p>简单工厂也有存在的意义：产品稳定的情况</p><p>比如calendar的源码中也用到了简单工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">    String caltype = aLocale.getUnicodeLocaleType(<span class="string">&quot;ca&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;buddhist&quot;</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;japanese&quot;</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;gregory&quot;</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><p>与简单工厂一致，用来解决简单工厂的遗留问题，其实也就是<strong>在业务类的基础上封装了一层工厂</strong>，好处在于工厂的名字是不易改变的</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://pic1.zhimg.com/v2-70495f804a9518d3553ed33134dea0e4_b.png" alt="img"></p><p>工厂抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IComputer <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiComputerFactory</span> <span class="keyword">implements</span> <span class="title">IComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IComputer <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleComputerFactory</span> <span class="keyword">implements</span> <span class="title">IComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IComputer <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppleIComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IComputer <span class="title">getService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    IComputer service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(type)) &#123;</span><br><span class="line">        HuaWeiComputerFactory aFactory = <span class="keyword">new</span> HuaWeiComputerFactory();</span><br><span class="line">        service = aFactory.getService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(type)) &#123;</span><br><span class="line">        AppleComputerFactory bFactory = <span class="keyword">new</span> AppleComputerFactory();</span><br><span class="line">        service = bFactory.getService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于工厂名不易改变，所以调用方很稳定，但新增产品，就需要新增工厂，调用方代码还是违反了开闭原则，本质上的问题并没有得到解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IComputer <span class="title">getService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    IComputer service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(type)) &#123;</span><br><span class="line">        HuaWeiComputerFactory aFactory = <span class="keyword">new</span> HuaWeiComputerFactory();</span><br><span class="line">        service = aFactory.getService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(type)) &#123;</span><br><span class="line">        AppleComputerFactory bFactory = <span class="keyword">new</span> AppleComputerFactory();</span><br><span class="line">        service = bFactory.getService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;C&quot;</span>.equals(type)) &#123;</span><br><span class="line">        XiaoMiComputerFactory cFactory = <span class="keyword">new</span> XiaoMiComputerFactory();</span><br><span class="line">        service = cFactory.getService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产电脑</span></span><br><span class="line">    service.method();</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：工厂名不易改变，稳定</p><p>缺点：不去纠结调用方的问题假如我不生产电脑了，我新增手机，对于产品簇的问题，代码会出现爆炸增长，类爆炸，所以引出抽象工厂</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>用来解决产品簇的问题，而不是解决调用方的开闭原则问题</p><h2 id="什么是产品簇"><a href="#什么是产品簇" class="headerlink" title="什么是产品簇"></a>什么是产品簇</h2><p>通俗点讲，比如苹果厂只生产苹果产品，而苹果产品包括了电脑，手机，手表等，这些一系列的产品就是产品簇</p><p><img src="https://pic4.zhimg.com/v2-7cde9cbbb0f877e8c5b555e9e64981b7_b.png" alt="img"></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><p>华为，苹果不可能只生成一种产品，上述例子中，只生产了电脑这个产品，现在除了生产电脑，还要生产手机，那么使用原来的工厂模式的弊端就显现出来了，还得弄一个手机抽象类，具体的再去实现，那么之后再去生产别的产品呢，抽象工厂类会越来越多，实现的类也会越来越多，可能引发类爆炸的情况</p><p>比如加一个手机产品，uml类图变为这样，相当于增加一个产品，增加了6个类</p><p><img src="https://pic3.zhimg.com/v2-28a8952d6b7a1449434c7224c70d4016_b.png" alt="img"></p><p>使用抽象工厂后，现在只需要增加三个类，如果产品簇越多，效果越明显</p><p><img src="https://pic2.zhimg.com/v2-268625c7426434b0cf5154728cc1e091_b.png" alt="img"></p><p>抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产电脑</span></span><br><span class="line">    <span class="function">IComputer <span class="title">getComputer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    <span class="function">IPhone <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>华为工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IComputer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产华为电脑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiIComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPhone <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产华为手机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IComputer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产苹果电脑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppleIComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPhone <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产苹果手机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得苹果工厂</span></span><br><span class="line">Factory apple = <span class="keyword">new</span> AppleFactory();</span><br><span class="line"><span class="comment">//可生产所有的苹果产品</span></span><br><span class="line">apple.getComputer();</span><br><span class="line">apple.getPhone();</span><br></pre></td></tr></table></figure><p>优点：将工厂类的方法减少，适用于增加工厂的情况（比如增加一个小米工厂）</p><p>缺点：当产品等级发生变化时（比如在增加一个手表产品），都需要修改以前工厂产品的代码（每个工厂都需要多加一个），违反开闭原则</p><p>所以产品等级总是变化的时候，那么抽象工厂就不合适</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需求不易改变选择简单工厂</p><p>产品等级少选工厂方法</p><p>产品等级稳定选抽象工厂</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/post/7b510e10.html"/>
      <url>/post/7b510e10.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>日常生活中常见的代理比如说老板秘书，明星经纪人，本来是老板或明星的活，代理就都给干了，除此之外，还可能多做一些额外的，比如帮明星筹建演唱会，打官司，做公关之类的</p><ol><li>为什么需要代理模式</li><li>代理模式种类</li><li>应用场景</li><li>静态代理</li><li>动态代理</li><li>cglib代理</li><li>总结</li></ol><h2 id="为什么需要代理模式"><a href="#为什么需要代理模式" class="headerlink" title="为什么需要代理模式"></a>为什么需要代理模式</h2><p>1、客户端可能无法直接操作对象（在另一台机器），那么可以在客户端建立一个代理对象，然后客户端直接调用目标对象，代理对象在与目标对象建立联系</p><p>2、需要加强目标对象的功能。有人表示为什么不在当初的类中加好，要使用代理来补充。单一职责要求一个类的功能尽可能单一，而且增强的功能大多都是与之前业务不同，比如增加日志输出，权限判断等，本来就不应该由之前的类去承担</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>静态代理，动态代理（jdk代理/接口代理），cglib代理</p><p>在《精通Spring4.x 企业应用开发实战》给出建议</p><p>单例使用cglib，多例使用jdk</p><p>原因：jdk创建对象性能高于cglib，而生成对象的运行性能却比cglib低</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>最常见的就是spring的AOP了，让关注点代码与业务代码分离</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在编译期确定，以通用的CRUD举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;<span class="comment">//表示核心业务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要在业务代码前后加入事务，通常的做法是实现该接口，前后加上事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">        <span class="comment">//核心业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：现在只是一个方法使用，方法多起来之后重复代码会很多</p><p>这时候通常的解决方案是抽取公共部分，封装方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        begin();</span><br><span class="line">        <span class="comment">//核心业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复代码解决了，但在每个方法中还是继续调用，不够优雅，于是就用到了代理</p><p>写一个代理类实现目标类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始事务&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以专注于业务逻辑了，但一个类只能代理一个接口，如果有1w个类需要代理，那还不得哭了，于是就出现了动态代理</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>由JDK提供，只需要调用Proxy的newProxyInstance()生成某个对象的代理对象就可以了，在运行期决定。</p><p><img src="https://pic3.zhimg.com/v2-6b1a2ee15bcf5ecfdcd4ac5e1323ccc6_b.png" alt="img"></p><p>解释下传入三个参数的含义</p><p>1、目标对象的类装载器</p><p>2、目标对象实现的接口</p><p>3、用这个对象干什么事，相当于之前的增强方法save（实现InvocationHandler接口，采取匿名内部类的方式重写该方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserJDKProxy</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                userDao.getClass().getClassLoader(),</span><br><span class="line">                userDao.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;使用jdk代理&quot;</span>);</span><br><span class="line">                        Object invoke = method.invoke(userDao, args);</span><br><span class="line">                        <span class="keyword">return</span> invoke;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IUserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">UserJDKProxy userJDKProxy = <span class="keyword">new</span> UserJDKProxy(userDao);</span><br><span class="line">IUserDao proxyInstance = (IUserDao)userJDKProxy.getProxyInstance();</span><br><span class="line">proxyInstance.save();</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用jdk代理</span><br><span class="line">保存成功</span><br></pre></td></tr></table></figure><p>如果目标类没有接口呢？就不能使用jdk代理了，这时候出现了cglib代理</p><h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p>需要引入cglib的jar包，但我引入了spring-core包，包含了cglib</p><p>简单的介绍下cglib</p><p>CGLib（Code Generation Library）是一个强大、高性能的Code生成类库，它可以在程序运行期间动态扩展类或接口，它的底层使用字节码处理框架ASM，来转换字节码并生成新的类。</p><p>需要实现MethodInterceptor接口，重写intercept方法，需要注意目标类不能是final，都不能被继承了，还怎么扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCglibProxy</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib代理&quot;</span>);</span><br><span class="line">        Object invoke = method.invoke(userDao, objects);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个工具类</span></span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setSuperclass(userDao.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserCglibProxy userCglibProxy = <span class="keyword">new</span> UserCglibProxy(userDao);</span><br><span class="line">IUserDao proxyInstance1 = (IUserDao)userCglibProxy.getProxyInstance();</span><br><span class="line">proxyInstance1.save();</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cglib代理</span><br><span class="line">保存成功</span><br></pre></td></tr></table></figure><p>查看jdk与cglib的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk</span></span><br><span class="line">System.out.println(jdk.getClass());</span><br><span class="line"><span class="comment">//cglib</span></span><br><span class="line">System.out.println(cglib.getClass());</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://pic2.zhimg.com/v2-5681f1ff4163000184b528d034aecc8d_b.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、代理模式通过代理对象来操作目标对象的方法，并在原对象的基础上增加额外的操作来满足业务要求</p><p>2、当我们不想改变原有代码，但希望增强方法，添加一些功能，可以考虑使用代理模式</p><p>比如日志记录，性能统计，事务处理，权限校验等</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/post/f7de8aa8.html"/>
      <url>/post/f7de8aa8.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>通用类图</li><li>场景举例</li><li>优点</li><li>缺点</li><li>注意</li><li>总结</li></ol><h2 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h2><p><img src="https://pic2.zhimg.com/v2-b832b6614c6ed1ceb94dd44257a87871_b.png" alt="img"></p><p>把功能统一到一块，形成一个总控，就类似于家里电闸的总开关，可以控制所有的电器</p><p>就拿我们公司举例，如果我平时遇到某个系统的问题，比如财务的问题找财务系统负责人，人力的找人力负责人，我还得知道他们是谁，我也没必要记住他们，那么一个角色出现了，充当了中间人的作用，那就是客服，我知道如果出问题了，就去找她，她给我找具体的人，这就是外观模式的一种体现</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>这样看下来一共有两个角色</p><p>外观，相当于客服</p><p>子系统，相当于各个部门的负责人</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>拿总控进行举例，如果我按总开关打算控制家中所有的灯，那么代码如下</p><p>先看调用端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外观模式,一步齐活</span></span><br><span class="line"><span class="keyword">new</span> Facade().open();</span><br><span class="line"><span class="keyword">new</span> Facade().close();</span><br><span class="line"><span class="comment">//传统方式，挨个调用</span></span><br><span class="line"><span class="keyword">new</span> BedRoom().open();</span><br><span class="line"><span class="keyword">new</span> Kitchen().open();</span><br><span class="line"><span class="keyword">new</span> LivingRoom().open();</span><br><span class="line"><span class="keyword">new</span> BedRoom().close();</span><br><span class="line"><span class="keyword">new</span> Kitchen().close();</span><br><span class="line"><span class="keyword">new</span> LivingRoom().close();</span><br></pre></td></tr></table></figure><p>外观类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BedRoom().open();</span><br><span class="line">        <span class="keyword">new</span> Kitchen().open();</span><br><span class="line">        <span class="keyword">new</span> LivingRoom().open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BedRoom().close();</span><br><span class="line">        <span class="keyword">new</span> Kitchen().close();</span><br><span class="line">        <span class="keyword">new</span> LivingRoom().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3个子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BedRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开卧室的灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭卧室的灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kitchen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开厨房的灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭厨房的灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LivingRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开客厅的灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭客厅的灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>相当于封装了一层，子系统怎么变不影响，提供统一入口，方便调用，降低客户类与子系统的耦合度（可以想作，我只需要找客服，不需要找其他人了，降低与他们的联系，也就是耦合）</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>符合迪米特法则（最少知道），但不符合开闭原则（每次子系统添加方法，外观类都得改变）</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、通常只需要一个外观类，因为他本来就是总开关的角色，你在写个类继承他，给他增加方法，那就违背了它本来的意义</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网上看了几个有jdbcutils的，tomcat的一些源码，但我觉得都有点牵强，不得不说这个模式技术点并不多，只是提供了一个统一封装的思想</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/post/563268dc.html"/>
      <url>/post/563268dc.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>这是一个不常用的设计模式，了解核心思想即可</p><ol><li>什么是桥接模式</li><li>应用场景</li><li>场景举例</li><li>Java实现</li></ol><h2 id="什么是桥接模式"><a href="#什么是桥接模式" class="headerlink" title="什么是桥接模式"></a>什么是桥接模式</h2><p>1、将抽象部分与实体部分分离</p><p>2、处理多个独立变化的维度，在抽象层建立关联，其中抽象类作为桥</p><p>3、通过构造函数的方式将接口传入实现联系</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>JDBC多种驱动的实现</p><p><img src="https://pic4.zhimg.com/v2-8fbc05ca92c0b8633c6d54c602e53473_b.png" alt="img"></p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>目前有支付方式wx支付与zfb支付，有解锁方式人脸识别与指纹解锁</p><p>现需要两种方式结合的方式才能完成付款功能，如何进行实现？</p><p>如果采用传统的方式，可得到类图</p><p><img src="https://pic2.zhimg.com/v2-58f33283460de4945934a95b8bdea83d_b.png" alt="img"></p><p>此时如果加一个云闪付，那么需要增加3个类，增加一个密码解锁需要增加2个类 </p><p>这个只是最简单的举例，实际业务远比这复杂得多，可以想象到，如果进行扩展，就很容易出现类爆炸的情况，这个时候使用桥接模式，可以很好的应对这种情况</p><p>传统方式的源码可以去git查看，这里就不贴了</p><p>桥接模式的类图</p><p><img src="https://pic2.zhimg.com/v2-1a3556f781e71e42a88a83eb81365a45_b.png" alt="img"></p><p>可以看到解锁抽象类当作桥，用于连接支付接口，扩展十分方便</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><p>支付接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wx支付</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WXPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wx支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zfb支付</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZFBPay</span> <span class="keyword">implements</span> <span class="title">IPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PayType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> IPay iPay;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayType</span><span class="params">(IPay iPay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iPay = iPay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人脸解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacePay</span> <span class="keyword">extends</span> <span class="title">PayType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FacePay</span><span class="params">(IPay iPay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iPay.pay();</span><br><span class="line">        System.out.println(<span class="string">&quot;人脸识别&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指纹解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FingerPay</span> <span class="keyword">extends</span> <span class="title">PayType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FingerPay</span><span class="params">(IPay iPay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iPay.pay();</span><br><span class="line">        System.out.println(<span class="string">&quot;指纹识别&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PayType p = <span class="keyword">new</span> FacePay(<span class="keyword">new</span> WXPay());</span><br><span class="line">p.pay();</span><br><span class="line">PayType p1 = <span class="keyword">new</span> FacePay(<span class="keyword">new</span> ZFBPay());</span><br><span class="line">p1.pay();</span><br><span class="line">PayType p2 = <span class="keyword">new</span> FingerPay(<span class="keyword">new</span> WXPay());</span><br><span class="line">p2.pay();</span><br><span class="line">PayType p3 = <span class="keyword">new</span> FingerPay(<span class="keyword">new</span> ZFBPay());</span><br><span class="line">p3.pay();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/post/df879792.html"/>
      <url>/post/df879792.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>角色</li><li>类图</li><li>种类</li><li>场景举例</li><li>实际应用场景</li><li>总结</li></ol><p><img src="https://pic4.zhimg.com/v2-9f901f64c41ebc204831a210419b5453_b.png" alt="img"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>组合模式定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行<strong>统一处理</strong>。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现<strong>递归组合</strong>，形成一个树形结构。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Component（抽象构件）：声明公共行为</p><p>Leaf（叶子结点，树叶构件）：没有子节点</p><p>Composite（树枝构件）：存储或管理子部件，有独特的list</p><h2 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h2><p><img src="https://pic2.zhimg.com/v2-ca1372997b69a85bd59b138fb69e8979_b.png" alt="img"></p><h2 id="以其他形式展现"><a href="#以其他形式展现" class="headerlink" title="以其他形式展现"></a>以其他形式展现</h2><p>在文件系统中可改写为如图，文件为抽象类定义了对象的一些属性及方法，具体的由文件夹和文件去实现，而文件只实现操作方法（getName）</p><p><img src="https://pic2.zhimg.com/v2-016e4786d83b56f53687eb87b6393345_b.png" alt="img"></p><p>而在别的场景中，如组织结构，这个文件夹就相当于一个统称了，比如一级部门下有二级，二级下有三级，等等，那么最后一级部门作为叶子节点，其余部门就全部充当树枝节点了</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>组合模式有<strong>透明方式</strong>与<strong>安全方式</strong></p><p>透明方式表示用户使用的时候不管是叶子还是树枝方法都是一样的，用户全能看到方法，但如果叶子结点调用add方法，就会出现异常</p><p>安全方式则针对于透明方式，透明方式出现异常的地方弄安全就叫安全模式，使叶子节点不实现add方法就好了</p><p>所以决定透明还是安全的就在于抽象构件这个怎么去定义</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>现需要展示公司的部门层级，如何实现？</p><p>先构建类图，捋清楚之前的关系（找到了一个画图软件，比mspaint好用多了）</p><p><img src="https://pic4.zhimg.com/v2-f0df6a06341ae8982f67965ffab7443b_b.png" alt="img"></p><p>再看client如何调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建公司</span><br><span class="line">Component company = new CompanyComposite(&quot;北京公司&quot;);</span><br><span class="line">//创建部门</span><br><span class="line">Component dept1 = new DeptComposite(&quot;财务部&quot;);</span><br><span class="line">Component dept2 = new DeptComposite(&quot;市场部&quot;);</span><br><span class="line">//创建叶子节点</span><br><span class="line">Component leaf = new Leaf(&quot;最小部门&quot;);</span><br><span class="line"></span><br><span class="line">//将部门加到公司中</span><br><span class="line">company.add(dept1);</span><br><span class="line">company.add(dept2);</span><br><span class="line"></span><br><span class="line">//将最小部门加到部门中</span><br><span class="line">dept1.add(leaf);</span><br><span class="line">dept2.add(leaf);</span><br><span class="line"></span><br><span class="line">//输出组织架构</span><br><span class="line">company.getChild();</span><br><span class="line">System.out.println(&quot;-------&quot;);</span><br><span class="line">dept1.getChild();</span><br></pre></td></tr></table></figure><p>输出截图</p><p><img src="https://pic2.zhimg.com/v2-4a5240499c56a580b34a1e96138e5685_b.png" alt="img"></p><p>抽象接口定义（这里使用了接口，并使用了Java8的默认接口特性，子类可以选择不实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component o)</span></span>&#123; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Component <span class="title">getChild</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公司实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyComposite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompanyComposite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component o)</span> </span>&#123;</span><br><span class="line">        organizationComponents.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Component temp : organizationComponents) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;下有&quot;</span>+temp.getName());</span><br><span class="line">                temp.getChild();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部门实现类（与公司大体一致，实际情况考虑到业务不同，树枝类不写到一坨）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptComposite</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeptComposite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component o)</span> </span>&#123;</span><br><span class="line">        organizationComponents.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Component temp : organizationComponents) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;下有&quot;</span>+temp.getName());</span><br><span class="line">                temp.getChild();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叶子部门实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>①在List中定义addAll()的方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的collection可以看作上面的Component</p><p>②JDK中AWT包和Swing包的设计是基于组合模式 ，在这些界面包中为用户提供了大量的容器构件，继承、关联于组件类Component</p><p>举个例子，比如Container类，其中的add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">add</span><span class="params">(Component comp)</span> </span>&#123;</span><br><span class="line">    addImpl(comp, <span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> comp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getTreeLock()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comp.parent == <span class="keyword">this</span>)  &#123;</span><br><span class="line">            <span class="keyword">int</span> index = component.indexOf(comp);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                remove(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、可以递归组合成任意复杂的对象</p><p>2、可随意增加新类型的Composite与Leaf的类</p><p>3、采用同一套接口操作</p><p>4、由于返回的使同一个接口类型，必要的时候需要做类型判断</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/post/f5c535ea.html"/>
      <url>/post/f5c535ea.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>什么是适配器模式</li><li>有几种适配器种类（了解）</li><li>应用场景</li><li>应用场景简单实现</li></ol><p><img src="https://pic4.zhimg.com/v2-0fc3e0195bda1f609351bfa528ac8ecb_b.png" alt="img"></p><h2 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h2><p>如图，将4个口最终转为一个口的能力，实现了很好的兼容</p><p>在程序对应中，将多个对象类型转为一个对象类型去调用方法</p><h2 id="有几种适配器种类（了解）"><a href="#有几种适配器种类（了解）" class="headerlink" title="有几种适配器种类（了解）"></a>有几种适配器种类（了解）</h2><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a><strong>类适配器</strong></h3><p>适配器类需要继承被适配器类（原来的东西）实现目标接口（转换得到的东西）</p><p>缺点：继承耦合性强，暴露了被适配器中的方法，好处是可以重写</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a><strong>对象适配器</strong></h3><p>不在继承，而是new一个实例，系统中尽量不使用继承关系，所以对象适配器是常用的一种 </p><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a><strong>接口适配器</strong></h3><p>有些适配方法不需要全部实现，这种情况下可以使用一个抽象类实现接口中的全部方法，然后用匿名内部类的方式实现自己用的方法。类似于监听器类</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>springmvc中的DispatcherServlet类中doDispatch方法中很清楚的出现了适配器的影子，只要把这块为什么作者使用适配器搞懂了，这个模式也就理解大半了，剩下的就是不断实践</p><p>1、首先根据传入的request来获取对应的handler</p><p><img src="https://pic4.zhimg.com/v2-c36befcb8ea690de36e4091174800c97_b.png" alt="img"></p><p>2、利用获取的handler获取适配器类adapter</p><p><img src="https://pic4.zhimg.com/v2-b67ade9fcdeeb297d679c30d15453e0f_b.png" alt="img"></p><p>3、利用该适配器调用对应的方法</p><p><img src="https://pic2.zhimg.com/v2-08f34399920909acd168bf7f934f826d_b.png" alt="img"></p><p>为什么用适配器，直接根据handler调对应方法不就可以了？</p><p>①不知道获得的handler类型，需要判断，这本身也是一个适配的过程</p><p>常用的handler有：Controller，HttpRequestHandler、Servlet。而它们都属于不同的类型，调用的方法名也不同</p><p><img src="https://pic2.zhimg.com/v2-2583661dee4cd5b347ae10dde1ad6add_b.png" alt="img"></p><p>②这里的handler被封装为了HandlerExecutionChain对象</p><p>这个类不知道获取的handler是什么类型，接口中虽然有获取handler方法，但返回类型为object。这时候需要用到handlerMapping来找对应的handler</p><p><img src="https://pic2.zhimg.com/v2-809cce465c627173fdb371288f0c020d_b.png" alt="img"></p><p>③那为什么不用handlerMapping来调用方法？</p><p>基于单一职责，一个类只做一件事情， 这个类的作用就是处理请求与handler的对应关系，调用是有各自的handler去提供</p><p>④每个handler实现方式不同，但有个共同特点，传参都有request与response，那么就可以设置一个适配器类，传入相同的参数在给一个handler类型，来帮不同的handler提供一个统一的调用方法，起到适配的作用，可以联想以下扩展坞，假如你的电脑只支持c口，那么想用a口，hdmi口，就需要扩展坞，扩展坞的好处是方便，不管有什么口最终都可以转为一个口，而且好扩展</p><p><img src="https://pic2.zhimg.com/v2-9df84890c01dd9d42a30609da6e6deb1_b.png" alt="img"></p><h2 id="适配器类的好处"><a href="#适配器类的好处" class="headerlink" title="适配器类的好处"></a>适配器类的好处</h2><p>只需要给我一个handler类型的对象就可以，具体是什么不用管。</p><p>如果进行扩展，只需要添加适配器类就可以，调用方无需修改</p><h2 id="不用适配器，能不能实现？"><a href="#不用适配器，能不能实现？" class="headerlink" title="不用适配器，能不能实现？"></a>不用适配器，能不能实现？</h2><p>可以，首先同样得到handler，然后遍历if-else判断得到具体的handelr类型，在调各自的方法即可，但不方便扩展，每次都需要改调用方代码，违反开闭原则。所以适配器也可以看作高级版的if-else</p><h2 id="适配器类在源码中是怎么实现的？"><a href="#适配器类在源码中是怎么实现的？" class="headerlink" title="适配器类在源码中是怎么实现的？"></a>适配器类在源码中是怎么实现的？</h2><p>举个例子，如果为HttpRequestHandler类型，则强转为这个类型，然后调用</p><p><img src="https://pic2.zhimg.com/v2-289b77519079f3f873f07bb44ba3bb7d_b.png" alt="img"></p><h2 id="简单的MVC实现"><a href="#简单的MVC实现" class="headerlink" title="简单的MVC实现"></a>简单的MVC实现</h2><p>uml类图</p><p><img src="https://pic1.zhimg.com/v2-11b1b08c225f7daa3332029b859b4e3c_b.png" alt="img"></p><p>先画出类图，再根据类图实现代码</p><p>定义handler接口，实现该接口标识为handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>HttpHandel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandel</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用HttpHandel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleHandel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandel</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimpleHandel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用SimpleHandel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义adapter接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HttpHandel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        ((HttpHandel)handler).doHttpHandel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> SimpleHandel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        ((SimpleHandel)handler).doSimpleHandel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟DispaterServlet类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做简化，spring中使用反射将adapter假如list中，如果扩展，只需要在配置文件中添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatcherServletTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handlerList.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">        handlerList.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传参做简化，spring源码中根据request来获取handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据不同的handler进行适配转换</span></span><br><span class="line">        HandlerAdapter adapter = <span class="keyword">this</span>.getHandler(handler);</span><br><span class="line">        <span class="comment">//进行方法调用</span></span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            adapter.handler(handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : handlerList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DispatcherServletTest().doDispatch(<span class="keyword">new</span> SimpleHandel());</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/post/a708a60d.html"/>
      <url>/post/a708a60d.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>该模式又称套娃模式</p><ol><li>应用场景</li><li>场景举例</li><li>Java实现</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>大家都见过流中套娃的写法，类似如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new BufferedInputStream(new FileInputStream(new File(&quot;&quot;)));</span><br></pre></td></tr></table></figure><p>如类似的实现关系，如图</p><p><img src="https://pic4.zhimg.com/v2-0c083d63ddd8d45671e045362ceef727_b.png" alt="img"></p><p>装饰者模式就是这样的写法，将对象动态增加功能，而不改变原有的功能</p><p>怎么体现不改变原有代码，而动态增加职责？</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>目前有一个咖啡接口，可以有众多咖啡实现，比如星巴克，瑞幸，类图如下，这也是原始的代码</p><p><img src="https://pic3.zhimg.com/v2-da380d0b52250a235829d137a51edc82_b.png" alt="img"></p><p>类代码如下</p><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICoffee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星巴克</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarBucksCoffee</span> <span class="keyword">implements</span> <span class="title">ICoffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;星巴克咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瑞幸</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LukinCoffee</span> <span class="keyword">implements</span>  <span class="title">ICoffee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;瑞幸咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我现在打算在每种具体的咖啡加增加口味，如何进行修改？</p><p>有人说，那我直接在咖啡接口中增加一个加调味品的方法就行了，这好吗？这不好。违反了开闭原则（OCP原则）</p><p>新增一个装饰器类也去实现咖啡的方法，在之前父类制作咖啡的方法增加额外的方法，比如加糖，加牛奶。</p><p><img src="https://pic1.zhimg.com/v2-5e6983bd077c6a62080dfcaf80f13b08_b.png" alt="img"></p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><p>装饰器抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorSpice</span> <span class="keyword">implements</span> <span class="title">ICoffee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICoffee coffee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorSpice</span><span class="params">(ICoffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coffee.getCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加糖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SugarDecorator</span> <span class="keyword">extends</span> <span class="title">DecoratorSpice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SugarDecorator</span><span class="params">(ICoffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getCoffee();</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加牛奶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkDecorator</span> <span class="keyword">extends</span> <span class="title">DecoratorSpice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MilkDecorator</span><span class="params">(ICoffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getCoffee();</span><br><span class="line">        System.out.println(<span class="string">&quot;加牛奶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LukinCoffee lukinCoffee = <span class="keyword">new</span> LukinCoffee();</span><br><span class="line">MilkDecorator milkDecorator = <span class="keyword">new</span> MilkDecorator(lukinCoffee);</span><br><span class="line">SugarDecorator sugarDecorator = <span class="keyword">new</span> SugarDecorator(milkDecorator);</span><br><span class="line">MilkDecorator addMilk2 = <span class="keyword">new</span> MilkDecorator(sugarDecorator);</span><br><span class="line">addMilk2.getCoffee();</span><br></pre></td></tr></table></figure><p>优点：可以看出在不改变源码的情况下，动态的增加了功能</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/post/d036071c.html"/>
      <url>/post/d036071c.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>中介者模式其实也就是字面意思，跟你买房的时候往往需要找个中介一样。中介会帮你处理所有事情，你只需要与中介一个人建立联系就可以。那么跟之前学习的代理模式有什么不同之处，代理是完成类和增强类的功能，中介主要是为了解耦</p><p>没有中介之前的模式类似于网状结构，不仅你需要跟每个人联系，而且需要他们互相之前也去建立联系，令人头疼的是这种结构往往牵一发而动全身</p><p><img src="https://pic3.zhimg.com/v2-2f768b4c9c3b612b8251c753195dffa6_b.png" alt="img"></p><p>网状结构</p><p>有中介之后类似于星状结构，所有人都找中介，大大降低了耦合性</p><p><img src="https://pic1.zhimg.com/v2-d03161dcb6f3a1281f1c13765b0ee514_b.png" alt="img"></p><p>星状结构</p><ol><li>定义</li><li>优点</li><li>缺点</li><li>角色</li><li>场景模拟</li><li>总结</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。是迪米特法则的典型应用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>降低各个对象的耦合性，使系统易于维护与扩展</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>每添加对象，就需要在中介处更新，如果对象过多，中介类就会变的臃肿，复杂难以维护</p><p>中介出问题，整个程序玩完，道理和卖房中介卷钱跑路一样</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>抽象中介者（Mediator）：中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p><p>具体中介者（ConcreteMediator）：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系。</p><p>抽象同事类（Colleague）：同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p><p>具体同事类（Concrete Colleague）：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a><strong>场景模拟</strong></h3><p>模拟一个发送消息的场景，有三个同事需要互相发消息，这样他们就需要每个人都需要建立关系，现在引入一个中介，发出的消息都由中介去代替他们发送</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>调用端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建中介</span></span><br><span class="line">Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line"><span class="comment">//创建三位具体同事</span></span><br><span class="line">Colleague colleague1 = <span class="keyword">new</span> ConcreteColleague1();</span><br><span class="line">Colleague colleague2 = <span class="keyword">new</span> ConcreteColleague2();</span><br><span class="line">Colleague colleague3 = <span class="keyword">new</span> ConcreteColleague3();</span><br><span class="line"><span class="comment">//中介者记录每个同事类</span></span><br><span class="line">mediator.register(colleague1);</span><br><span class="line">mediator.register(colleague2);</span><br><span class="line">mediator.register(colleague3);</span><br><span class="line"><span class="comment">//某个同事发送消息</span></span><br><span class="line">colleague1.send();</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个同事发送消息</span><br><span class="line">中介代替转发中...</span><br><span class="line">第二个同事收到消息</span><br><span class="line">第三个同事收到消息</span><br></pre></td></tr></table></figure><p>抽象中介，提供注册和转发方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="comment">//转发</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象同事，保存中介对象，提供交互方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体中介</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入的对象在集合中没有，则添加，并设置该同事的中介者</span></span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            <span class="comment">//不为每个同事设置中介者，他们就不知道中介者是谁，也就无法建立联系</span></span><br><span class="line">            colleague.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//除了当前同事，对其他同事做出响应</span></span><br><span class="line">        <span class="keyword">for</span> (Colleague c : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c.equals(colleague)) &#123;</span><br><span class="line">                c.receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体同事（每个都是一样的，输出略有变化，所有源码请查看git）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span>  <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个同事收到消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个同事发送消息&quot;</span>);</span><br><span class="line">        <span class="comment">//自己不发送，请求中介者发送</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中介代替转发中...&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>开发中并不常用，生活中常见，实际开发中可应用于对象间存在复杂网状关系时，可以引入中介者来使系统耦合性降低，更易扩展维护</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模（mu）板模式</title>
      <link href="/post/cf413e35.html"/>
      <url>/post/cf413e35.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>优点</li><li>缺点</li><li>应用场景</li><li>使用场景</li><li>钩子方法</li><li>场景举例</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个操作中的算法骨架，将算法的一些子步骤延伸到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、封装不变部分，扩展可变部分，不变的封装到父类实现，可变的由子类去扩展</p><p>2、便于代码复用，易于拓展，符合开闭原则</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、父类的方法由子类实现，是一种反向控制，提高代码阅读难度</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>使用spring的都用过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(“classpath:<span class="comment">/*.xml”);</span></span><br><span class="line"><span class="comment">ac.getBean(&quot;bean&quot;)</span></span><br></pre></td></tr></table></figure><p>这个类的就是模板方法子类的一种体现，通过不断的继承重写父类方法，子类所需要实现的方法越来越少，也可以看出该模式是一种反向控制模式</p><p><img src="https://pic2.zhimg.com/v2-c2c9e244c08c2c78cdae5f9648629009_b.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">      prepareRefresh();</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         beanPostProcess.end();</span><br><span class="line">         initMessageSource();</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line">         <span class="comment">//钩子方法</span></span><br><span class="line">         onRefresh();</span><br><span class="line">         registerListeners();</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         destroyBeans();</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">         contextRefresh.end();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、算法的整体步骤很固定，但其中个别部分易变时</p><p>2、当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，就可以只允许进行部分扩展</p><h2 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h2><p>钩子方法源于设计模式中模板方法模式，模板方法模式中分为两大类：模版方法和基本方法，而基本方法又分为：<strong>抽象方法，具体方法，钩子方法</strong>。</p><p>对于抽象方法或者接口中定义的方法的一个<strong>空实现</strong>，在实际中的应用，比如说有一个接口，而你只想用其中一个方法，那么可以写一个抽象类实现这个接口，在这个抽象类里将你要用的那个方法设置为abstract,其它方法进行空实现，然后你再继承这个抽象类，就不需要实现其它不用的方法，这就是钩子方法的作用</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>现在小王需要在公司每周写周报，而周报的格式基本上又不变，在中间修改部分内容即可，假如平常按照总分总的结构写，偶尔加一些图片什么的，那么抽象类可以如此实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weekly</span> </span>&#123;</span><br><span class="line">   <span class="comment">//防止子类重写,相当于算法骨架</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        <span class="keyword">if</span> (hook()) &#123;</span><br><span class="line">            addOther();</span><br><span class="line">        &#125;</span><br><span class="line">        content();</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;周报开头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;周报正文&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;周报开头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加其他一些东西</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addOther</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认不添加</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A同事比较懒，只实现公司要求的基本方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPeople</span> <span class="keyword">extends</span> <span class="title">Weekly</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B同事比较喜欢表现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPeople</span> <span class="keyword">extends</span> <span class="title">Weekly</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加些图片，加点论证&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写钩子，使父类调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hook</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> LazyPeople().write();</span><br><span class="line"><span class="keyword">new</span> SmartPeople().write();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周报开头</span><br><span class="line">周报正文</span><br><span class="line">周报开头</span><br><span class="line">周报开头</span><br><span class="line">加些图片，加点论证</span><br><span class="line">周报正文</span><br><span class="line">周报开头</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/post/78134e07.html"/>
      <url>/post/78134e07.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>小米之家的一些家电，用一个app就可以进行控制，每个智能产品只需要提供一个统一的接口给小米app调用就行了，这就用到了命令模式</p><ol><li>定义</li><li>通用类图</li><li>角色</li><li>场景举例</li><li>总结</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>向某些对象发送请求，但不知道请求的接收者是谁，也不知道被请求的操作是哪一个，此时可以采用命令模式</p><p>发布者只管发送命令，不管谁去执行。不直接指挥执行者，而是通过命令类去处理</p><h2 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a><strong>通用类图</strong></h2><p><img src="https://pic2.zhimg.com/v2-e1bdf3804043a4ffaa71983f1fe7eac1_b.png" alt="img"></p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Command：命令角色，可以是接口或者抽象类</p><p>ConcreateCommand：定义具体命令</p><p>Receiver：接收者角色，等待命令并执行</p><p>Invoker：调用者，按照客户端指令执行命令，包括撤销命令</p><p>命令模式的精髓就是命令者并不需要知道谁去执行这个命令，比如老板让秘书去打印一些文件，命令就是打印文件，秘书在交给具体打印者去打印，老板不关心是小王还是小李打印</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>小王买了两个机器人A,B。A会唱歌，跳舞。B会炒菜。小王可以发布命令“唱歌，跳舞，炒菜”</p><p>uml类图设计</p><p><img src="https://pic4.zhimg.com/v2-5df7fc90fccea539ddea9d20aafeb39b_b.png" alt="img"></p><p>抽象类Command</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AB机器人（Receiver角色）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARobot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A机器人在唱歌&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A机器人在跳舞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRobot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeFry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B机器人在炒菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体命令（ConcreateCommand角色）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ARobotReceiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingCommand</span><span class="params">(ARobotReceiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DanceCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ARobotReceiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DanceCommand</span><span class="params">(ARobotReceiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeFryCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BRobotReceiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MakeFryCommand</span><span class="params">(BRobotReceiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.makeFry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者(Invoker角色）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotInvoker</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command c : commands) &#123;</span><br><span class="line">            c.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建王老板</span></span><br><span class="line">RobotInvoker wang = <span class="keyword">new</span> RobotInvoker();</span><br><span class="line"><span class="comment">//命令初始化</span></span><br><span class="line">wang.addCommand(<span class="keyword">new</span> SingCommand());</span><br><span class="line">wang.addCommand(<span class="keyword">new</span> DanceCommand());</span><br><span class="line">wang.addCommand(<span class="keyword">new</span> MakeFryCommand());</span><br><span class="line"><span class="comment">//执行命令</span></span><br><span class="line">wang.execute();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>源码实际应用场景还没找到，后续找到补充</li><li>命令接口除了可以执行操作，也可以进行撤销（关联别的设计模式，后续补充）</li><li>一个命令类只能完成一个命令比如上面的SingCommand/DanceCommand/MakeFryCommand</li><li>调用者Invoker只知道命令接口，并不知道具体命令。就好比遥控器只知道哪个能换台，哪个能调节音量，不管它怎么实现的。</li><li>client端就好比遥控器的角色</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/post/c3176455.html"/>
      <url>/post/c3176455.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>应用场景</li><li>优点</li><li>缺点</li><li>角色</li><li>场景模拟</li><li>总结</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>记录某一时刻的状态，以便用到的时候恢复</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>ctrl+z、快照，回滚，游戏存档，悔棋，相关的备份操作</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>在需要的时候可以很方便的恢复需要的状态</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>频繁保存会消耗大量资源</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>发起者（Originator）：记录状态信息，同时可以访问备忘录中的信息</p><p>备忘录（Memento）：储存发起人的内部状态</p><p>管理者（Caretaker）：用于保存和获取备忘录功能，但不能修改</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a><strong>场景模拟</strong></h3><p>模拟小游戏打怪场景，一个怪2分，可以存档和读档</p><p>调用场景实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line"><span class="comment">//开始游戏</span></span><br><span class="line">System.out.println(<span class="string">&quot;开始游戏，杀死一个小怪得2分&quot;</span>);</span><br><span class="line"><span class="comment">//开始杀怪</span></span><br><span class="line">originator.kill();</span><br><span class="line">originator.kill();</span><br><span class="line"><span class="comment">//显示目前游戏状态</span></span><br><span class="line">originator.getScore();</span><br><span class="line"><span class="comment">//存档</span></span><br><span class="line">careTaker.saveMemento(originator.save());</span><br><span class="line"><span class="comment">//退出游戏</span></span><br><span class="line">originator.exit();</span><br><span class="line"><span class="comment">//显示目前游戏状态</span></span><br><span class="line">originator.getScore();</span><br><span class="line"><span class="comment">//读档</span></span><br><span class="line">originator.restoreProcess(careTaker.getMemento(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//显示目前游戏状态</span></span><br><span class="line">originator.getScore();</span><br><span class="line"><span class="comment">//在杀</span></span><br><span class="line">originator.kill();</span><br><span class="line"><span class="comment">//显示目前游戏状态</span></span><br><span class="line">originator.getScore();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">开始游戏，杀死一个小怪得2分</span><br><span class="line">小怪被消灭！获得2分</span><br><span class="line">小怪被消灭！获得2分</span><br><span class="line">目前的游戏数据为：杀了2只怪，分数为4分</span><br><span class="line">存档中...</span><br><span class="line">退出游戏</span><br><span class="line">目前的游戏数据为：杀了0只怪，分数为0分</span><br><span class="line">读档中...</span><br><span class="line">目前的游戏数据为：杀了2只怪，分数为4分</span><br><span class="line">小怪被消灭！获得2分</span><br><span class="line">目前的游戏数据为：杀了3只怪，分数为6分</span><br></pre></td></tr></table></figure><p>Originator实现—游戏类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小怪的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentCount;</span><br><span class="line">    <span class="comment">//小怪单个的价值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存档</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;存档中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(currentCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复分数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreProcess</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读档中...&quot;</span>);</span><br><span class="line">        currentCount = memento.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//杀死一个小怪+2分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小怪被消灭！获得&quot;</span>+value+<span class="string">&quot;分&quot;</span>);</span><br><span class="line">        currentCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目前的游戏数据为：杀了&quot;</span>+currentCount+<span class="string">&quot;只怪，分数为&quot;</span>+currentCount*value+<span class="string">&quot;分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;退出游戏&quot;</span>);</span><br><span class="line">        currentCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Memento备忘录—游戏对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CareTaker管理者—用于存档读档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; memento= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memento.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在JDK、Spring、Mybatis 中很少有备忘录模式，没找到合适的源码场景</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/post/8acb1976.html"/>
      <url>/post/8acb1976.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>优点</li><li>角色</li><li>场景举例</li><li>总结</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>将复杂的逻辑判断提取到不同的状态对象中，允许内部状态发生改变时改变其行为</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>结构清晰，满足单一职责，减少对象的相互依赖，易于程序扩展</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>上下文（Context）：它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</p><p>抽象状态（State）：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</p><p>具体状态（Concrete State）：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</p><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a><strong>场景举例</strong></h3><p>线程生命周期举例</p><p><img src="https://pic3.zhimg.com/v2-fee9c7db96f6ab60bf0b459753628996_b.png" alt="img"></p><p>如图，存在5种状态，在每个状态获得一定条件之后会转换为其他状态</p><p>如果用传统的方式实现，if/switch利用现在的状态来做这个状态下的行为</p><p>伪代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> InitialState) &#123;</span><br><span class="line">    <span class="comment">//新建状态调用</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">    <span class="comment">//就绪状态调用</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Running) &#123;</span><br><span class="line">    <span class="comment">//运行状态调用</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Blocked) &#123;</span><br><span class="line">    <span class="comment">//阻塞状态调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式实现</p><p>uml类图</p><p><img src="https://pic4.zhimg.com/v2-186a678ff547b11045fe4c07f87d9617_b.png" alt="img"></p><p>调用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上下文环境创建</span></span><br><span class="line">Context context = <span class="keyword">new</span> Context();</span><br><span class="line"><span class="comment">//不需要用if判断，会根据自身类型调用不同的方法</span></span><br><span class="line">context.start();</span><br><span class="line">context.getCPU();</span><br><span class="line">context.suspend();</span><br><span class="line">context.resume();</span><br><span class="line">context.getCPU();</span><br><span class="line">context.stop();</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前线程处于：新建状态</span><br><span class="line">调用start方法开始启动一个线程--&gt;当前线程处于：就绪状态</span><br><span class="line">获得CPU时间片--&gt;当前线程处于：运行状态</span><br><span class="line">阻塞条件达成--&gt;当前线程处于：阻塞状态</span><br><span class="line">阻塞解决当前线程处于：就绪状态</span><br><span class="line">获得CPU时间片--&gt;当前线程处于：运行状态</span><br><span class="line">线程执行完毕--&gt;当前线程处于：死亡状态</span><br></pre></td></tr></table></figure><p>抽象状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exception NotSupportException = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不能直接使用超类提供的方法&quot;</span>);</span><br><span class="line">    <span class="comment">//默认实现</span></span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> NotSupportException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取时间片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCPU</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> NotSupportException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> NotSupportException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> NotSupportException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞恢复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> NotSupportException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体状态（5种）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitialState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：新建状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用start方法开始启动一个线程--&gt;&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> Runnable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其余实现类请查看git地址</span></span><br></pre></td></tr></table></figure><p>上下文环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    Context() &#123;</span><br><span class="line">        state = <span class="keyword">new</span> InitialState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set、get</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        state.start(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取时间片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCPU</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        state.getCPU(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        state.suspend(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        state.stop(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞恢复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        state.resume(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>最大的好处可以看到消除了if-else的写法，让整个程序更易于扩展</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/post/30cf0cd2.html"/>
      <url>/post/30cf0cd2.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>用的原因</li><li>缺点</li><li>角色</li><li>场景举例</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>用编译语言的方式来分析应用中的实例</p><h3 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a><strong>为什么要用</strong></h3><p>扩展性好，利用继承机制扩展文法</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>效率低，调用麻烦，容易引起类膨胀，这个模式很少能用到</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>抽象表达式（Abstract Expression）：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p><p>终结符表达式（Terminal Expression）：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p><p>非终结符表达式（Nonterminal Expression）：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p><p>上下文（Context）：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a><strong>场景举例</strong></h3><p>设计一个读卡器，北京或太原的老年和孕妇刷卡免费，其余人群标准价</p><p>首先设计文法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</span><br><span class="line">&lt;city&gt; ::= 北京|太原</span><br><span class="line">&lt;person&gt; ::= 老人|孕妇</span><br></pre></td></tr></table></figure><p>uml类图</p><p><img src="https://pic2.zhimg.com/v2-341194f2849455b85f06f2225165d005_b.png" alt="img"></p><p>程序调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建上下文运行环境，这里指刷卡用的bus</span></span><br><span class="line">Context bus = <span class="keyword">new</span> Context();</span><br><span class="line"><span class="comment">//不同人群刷卡</span></span><br><span class="line">System.out.println(<span class="string">&quot;公交乘车开始刷卡&quot;</span>);</span><br><span class="line">bus.freeRide(<span class="string">&quot;北京的老人&quot;</span>);</span><br><span class="line">bus.freeRide(<span class="string">&quot;太原的孕妇&quot;</span>);</span><br><span class="line">bus.freeRide(<span class="string">&quot;太原的儿童&quot;</span>);</span><br><span class="line">bus.freeRide(<span class="string">&quot;上海的老人&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">公交乘车开始刷卡</span><br><span class="line">哔！老人卡，欢迎乘车，您本次乘车免费！</span><br><span class="line">哔！孕妇卡，欢迎乘车，您本次乘车免费！</span><br><span class="line">哔！欢迎乘车，您本次乘车扣费2元！</span><br><span class="line">哔！欢迎乘车，您本次乘车扣费2元！</span><br></pre></td></tr></table></figure><p>抽象表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终结符表达式（具体实现者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            set.add(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(info)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非终结符表达式（具体实现者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line">    <span class="comment">//左半部分</span></span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="comment">//右半部分</span></span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line">    <span class="comment">//切分关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLEX = <span class="string">&quot;的&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression city, Expression person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = city;</span><br><span class="line">        <span class="keyword">this</span>.right = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        String s[] = info.split(FLEX);</span><br><span class="line">        <span class="comment">//符合文法的全部才会返回true</span></span><br><span class="line">        <span class="keyword">return</span> left.interpret(s[<span class="number">0</span>]) &amp;&amp; right.interpret(s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上下文Context</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] citys = &#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;太原&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] persons = &#123;<span class="string">&quot;老人&quot;</span>, <span class="string">&quot;孕妇&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Expression expression;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Expression city = <span class="keyword">new</span> TerminalExpression(citys);</span><br><span class="line">        Expression person = <span class="keyword">new</span> TerminalExpression(persons);</span><br><span class="line">        expression = <span class="keyword">new</span> AndExpression(city, person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeRide</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提示语，可自行设置</span></span><br><span class="line">        String s1 = <span class="string">&quot;哔！&quot;</span>+info.split(FLEX)[<span class="number">1</span>] + <span class="string">&quot;卡，欢迎乘车，您本次乘车免费！&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;哔！欢迎乘车，您本次乘车扣费2元！&quot;</span>;</span><br><span class="line">        System.out.println(expression.interpret(info) ? s1 : s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/post/72e3b671.html"/>
      <url>/post/72e3b671.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>使用场景</li><li>角色</li><li>场景举例</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><p>有些问题存在一题多解的情况，这时候往往需要if结构去判断调用其行为，可以考虑使用该模式</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>抽象策略（Strategy）：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</p><p>具体策略（Concrete Strategy）：实现了抽象策略定义的接口，提供具体的算法实现。</p><p>环境（Context）：持有一个策略类的引用，最终给客户端调用。</p><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a><strong>场景举例</strong></h3><p>王老板打算去约会，打算考虑一种出行方案，既省钱又快速，方案如下</p><p>1、公交：1块/km，用时30分钟</p><p>2、打车：3km起步价5块，超1km加2块</p><p>3、单车：2块/5km</p><p>传统写法是这么调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fee</span><span class="params">(String way,<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> trafficFee = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (way) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;bus&quot;</span>:</span><br><span class="line">            trafficFee = <span class="number">1</span> * distance;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;didi&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span>(distance&lt;=<span class="number">3</span>)</span><br><span class="line">                trafficFee = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trafficFee=<span class="number">5</span>+(distance-<span class="number">3</span>)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;bicycle&quot;</span>:</span><br><span class="line">            trafficFee = <span class="number">2</span> * distance/<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trafficFee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1 = fee(<span class="string">&quot;bus&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> s2 = fee(<span class="string">&quot;didi&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> s3 = fee(<span class="string">&quot;bicycle&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(s1 + <span class="string">&quot;:&quot;</span> + s2 +<span class="string">&quot;:&quot;</span>+ s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Context c = <span class="keyword">new</span> Context();</span><br><span class="line">    System.out.println(<span class="string">&quot;坐公交花费&quot;</span> + c.fee(<span class="keyword">new</span> ByBus(), <span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;打车花费&quot;</span> + c.fee(<span class="keyword">new</span> ByTaxi(), <span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;骑单车花费&quot;</span> + c.fee(<span class="keyword">new</span> ByBicycle(), <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">坐公交花费5</span><br><span class="line">打车花费9</span><br><span class="line">骑单车花费2</span><br></pre></td></tr></table></figure><p>策略抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calFee</span><span class="params">(<span class="keyword">int</span> distance)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByTaxi</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="comment">//超过起步价每公里价格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TAXI_FEE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//起步价格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TAXI_START = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//起步距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TAXI_DISTANCE = <span class="number">3</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calFee</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance &lt;= TAXI_DISTANCE ? TAXI_START : TAXI_START + (distance-TAXI_DISTANCE) * TAXI_FEE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只贴打车代码，其余可查看git</span></span><br></pre></td></tr></table></figure><p>上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fee</span><span class="params">(Strategy strategy, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.calFee(distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王老板思来想去，还是骑上了心爱的小单车</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/post/9a246216.html"/>
      <url>/post/9a246216.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>角色</li><li>使用场景</li><li>缺点</li><li>Java实现</li><li>总结</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>当一个对象状态发生改变时，依赖它的所有对象都会得到通知并通知自动更新</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>抽象主题（Subject）：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</p><p>具体主题（ConcreteSubject）：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</p><p>抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</p><p>具体观察者（ConcreteObserver）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><p>1、存在一对多的对象关系，一个对象改变影响其他对象</p><p>2、广播机制。如邮件订阅，公众号订阅、up的关注等</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>在观察者过多的时候，通知效率会降低</p><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a><strong>Java实现</strong></h3><p>uml类图，可以看到具体目标对象与观察者的耦合很小</p><p><img src="https://pic2.zhimg.com/v2-101ab967dab67e2750095527f4401775_b.png" alt="img"></p><p>如何调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建目标对象</span></span><br><span class="line">Subject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"><span class="comment">//创建观察者</span></span><br><span class="line">Observer o1 = <span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">Observer o2 = <span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line"><span class="comment">//将目标对象与观察者关联</span></span><br><span class="line">concreteSubject.addObserver(o1);</span><br><span class="line">concreteSubject.addObserver(o2);</span><br><span class="line"><span class="comment">//目标对象发生变化</span></span><br><span class="line">concreteSubject.notifyObserver();</span><br></pre></td></tr></table></figure><p>抽象主题（目标对象抽象类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建观察者集合，protected为了目标对象可以访问到</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addObserver</span><span class="params">(Observer o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标对象状态发生改变，通知给所有观察者！&quot;</span>);</span><br><span class="line">        <span class="comment">//所有观察者做出响应</span></span><br><span class="line">        <span class="keyword">for</span> (Observer o : list) &#123;</span><br><span class="line">            o.response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者对象1已经收到通知，正在变更状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者对象2已经收到通知，正在变更状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个简单的模式就搭出来了，结果输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标对象状态发生改变，通知给所有观察者</span><br><span class="line">观察者对象1已经收到通知，正在变更状态...</span><br><span class="line">观察者对象2已经收到通知，正在变更状态...</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>监听器类都是观察者模式的一种体现</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/post/9055d217.html"/>
      <url>/post/9055d217.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><ol><li>定义</li><li>为什么需要</li><li>常见写法</li><li>角色</li><li>场景举例</li><li>总结</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p><h3 id="为什么需要迭代器模式"><a href="#为什么需要迭代器模式" class="headerlink" title="为什么需要迭代器模式"></a><strong>为什么需要迭代器模式</strong></h3><p>在我们遍历元素的时候，不能将内部元素的数据结构（如数组，集合）暴露给用户。需要保证数据安全性。其次也增加了用户的负担，它原本也不需要知道内部结构</p><h3 id="常见的迭代器写法"><a href="#常见的迭代器写法" class="headerlink" title="常见的迭代器写法"></a><strong>常见的迭代器写法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">Iterator iter = list.iterator();</span><br><span class="line"> <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">     String str = (String) iter.next();</span><br><span class="line">     System.out.println(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>日常开发中不需要重复造轮子，框架给的API就够用了，自己模拟实现迭代器实现如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyIterable&lt;Student&gt; list = <span class="keyword">new</span> ConcreteIterable();</span><br><span class="line">MyIterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将MyIterable看作ArrayList</p><p>因为ArrayList内部实现了Iterable接口（实际上是Collection接口实现的，List继承了相关父类而得到的能力）</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>抽象聚合（MyIterable）角色：定义创建迭代器对象的接口。</p><p>具体聚合（ConcreteIterable）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p><p>具体迭代器（ConcreteIterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a><strong>场景举例</strong></h3><p>假如需要遍历一个学生对象类</p><p>uml类图</p><p><img src="https://pic4.zhimg.com/v2-6b007ddbc136d8b0c62dff11111ef2cf_b.png" alt="img"></p><p>首先建立学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//get、set、构造器、toString省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器能力接口，使实现的子类具有迭代器的能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyIterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">MyIterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器接口，定义遍历条件与遍历过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现类实现两个接口，进行方法重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterable</span> <span class="keyword">implements</span> <span class="title">MyIterable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//做简化</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">&quot;小李&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addStudent</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeStudent</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参照ArrayList实现方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">MyIterator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; list.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用就是最上面的</p><p>结果输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;id=1, name=&#x27;小王&#x27;&#125;</span><br><span class="line">Student&#123;id=2, name=&#x27;小李&#x27;&#125;</span><br><span class="line">Student&#123;id=3, name=&#x27;小张&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>该模式与聚合对象关系密切，通常在以下场景中使用</p><ol><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时</li></ol><p>而大多数语言在实现据合类的时候已经提供了迭代器类，用本身自带的就足够了</p><p>具体的源码可以参照JDK提供的Iterator、Iterable、ArrayList等</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/post/64b51ed9.html"/>
      <url>/post/64b51ed9.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>这个模式比较抽象，用到了双分派技术，比较复杂</p><ol><li>定义</li><li>使用场景</li><li>角色</li><li>场景举例</li><li>总结</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于其内部各个元素的新操作</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>类结构比较稳定，不会经常增删不同类型的元素。而需要经常给这些元素添加新的操作的时候，考虑使用此设计模式。（元素不变，操作变）</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><strong>ObjectStructure</strong></p><p>封装元素用的结构，可以操作或访问之中的元素</p><p><strong>Visitor</strong></p><p>访问者，接口，定义元素的方法</p><p><strong>ConcreteVisitor</strong></p><p>访问者实现类</p><p><strong>Element</strong></p><p>结构中的元素</p><p><strong>ConcreteElement</strong></p><p>元素实现类</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>王老板开了家公司，招了小李，小雷。打算疯狂压榨打工人。要求做前端，后端，测试，部署，产品销售等等，而且近期不准备招新人。</p><p>这种就符合元素不变（就一个人）而操作经常变（一会儿干这，一会儿干那的）</p><p>下面进行实现</p><p>这么一家有爱的公司，就叫它有爱公司</p><p>是这么调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建有爱公司</span></span><br><span class="line">LoveCompany loveCompany = <span class="keyword">new</span> LoveCompany();</span><br><span class="line"><span class="comment">//制作产品</span></span><br><span class="line">loveCompany.build(<span class="keyword">new</span> BuildProject());</span><br><span class="line"><span class="comment">//销售产品</span></span><br><span class="line">loveCompany.build(<span class="keyword">new</span> SaleProject());</span><br></pre></td></tr></table></figure><p>类图</p><p><img src="https://pic3.zhimg.com/v2-6c6237daff3be6b267e59f1db2ec945a_b.png" alt="img"></p><p>打工人抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="comment">//干活</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小李倒霉蛋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lee</span> <span class="keyword">implements</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小雷倒霉蛋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ray</span> <span class="keyword">implements</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问者（将来干什么活）,一个人（元素）对应一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Lee lee)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Ray ray)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有爱公司</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoveCompany</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Worker&gt; employee= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoveCompany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        employee.add(<span class="keyword">new</span> Lee());</span><br><span class="line">        employee.add(<span class="keyword">new</span> Ray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker slave : employee) &#123;</span><br><span class="line">            slave.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在王老板要求开发出一套产品来，让小李干设计前端，小雷干后端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildProject</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Lee lee)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;悲催的小李进行设计，前端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Ray ray)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;悲催的小雷进行后端开发，测试工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王老板觉得干得不错，小伙子们有前途，给我销售吧，小李营销，小雷帮公司记账</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildProject</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Lee lee)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;悲催的小李进行设计，前端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Ray ray)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;悲催的小雷进行后端开发，测试工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改日，王老板觉得小伙子们做的不错，表示他家房子还蛮大的，晚上来开party。。</p><p>结果输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">悲催的小李进行设计，前端开发</span><br><span class="line">悲催的小雷进行后端开发，测试工作</span><br><span class="line">小李开始卖力营销，争做奋斗好青年</span><br><span class="line">小雷开始帮公司做账，早日做大做强</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、可以看出，有爱公司可以识别出干活场景（根据不同的打工人），如果在加一个小蔡（元素），改动会比较大这个模式就不适用了</p><p>2、如果继续给他们安排活，只需要增加一个类，符合开闭原则</p><p>3、这里出现了双分派的技术</p><p>所以来解释一下，更多的可以去网上和实战中了解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker slave : employee) &#123;</span><br><span class="line">        slave.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据不同的打工人来调用各自的行为，在运行期决定，所以也叫动态单分派。</p><p>点进去看各自元素的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">    visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visitor方法由传入的this决定，如果this为小李就执行小李的方法，小雷就是小雷的方法，所以又是一个动态单分派</p><p>和前一次一起算就是伪动态双分派，为什么是伪的？Java是一个单分派语言，这里是通过分别的两次加起来才实现双分派，所以是伪的</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/post/6208627e.html"/>
      <url>/post/6208627e.html</url>
      
        <content type="html"><![CDATA[<p>设计模式源码git地址：<a href="https://gitee.com/leidl97/design-pattern-src">design-pattern-src: 设计模式源码 (gitee.com)</a></p><p>将请求发送到链条上，只关心它传给谁，不关心传递过程与处理细节，将请求者与处理者进行解耦</p><ol><li>定义</li><li>优点</li><li>缺点</li><li>角色</li><li>场景模拟</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>解耦，可扩展，灵活，符合单一职责</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>不能保证每个请求一定被处理，请求没有明确的处理者</p><p>如果链子过长，会影响系统性能</p><p>搭链子需要靠客户端完成，增加了客户端的复杂性，如果搭错，可能形成环</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>抽象处理者（Handler）：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p><p>具体处理者（Concrete Handler）：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p><p>客户类（Client）：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a><strong>场景模拟</strong></h3><p>王老板的下属打算请假，王老板给指定了一个请假规则</p><p>请假小于3天，上级领导可以审批</p><p>请假小于7天，需要部门领导审批</p><p>请假小于15天，需要王老板审批</p><p>请假大于15天，王老板表示不想干可以走人</p><p>传统方式实现就不举例了，很简单，一个if-else就可以实现</p><p>使用策略模式实现</p><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Handler directHandler = <span class="keyword">new</span> DirectHandler();</span><br><span class="line">Handler deptHandler = <span class="keyword">new</span> DeptHandler();</span><br><span class="line">Handler CEO = <span class="keyword">new</span> CEOHandler();</span><br><span class="line">directHandler.setNextHandler(deptHandler);</span><br><span class="line">deptHandler.setNextHandler(CEO);</span><br><span class="line">System.out.println(directHandler.handler(<span class="number">14</span>) ? <span class="string">&quot;多谢领导&quot;</span> : <span class="string">&quot;打扰了&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请假天数过长，交给上级领导审批...</span><br><span class="line">请假天数过长，交给上级领导审批...</span><br><span class="line">直系领导批了</span><br><span class="line">多谢领导</span><br></pre></td></tr></table></figure><p>抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置下一个处理者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler handler)</span></span>;</span><br><span class="line">    <span class="comment">//处理</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> day)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (day &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;直系领导批了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请假天数过长，交给上级领导审批...&quot;</span>);</span><br><span class="line">        <span class="comment">//防止链条上错抛异常</span></span><br><span class="line">        <span class="keyword">return</span> handler == <span class="keyword">null</span> ? <span class="keyword">false</span> : handler.handler(day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个类省略，详情可查看git</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之路</title>
      <link href="/post/2cd418c2.html"/>
      <url>/post/2cd418c2.html</url>
      
        <content type="html"><![CDATA[<p>一个类就能解决的事情，非得拆出四五个类，还得处理类之间的关系，这是在炫技，没有实际用处，这就是我当初的想法</p><p>确实，如果代码少或者系统业务不复杂的情况下，怎么写都可以，实现了功能就好了，但在后期维护上如果没有一个好的设计，那就是在堆屎山。写的人爽，维护的人骂娘</p><p>内心os：我目前在维护的这个系统真是让我苦不堪言，就是因为当初没有一个好的设计，现在想改也改不了，业务量巨大，不想吐槽了，任务就是保证系统正常运行就好</p><p><strong>什么情况下不用设计模式</strong></p><p>1、没学过，或者学过不会用</p><p>2、需求简单，用设计模式确实没必要</p><p>3、工期紧，还讲究什么模式，先实现功能吧</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>为什么要学设计模式</li><li>什么是设计模式</li><li>看看你在第几层</li><li>如何学明白设计模式</li><li>去哪学？怎么学？</li><li>设计模式的六大原则</li><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li><li>总结</li></ol><h2 id="为什么要学设计模式"><a href="#为什么要学设计模式" class="headerlink" title="为什么要学设计模式"></a>为什么要学设计模式</h2><p>在《重学Java设计模式》中有一段说的特别形象</p><blockquote><p>就像火车加一节车厢不需要改动整列火车 插线板可以支持随时插入各种功能的插头 签字笔没墨水了可以更换笔芯 总之满足基本原则：做出一个可扩展、易维护、好管理的工程代码</p></blockquote><p>参照spring与jdk的源码，为什么debug会经常跟丢？为什么要用工厂来返回对象，不去直接new？为什么一个方法就一句话，甚至空实现？开发者们在这么庞大的工程面前，如果没有一个好的设计，就和盖楼只会砖头堆砖头一样，代码会越来越糟糕。最后总结下面5点</p><ol><li>面试。不解释了很大几率会问到，索性都是背八股，不如系统性的学一遍</li><li>不在束缚于语言。有好的设计能力才是研发人员的价值所在</li><li>拒绝CRUD第二步。不当一辈子码农</li><li>拒绝代码屎山。只有真正遇到过的才理解这种痛</li><li>阅读源码更从容。源码其实也就是设计模式+反射</li></ol><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>设计模式英文名叫Design pattern，用来解决<strong>软件设计中</strong>普遍存在的<strong>各种问题</strong>的<strong>解决方案</strong></p><p>不局限于代码，就算是一种设计模式，在不同场景中也会有不同的实现方式</p><h2 id="看看你在第几层"><a href="#看看你在第几层" class="headerlink" title="看看你在第几层"></a>看看你在第几层</h2><p>第一层：没听过什么是设计模式</p><p>第二层：写了很多代码，也用到了设计模式，但自己不知道</p><p>第三层：学过设计模式，发现自己已经在使用了，并且发现了一些新的设计模式</p><p>第四层：阅读别人源码和框架，发现设计模式的精妙与带来的好处</p><p>第五层：写代码没有意识到自己使用了设计模式，但能熟练的写出来</p><h2 id="如何学明白设计模式"><a href="#如何学明白设计模式" class="headerlink" title="如何学明白设计模式"></a>如何学明白设计模式</h2><p>学习每个设计模式，都应该思考</p><p>1、该模式的使用场景</p><p>2、该模式类（角色）之间的关系</p><p>3、这个设计模式是哪里好？哪里值得学？哪里会用它？</p><p>4、在框架中，源码中哪里得到了体现？我从中能学到什么？</p><h2 id="去哪学？"><a href="#去哪学？" class="headerlink" title="去哪学？"></a>去哪学？</h2><p>我在b站看两位老师的视频学习，地址附上，另外自己买了一本《重学Java设计模式》，因为上本《算法》有点后悔，实在是难啃。这次买个能读下去的，目前看下来这本书写的确实比较浅，不通透，比如工厂模式就讲了两种。其他模式讲的穿插了大量业务伪代码，导致核心的设计模式不好体现，在抽象工厂模式中还穿插了代理模式，能把一个模式先讲明白了再说吧。总之这本书我不是很推荐</p><p>看完视频就刷博客，重要的是要尽量搞懂一个设计模式，然后在学下一个</p><p>有两个博客写的也不错，链接也附上</p><p><a href="https://www.bilibili.com/video/BV1G4411c7N4">尚硅谷Java设计模式（图解+框架源码剖析）_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Qx411o7tN">Java设计模式-Mr.high_哔哩哔哩_bilibili</a></p><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/115980889">永不磨灭的设计模式（有这一篇真够了，拒绝标题党）_ShuSheng007的程序人生-CSDN博客</a></p><p><a href="http://c.biancheng.net/view/1317.html">软件设计模式概述 (biancheng.net)</a></p><h2 id="怎么学？"><a href="#怎么学？" class="headerlink" title="怎么学？"></a>怎么学？</h2><p>光看不练学不会，多敲多练多找源码体现，不得不说，比数据结构学起来可太轻松了，看看spring源码中哪里用到了，看人家大佬是如何实践落地的，自己尝试在业务中加以应用</p><p>重要的是不对某一设计模式钻牛角尖，它为什么不按照官方的这几大角色来实现，这怎么少一种角色？设计模式本身就是一种思想，不要拘泥于实现</p><p>学完或许懵，因为需要大量实践去丰富所学到的理论，要相信1w小时定律</p><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>这 6 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。（有的也说7种，都可以吧，不要吹毛求疵，放弃本质）实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。也是所有设计模式共同的优点</p><table><thead><tr><th>设计原则</th><th>归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>好维护</td></tr><tr><td>单一职责</td><td>一个类只干一件事，实现类要单一</td><td>提升可读性</td></tr><tr><td>里氏替换</td><td>不要重写父类的方法</td><td>防止继承泛滥</td></tr><tr><td>迪米特法则</td><td>最少知道，对象之间少建立联系</td><td>解耦</td></tr><tr><td>接口隔离</td><td>一个接口只干一件事，接口要精简单一</td><td>高内聚，低耦合</td></tr><tr><td>依赖倒置</td><td>高层不应该依赖低层，要面向接口编程</td><td>利于结构升级</td></tr></tbody></table><p><strong>单一职责（常用）</strong></p><p>一个类应该只负责一个功能。比如userDAO只负责用户的相关功能</p><p><strong>开闭原则（常用）</strong></p><p>对扩展开放，对修改关闭。我们在添加功能时不应该修改源代码，而是通过扩展类的方式增加功能</p><p><strong>迪米特法则（常用）</strong></p><p>也叫最少知道原则，指一个对象对其他类来说知道的越少越好，类之间不要有过多的耦合关系，陌生类不要作为局部变量出现。被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。</p><p><strong>里氏替换</strong></p><p>所有引用父类的地方必须能透明地使用其子类的对象。也就是说在子类中尽量不要重写和重载父类的方法。</p><p><strong>接口隔离</strong></p><p>尽可能的拆分接口。一个类对另一个类的依赖应该建立在最小的接口上。</p><p><strong>依赖倒置</strong></p><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><h2 id="设计模式种类"><a href="#设计模式种类" class="headerlink" title="设计模式种类"></a>设计模式种类</h2><p>分为创建型（5种）、结构型（7种）、行为型模式（11种）</p><table><thead><tr><th>设计模式</th><th>归纳</th><th>案例</th></tr></thead><tbody><tr><td>单例模式</td><td>世界上没有两片完全相同的树叶</td><td>CEO</td></tr><tr><td>原型模式</td><td>72变</td><td>克隆</td></tr><tr><td>建造者模式</td><td>属性自由搭配</td><td>装修</td></tr><tr><td>代理模式</td><td>自身能力不足找别人帮忙</td><td>代言人</td></tr><tr><td>外观模式</td><td>统一接口封装</td><td>前台</td></tr><tr><td>装饰器模式</td><td>灵活，套娃</td><td>俄罗斯套娃</td></tr><tr><td>享元模式</td><td>共享资源</td><td>连接池及各种池</td></tr><tr><td>组合模式</td><td>整体-部分</td><td>组织架构</td></tr><tr><td>适配器模式</td><td>兼容转换</td><td>电源适配器</td></tr><tr><td>桥接模式</td><td>两个维度分离开</td><td>桥</td></tr><tr><td>模板模式</td><td>定义一套模板，根据需要实现模板中的操作</td><td>写周报</td></tr><tr><td>策略模式</td><td>用户进行选择方案</td><td>出行方式</td></tr><tr><td>责任链模式</td><td>流水线传送带，各级互不关联</td><td>流水线，审批流</td></tr><tr><td>迭代器模式</td><td>数据访问方式</td><td>遍历集合</td></tr><tr><td>命令模式</td><td>运筹帷幄之中，决胜千里之外</td><td>遥控器</td></tr><tr><td>状态模式</td><td>根据不同的状态做出不同的行为</td><td>线程生命周期</td></tr><tr><td>备忘录模式</td><td>失足不成千古恨，人生还能重来</td><td>游戏存档</td></tr><tr><td>中介者模式</td><td>我只和你一人联系</td><td>房屋中介</td></tr><tr><td>解释器模式</td><td>实现特定语法解析</td><td>编译器，密码本</td></tr><tr><td>观察者模式</td><td>有新消息通知我</td><td>公众号</td></tr><tr><td>访问者模式</td><td>横看成岭侧成峰，远近高低各不同</td><td>压榨打工人</td></tr><tr><td>工厂模式</td><td>封装细节，生产更高效</td><td>工厂</td></tr></tbody></table><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>关心么样去创建对象，然后与使用者分离</p><p>1、单例模式</p><p>指某个类中<strong>只存在一个对象实例</strong>。sprng中bean默认都是单例模式</p><p>空降地址：<a href="https://leidl.top/post/f1601c3e">钟sir：看完就明白之单例模式</a></p><p>2、原型模式（了解）</p><p>clone()方法，spring的bean中也提供了prototype的常见方式</p><p>空降地址：<a href="https://leidl.top/post/91ad9ce3">钟sir：看完就明白之原型模式</a></p><p>3、工厂模式（包含工厂方法和抽象工厂，简单工厂不属于GOF的23种之内）</p><p>又分为简单工厂模式、工厂方法模式，抽象工厂模式。</p><p>在创建对象时不会暴露具体细节，而是通过一个接口来创建对象</p><p>空降地址：<a href="https://leidl.top/post/54788f73">钟sir：看完就明白之工厂模式</a></p><p>4、建造者模式（了解）</p><p>隐藏了复杂对象的创建过程，将一个复杂对象（属性多）赋值的问题</p><p>比如lombok中的@Builder注解</p><p>空降地址：<a href="https://leidl.top/post/fe816c3c">钟sir：看完就明白之建造者模式</a></p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>如何将类或对象按某种布局组成更大的结构</p><p>5、适配器模式</p><p>指多个对象类型转为一个对象类型然后去统一实现方法，比如常见的类包含adapter字样的，都用到了适配器模式，其中MVC最为经典，可以空降看分析</p><p>空降地址：<a href="https://leidl.top/post/f5c535ea">钟sir：看完就明白的适配器模式</a></p><p>6、桥接模式（了解）</p><p>应对两个及以上独立变化的维度，解决类爆炸的问题</p><p>空降地址：<a href="https://leidl.top/post/563268dc">钟sir：看完就明白的桥接模式</a></p><p>7、装饰者模式</p><p>又称套娃模式，在不改变源码的情况下，动态的给对象添加一些职责和功能</p><p>空降地址：<a href="https://leidl.top/post/a708a60d">钟sir：看完就明白的装饰者模式</a></p><p>8、外观模式（了解）</p><p>这也能叫设计模式？存在即合理，外观模式的思想确实频率用的很高。它对外提供统一的交互接口，隐藏内部的子系统调用。相当于一个总开关的角色</p><p>空降地址：<a href="https://leidl.top/post/f7de8aa8">钟sir：看完就明白的外观模式</a></p><p>9、组合模式（了解）</p><p>用来解决部分—整体的关系的一种设计模式，当程序结构中出现了<strong>类似树</strong>（部分—整体）一样的层级结构时，可以考虑使用组合模式</p><p>空降地址：<a href="https://leidl.top/post/df879792">钟sir：看完就明白的组合模式</a></p><p>10、代理模式</p><p>帮助别人干它的事情，除此之外还能另外的帮它作更多事情，比如常见的AOP切面编程，就很好的用到了代理模式</p><p>空降地址：<a href="https://leidl.top/post/7b510e10">钟sir：看完就明白的代理模式</a></p><p>11、享元模式（了解）</p><p>就是各类池，比如数据库连接池，缓冲池，常量池等，共同的目标就是减少内存的使用</p><p>空降地址：<a href="https://leidl.top/post/e19da94a">钟sir：看完就明白的享元模式</a></p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。是一个大的模式，包含11种模式</p><p>12、命令模式</p><p>家里的遥控器可以进行发布各种命令，而我不需要知道它是怎么做到的，我只关心它可以给我完成对应的功能，将请求者（me）与执行者（遥控程序）解耦</p><p>空降地址：<a href="https://leidl.top/post/78134e07">钟sir：看完就明白的命令模式</a></p><p>13、模（mu）板模式（了解）</p><p>日程写的周报千篇一律，只需要每周改吧改吧内容就好了，格式基本都不会变，这种场景下适合使用模板模式</p><p>空降地址：<a href="https://leidl.top/post/cf413e35">钟sir：看完就明白的模板模式</a></p><p>14、访问者模式（了解）</p><p>我愿称为没什么用的模式，不大能想到平时在什么地方使用，实战中在积累经验吧</p><p>空降地址：<a href="https://leidl.top/post/64b51ed9">钟sir：看完也不明白的访问者模式</a></p><p>15、备忘录模式（了解）</p><p>像平时的游戏存档类似，它可以记录对象在某一时刻的状态，当需要的时候可以快速回到当时的状态</p><p>空降地址：<a href="https://leidl.top/post/c3176455">看完就明白的备忘录模式)</a></p><p>16、迭代器模式（了解）</p><p>一般我们会用到Java类提供的Iterator来进行遍历，其中的思想就是迭代器的思想</p><p>空降地址：<a href="https://leidl.top/post/9055d217">看完就明白的迭代器模式</a></p><p>17、观察者模式</p><p>用过的一些监听器类，会监听你某个动作执行后，调用相关的一些行为。类似的，当一个对象状态发生改变时，依赖它的对象会得到通知并做出相应的行为</p><p>空降地址：<a href="https://leidl.top/post/9a246216">看完就明白的观察者模式</a></p><p>18、解释器模式（了解）</p><p>为编译器提供的一个设计模式，一般情况下用不到，用到的也不是一般人，涉及到了句子，文法，语法树等</p><p>空降地址：<a href="https://leidl.top/post/30cf0cd2">看完就明白的解释器模式</a></p><p>19、中介者模式（了解）</p><p>中介这个词应该很熟，买房需要中介，假期打工需要中介等等，你只需要和中介一人联系，剩下的中介去干，当然其他人也只需要联系中介，这样就进行了解耦</p><p>空降地址：<a href="https://leidl.top/post/d036071c">看完就明白的中介者模式</a></p><p>20、状态模式</p><p>最实用的地方就是用来消除if-else了，当一个对象状态改变的时候，其内部行为也随之改变</p><p>空降地址：<a href="https://leidl.top/post/8acb1976">看完就明白的状态模式</a></p><p>21、策略模式</p><p>是一个简单又开发常用的设计模式，当存在一题多解的情况时，可以使用策略模式使程序更加灵活</p><p>空降地址：<a href="https://leidl.top/post/72e3b671">看完就明白的策略模式</a></p><p>22、责任链模式</p><p>将一个对象传给下一个对象，然后一直传下去，直到该请求被响应。由于发起者只知道下一个是谁，而不清楚往后的处理者和处理细节，也实现了对象之间的解耦</p><p>空降地址：<a href="https://leidl.top/post/6208627e">钟sir：看完就明白的责任链模式</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，不为了设计而设计，一定要结合实际。可以帮助我们设计出更加优雅的代码结构。</p><p>所有模式学完，感觉有的很相似，有的也记不大住，使用了设计模式反而比不使用设计模式使程序看起来更加复杂，而不是更加简单。那是因为每篇文章的场景模拟都是无实际使用意义的示例代码，实际情况是程序非常复杂才需要使用到设计模式。</p><p>一个大型程序是不断迭代出来的，一开始肯定不长那样，日常接到一个需求也不要上来就想用什么设计模式，先实现功能，然后回头看看<br>公共代码都封装了吗？常用的方法能封装个工具类吗？<br>相同行为的一些对象是否能抽象一个接口？<br>是否将每个方法的功能都最小化了？<br>是每个类只干一件事情，写程序时候的每一步考虑，其实就是设计模式的思想，我们程序员做的，都是尽量的使工程做到<strong>高内聚，低耦合</strong>。这也是我们学习设计模式的初衷！</p><p>受之设计模式，用之设计模式</p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈前后端分离</title>
      <link href="/post/de3bac1b.html"/>
      <url>/post/de3bac1b.html</url>
      
        <content type="html"><![CDATA[<p>前后端分离，被网上抄的如火如荼。但真的有网上吹的那么神吗？还是为了追新而追新，为了分离而分离？事实上，我开发过的项目并没有感觉到给我带来了多少便利。总之，<strong>前后端分离，人不分离</strong>。分离后前端对之前的要求更高了，只会前端三剑客是远远不够的。这就有了学习成本，还得处理耦合，跨域什么的，所以让我感觉到并不是那么便利。</p><p>一提到前后端分离，脱口而出的就是一些技术，比如spring，vue，react，node，有了它们我们才可以去进行前后端分离。但是仔细想想，是技术导致分离吗，还是需要分离才有了技术。<strong>显然它并不是一个先鸡后蛋的哲学问题</strong>。</p><h2 id="万恶之源jsp"><a href="#万恶之源jsp" class="headerlink" title="万恶之源jsp"></a><strong>万恶之源jsp</strong></h2><p>遥想当年，我们小团队主要是后端为主，作为项目组的攻坚核心力量，也在干着前端的活。当时也有专门的前端，但不多，也叫“切图仔”，主要帮助后端搜集一些模板和处理一些图片资源。当时前端要求不高，web化趋势也不明显，jsp就好似其汽车中五菱宏光，发挥着不可估量的作用。后端也被奉为一个有技术含量的岗位。但从2020年初开始，甲方逐渐变态，需要前端展示的东西也复杂起来，jsp弊端也逐渐放大，模板套模板，东拼西凑，没有规范，导致开发人员经常扯皮。从项目管理的角度看，这种开发模式非常影响项目开发效率，怎么办？那就<strong>解耦</strong>。“高内聚，低耦合”果然是永远滴神。所以前端越来越被重视，市场缺口也越来越大。前端的责任逐渐从后端人员身上拿掉，逐渐形成了一个单独的岗位及责任领域，前端也开始逐渐像后端一样开始工程化，模块化、项目化。</p><h2 id="大人时代变了"><a href="#大人时代变了" class="headerlink" title="大人时代变了"></a><strong>大人时代变了</strong></h2><p>我认为的分离应该是<strong>互不影响</strong>的，<strong>耦合极少</strong>的（只需要沟通好接口规范就可以）。站在本身做后端的角度，我用Java也好，PHP也罢，不用管我怎么实现的，最终给前端的只是一串协商好的接口数据，也可以给多个类型前端去用，比如web，手机网页，小程序等等。一次开发，处处使用。站在前端的角度来看，我需要的数据完全可以去从mock服务器去拿，不能傻呵呵的等你后端给我数据。不存在谁等谁的问题，拒绝扯皮，以缩短开发周期。</p><h2 id="优雅的分离"><a href="#优雅的分离" class="headerlink" title="优雅的分离"></a><strong>优雅的分离</strong></h2><p>如今的前后端都已经成熟，都可以单独的进行工程化开发。前后端分离绝不是仅仅项目单独开发，而是灌输于整个项目周期。</p><p>一个通常的项目开发通常有四个阶段，其实在《软件工程》不止四步，但就不空谈兵书了，不能深受八股毒害。只说关键部分。分别是设计、开发、测试、部署。</p><p><strong>设计阶段</strong>：设计包括系统设计（架构设计）和接口设计。包括不限于数据库、中间件、缓存、尤其要考虑性能、容量、可维护性这些东西，前后端都一样。而其中的接口设计就显得十分重要，它是联系前后端的关键部分，包括不限于请求方式，数据类型，数据格式。一个好的接口设计可以很好的避免前后端人员的撕b。</p><p><strong>开发阶段</strong>：各自开发，互不影响，尽量减少耦合。就如前面说的后端一次开发，到处使用，前端不用看后端眼色，自己模拟数据进行独立开发。</p><p><strong>测试阶段</strong>：前端本身作为一套完整的系统，自身可以进行页面的跳转，输入，展示，响应等测试。后端除了进行数据接口测试，还有权限、异常、一致性等问题的一些测试。</p><p><strong>部署阶段</strong>：独立可部署。我直接部署都是前端用webpack打包好，放后端项目的static目录下，还得重写路径，解决跨域，总觉得哪里怪怪的，这分离了个寂寞，后来才学会分别部署。前端使用nginx就可以单独部署，顺便解决了跨域问题。后端的话用tomcat。Jenkins持续发布。</p><h2 id="到底该不该做"><a href="#到底该不该做" class="headerlink" title="到底该不该做"></a><strong>到底该不该做</strong></h2><p>说了一大堆，做还是不做。前后端分离终究还是一个<strong>工程化考量</strong>和<strong>项目管理</strong>的问题。而不是单纯的技术问题。需要考虑成本、人力、开发，工具，部署等等方面。处理不善只会带来麻烦，而不是便利。</p><p>说的浅显点，前后端分离肯定需要扩招人手，成本能接受吗？能接受多少？分离不彻底带来的风险能承受吗？彻不彻底与招到的人有关，与带头的项目经理有关。出现问题就会延期，多出的成本问题都是损失。</p><p>但前后端分离带来的好处还是很多的</p><p>1、站在企业的角度。开发一套，到处使用，<strong>初期费钱，后期赚钱</strong></p><p>2、站在开发的角度。前端解放出来，开发更加灵活，可以开发更为复杂的业务，例如一些页面交互效果，数据处理。后端终于可以甩开膀子干三高了（高性能、高可用、高并发）。一句话：<strong>提高开发效率</strong></p><p>3、站在用户的角度。<strong>用户体验提升</strong>，tomcat终于不用加载静态资源了，减少负载压力。前端按路由配置可以按需加载。交互体验必定提升。客户满意的嗷嗷叫</p><p>4、站在维护的角度。<strong>更好维护</strong>了，不容易甩锅的现象。分工明确，出现问题可以快速定位。兼容性问题，跳转问题找前端，数据出错，校验问题找后端</p><p>所以可以粗略认为：<strong>大项目分，小项目不分。</strong></p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人见解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之路</title>
      <link href="/post/4a1111be.html"/>
      <url>/post/4a1111be.html</url>
      
        <content type="html"><![CDATA[<p>《数据结构与算法》是大学的必修教材。大学专业课我学的马马虎虎，期末也就85左右，但从学完到实习到转正一点没用过。在加上大学讲的也比较浅，现在也忘的差不多了。黄金时间都在大学，现在时间都得挤。现在回味起来：<strong>大学不知算法好，错把妹子当成宝</strong>。在我重温的过程中发现它并不是难的问题，而是能否把它坚持下去的问题。现开设此贴，以表决心！</p><p><img src="https://pic4.zhimg.com/v2-8bc3e2307487de5db40061570b147997_b.png" alt="img"></p><h2 id="给我一万个理由"><a href="#给我一万个理由" class="headerlink" title="给我一万个理由"></a>给我一万个理由</h2><p>除了算法工程师之外， 基本不会在工作中会用到，最直接的理由就是为了面试，除此之外</p><p>1、<strong>这将会是一条强者之路</strong>。拒绝拧螺丝，拒绝面向API编程</p><p><img src="https://pic2.zhimg.com/v2-c22d267a2873056d4857d9b08d74e481_b.png" alt="img"></p><p>2、<strong>造轮子必备</strong>。某天公司让你优化数据库或者框架，甚至想让你设计数据库和框架，你能担当此重任吗？有人表示，扯的远了，我等泛泛之辈也敢班门弄斧？还有人表示，目前市面轮子这么多，能直接用为什么要造，你能有人家造的好？</p><p>首先第一点，<strong>不要否定未来的自己</strong>。谁都是从菜鸟过来的，不要给自己设限，不要放纵自己。一年经验用三年，我是不能接受。第二点，如果只是调用API的工具人，市场竞争力在哪？公司怎么敢重用你？就算轮子造不好，也要有这种能力。有些东西，只有自己有了，才有资格说有没有用。</p><p>3、<strong>门槛变高</strong>。做IT这行技术在突飞猛进，要求也越来越高。追新不靠谱，但底层原理是通用的。数据结构与算法，计算机组成原理，计算机与网络等等。以2021的角度看hibernate可以不学，直接梭哈spring。指不定之后spring也不学了，但这些底层原理始终是基石。所谓基础不牢，地动山摇。除非以后计算机不在使用冯诺依曼结构，否则这些基石永远不会过时</p><p>4、<strong>进大厂必备</strong>。大厂对基础与算法能力是相当看重的，所以想接触更牛b的人，这是一门必修课</p><h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划"></a>学习规划</h2><p><a href="https://www.bilibili.com/video/BV1E4411H73v">b站看视频</a> +《算法第四版》–&gt;《剑指offer》—&gt;刷leetcode（看厂）</p><p>b站这个视频我看下来还是挺不错的，但只能当个入门，到B树都讲一点点，也不讲实现，红黑树压根不讲，都得自己去看，师傅领进门，修行在个人。听个算法的思路，然后自己lu代码，最后与之比较，期间穿插看《算法第四版》（OS：这本书抱着啃我是不行，当个补充还可以，又厚又不说人话，不过权威就是了）</p><p><strong>修炼期间踩的坑：</strong></p><p>1、我用100行，人家用10行，自我安慰，其实还好，起码有门。有的就过分了，有思路也不会写。后来寻思也挺正常</p><p>2、头铁，不服输，不会写就硬憋。看着我一根跟80的头发掉下来，依然不为所动。后来寻思没有必要。重要的是不要cv，不要看着敲（高级版cv），思考的时间占大头。</p><p>3、走火入魔。记得树的那块儿，学魔怔了，打算手写红黑树，在树节点删除那块是怎么也整不明白，网上也大多都是讲原理的，没代码。弄了几天，后来我也没弄出来，人麻了。最后还得找小姐姐诉苦</p><p>三个月后，基础篇终于弄完了，剩下的也就是刷题了</p><p>是什么让我坚持了下来？有一半是兴趣，另一半是贫穷</p><p><img src="https://pic2.zhimg.com/v2-a6d7e7af4c044dcb2ac21a858e770ec1_b.png" alt="img"></p><h2 id="怎么去学"><a href="#怎么去学" class="headerlink" title="怎么去学"></a>怎么去学</h2><p>看视频+看算法书+自己总结</p><p>学习算法不是一蹴而就的，重要的是拥有这种思想并加以转化</p><p>反正是学一遍，不要吝啬你宝贵的时间，千万不要图快，看完≠学会</p><p>快餐式学习，学得快，忘得更快，还不如打王者上两颗星实在</p><p>重要的是方法，不是死磕。最后还有<strong>最最重要的</strong>就是<strong>坚持！！！</strong>没有这两个字，什么都白搭。</p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><p>算法—&gt;前置技能—&gt;数据结构</p><p>数据结构—&gt;前置技能—&gt;若干</p><p>若干包括</p><p>1、掌握一门机器语言（不然怎么写代码，推荐但不局限于python，Java）</p><p>2、线性代数、离散数学</p><p>当然，科班的除外（自带buff）</p><h2 id="随手小记"><a href="#随手小记" class="headerlink" title="随手小记"></a>随手小记</h2><p>除了原有的内容，还有自己的思路，图解，代码用Java实现</p><p><a href="https://leidl.top/post/b6c47025">钟sir：数据结构之队列</a></p><p><a href="https://leidl.top/post/1f4ac2fb">钟sir：数据结构之栈</a></p><p><a href="https://leidl.top/post/f9f5e0c2">钟sir：程序员眼中的《盗梦空间》</a></p><p><a href="https://leidl.top/post/8ff08e27">钟sir：八大经典排序图解（看完必会）</a></p><p><a href="https://leidl.top/post/33cb1151">钟sir：数据结构之查找</a></p><p><a href="https://leidl.top/post/7b216a3b">钟sir：数据结构之树</a></p><p><a href="https://leidl.top/post/ee040603">钟sir：数据结构之图</a></p><p><a href="https://leidl.top/post/f79807ee">钟sir：常用算法归类</a></p><p>剑指offer（能指，只能指一点点）</p><p><img src="https://pic4.zhimg.com/v2-82c72c56c95a234dc7256a8575ac18bf_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大经典排序图解</title>
      <link href="/post/8ff08e27.html"/>
      <url>/post/8ff08e27.html</url>
      
        <content type="html"><![CDATA[<ol><li>排序的种类</li><li>时间频度和特点</li><li>时间复杂度</li><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>快速排序</li><li>归并排序</li><li>基数排序</li><li>堆排序</li></ol><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src">leidl97/algorithm-src</a></p><h2 id="排序的种类"><a href="#排序的种类" class="headerlink" title="排序的种类"></a><strong>排序的种类</strong></h2><p>排序分为<strong>内部排序</strong>和<strong>外部排序</strong></p><p>一般为内部排序，可以划分为8大排序</p><p>插入排序：直接插入 | 希尔排序</p><p>选择排序：简单选择 | 堆排序</p><p>交换排序：冒泡排序 | 快速排序</p><p>归并排序（分治算法）</p><p>基数排序（桶排序）</p><h2 id="时间频度和特点"><a href="#时间频度和特点" class="headerlink" title="时间频度和特点"></a><strong>时间频度和特点</strong></h2><p>1、常数项可以忽略</p><p>2、低次方项可以忽略</p><p>3、次方项的系数可以忽略</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><p>1、一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大的时候，T(n) / f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数，记作T(n) = O(f(n))， O(f(n))称为算法的渐进时间复杂度，简称时间复杂度</p><p>2、T(n)不同，但时间复杂度可能相同</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a><strong>计算方法</strong></h3><p>用常数1表示运行中所有加法常数</p><p>只保留最高阶项</p><p>去掉最高阶的系数</p><h3 id="常用的时间复杂度"><a href="#常用的时间复杂度" class="headerlink" title="常用的时间复杂度"></a><strong>常用的时间复杂度</strong></h3><p>由小到大</p><p>常数阶O(1)：没有循环等复杂结构 </p><p>对数阶O(log2n)：if（i &lt; n）一直循环 i = i * 2，n多大执行log2n遍，也就是说2^次数=n，次数=log2n</p><p>线性阶O(n)：i++或者一层for循环，都是一个意思，n多大执行多少遍</p><p>线性对数阶O(nlog2n)：for循环中套了一个对数阶</p><p>平方阶O(n^2)：两层for循环</p><p>立方阶O(n^3)：三层for循环</p><p>k次方阶O(n^k)：n层for循环</p><p>指数阶O(2^n)：</p><p><img src="https://pic1.zhimg.com/v2-657997bc3a2bfc3325979f884533b5e0_b.png" alt="img"></p><p>图片来源于网络</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h2><p>思想：两个for循环，比数组大小-1次，每次比较数组大小-1次，从数组的第一个数字开始与下一个比较，如果第一个比第二个大则交换，否则第二个跟第三个比较</p><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只能用于判断趟数，省趟数，不省次数</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//排序n - 1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swag(a,j,j+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不重置只要交换过就没用了</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h2><p><strong>思想</strong></p><p>将数组中的数据遍历，先拿第一个进行比较，看后面的有没有比这更小的，有的话交换，没有就第二个进行比，依次比较，一共需要比数组大小-1次</p><p><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j+<span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">                <span class="comment">//交换两数</span></span><br><span class="line">                swag(a,i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h2><p>思想：将一个数组中的数据看作两个数组，有序和无序数组，由于第一个无需比较，所以需要比n-1次，将无需数组的第一个与有序数组的最后一个依次对比，并且插入合适的位置</p><p>一个for循环，一个while解决</p><p>初始为数组的第二个元素，依次与前面的比较，如果小的话一直比，直到遇到大的，则将找到的该元素后移，将比较的元素插入找到元素的后面，一轮结束，一共需要数组大小-1轮比较</p><p><img src="https://pic2.zhimg.com/v2-f87ad7d8ad54379dd81f02fcf9b91f49_b.gif" alt="img"></p><p>图片来源于网络</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> arr = a[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; arr &lt; a[index]) &#123;</span><br><span class="line">            a[index + <span class="number">1</span>] = a[index];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index+<span class="number">1</span>] = arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h2><p>如果存在一个数组为{2，3，4，5，6，1}那么使用插入排序会导致算法效率很慢</p><p>所以说是对插入排序的一种优化，它是分组对每组进行排序，又叫做缩小增量排序</p><p><img src="https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_b.gif" alt="img"></p><p>图片来源于网络</p><h3 id="为什么希尔排序效率更高"><a href="#为什么希尔排序效率更高" class="headerlink" title="为什么希尔排序效率更高"></a><strong>为什么希尔排序效率更高</strong></h3><p>由于开始时，步长的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期步长取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。就是判断的多了，移动的次数变少，所以速度变快。</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = a.length /<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="keyword">int</span> arr = a[index];</span><br><span class="line">                <span class="keyword">if</span> (arr &lt; a[index-gap]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (index - gap &gt;= <span class="number">0</span> &amp;&amp; arr &lt; a[index-gap]) &#123;</span><br><span class="line">                        count ++ ;</span><br><span class="line">                        a[index] = a[index-gap];</span><br><span class="line">                        index-=gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[index] = arr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;一共：&quot;</span>+count+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>同样的数组，用插入需要16次，用希尔只需要8次</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h2><p>特点就是递归，通过一个中间数，将该数的左右分别排序好，先找一个<strong>基准值</strong>，一般为数组大小/2，左边找到一个比基准值大的数，右边找到一个比基准值小的数，然后进行交换，算完之后左边的都为比基准值小的，右边都为比基准值大的，但不能保证他们是有序的，所以还需要对左右生成的数据进行二次排序</p><p><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = right;</span><br><span class="line">        <span class="keyword">int</span> center = arr[(l+r)/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; center) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; center) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换顺序，指针改变</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            l+=<span class="number">1</span>;</span><br><span class="line">            r-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l+=<span class="number">1</span>;</span><br><span class="line">            r-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            sort(left,r,arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            sort(l,right,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h2><p>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p><p><img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.gif" alt="img"></p><p>分而治之</p><p><img src="https://pic4.zhimg.com/v2-f76f2c1e90e9595c6a3438df4ca7553f_b.png" alt="img"></p><p>图片来源网络</p><p><img src="https://pic2.zhimg.com/v2-3da0360edf1790141836af963f980091_b.png" alt="img"></p><p>图片来源网络</p><p><strong>思想</strong></p><p>先将数组中的一组数据进行划分，最后去比较划分好的数据然后逐级比较合并</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左归并</span></span><br><span class="line">            sort(arr, left, mid);</span><br><span class="line">            <span class="comment">//右归并</span></span><br><span class="line">            sort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">//归并计算</span></span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        count ++ ;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">//左边小，将左边的数放入数组中</span></span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//右边小，将右边的数据放入数组中</span></span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将剩下的数据放入数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将temp的数据放入arr中</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; temp.length) &#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><img src="https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.gif" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-ec40263705b992bffa00b91721e2feeb_b.png" alt="img"></p><p>图片来源于网络</p><p><strong>难点</strong></p><p>1、取数组内最大数字的位数</p><p>2、求次方</p><p>3、求本次遍历应该取个位还是什么位，如何取</p><p>4、桶应该如何创建</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * size表示循环的次数，根据最大数的位数决定，n表示当前应该取哪一位数，n为1的时候表示取个位</span></span><br><span class="line"><span class="comment">         * n为10表示取百位，以此类推，每次遍历都创建一个length*10的桶，保证数据不会出错</span></span><br><span class="line"><span class="comment">         * 存的时候是按照行列存储的，但取得时候按照列行取（按照人的思维）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, n = <span class="number">1</span>; k &lt; size; k++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//创建一个二维数组用来表示放置的桶</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> gewei = temp / n % <span class="number">10</span>;</span><br><span class="line">            bucket[i][gewei] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (bucket[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    arr[t++] = bucket[j][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序（用顺序存储二叉树的思想进行排序）"><a href="#堆排序（用顺序存储二叉树的思想进行排序）" class="headerlink" title="堆排序（用顺序存储二叉树的思想进行排序）"></a><strong>堆排序（用顺序存储二叉树的思想进行排序）</strong></h2><p>相关概念</p><p>堆这种数据结构是一种排序算法，堆排序是一种选择排序，它的最坏最好，平均复杂度均未nlogn，为不稳定排序</p><p>大顶堆：每个结点的值都大于等于他的左右孩子结点的值，比如下图</p><p><img src="https://pic3.zhimg.com/v2-56f3f0fd4479e8dc2c3f34a747ffa9ca_b.png" alt="img"></p><p>小顶堆：相反，每个结点的值都小于等于他的左右孩子结点的值，比如下图</p><p><img src="https://pic4.zhimg.com/v2-218eb3b9377672a3fe7c8536666eaaf7_b.png" alt="img"></p><p><strong>大小是对于顶点来说的</strong>，一般大顶堆做升序，小顶堆做降序</p><p>堆排序思想</p><p>如果是升序，也就是从小到大排，那么就需要构建大顶堆，然后想根节点元素与最后一个叶子进行交换，重复除了已经筛选好的叶子节点这个过程</p><p>也可以说将数组按照树的思想进行排序。树只是一个逻辑上的概念</p><p>步骤，刚开始如下图</p><p><img src="https://pic4.zhimg.com/v2-b1ededd59da5160cb25ae2cd7f1b21bb_b.png" alt="img"></p><p>1、首先找到第一个非叶子节点，公式 a.length / 2 - 1，将叶子结点大的值进行交换</p><p><img src="https://pic3.zhimg.com/v2-e8944335c0e50e2157e05daca35bb4b2_b.png" alt="img"></p><p>2、然后在找到下一个非叶子节点重复1的操作</p><p><img src="https://pic1.zhimg.com/v2-0936d117e92d5cc08120dabf2d95f40c_b.png" alt="img"></p><p>3、排完在返回来进行之前左子树的排序，因为结构已经混乱（程序不用递归怎么回来的，在上一步已经做了遍历操作，可以看作23是一起的）</p><p><img src="https://pic3.zhimg.com/v2-50aabebb6e55fe7b904eceb374c704c2_b.png" alt="img"></p><p>4、最后形成一个大顶堆，将堆顶元素与最后一个叶子节点交换值，除去该值，继续重复上面的过程</p><p><img src="https://pic1.zhimg.com/v2-bc6023638f2c4df25eb179f7ccec1838_b.png" alt="img"></p><p>5、重新调整结构，继续构建大顶堆</p><p><img src="https://pic4.zhimg.com/v2-597ed7cbd8451e870fbbdbebd46779af_b.png" alt="img"></p><p>6、重复进行</p><p><img src="https://pic1.zhimg.com/v2-457e8284a31bebe020b3b692b6823264_b.png" alt="img"></p><p><strong>难点</strong></p><p>1、构建大顶堆 / 构建小堆顶</p><p>2、边界值判断</p><p>自己思路写出的代码如下，完了思考这个复杂度怎么都上n2了啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建大顶堆（升序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待处理的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 待处理非叶子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 待处理数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从该节点的索引下进行调整，将i节点之下构建为一个大顶堆</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt;= length; j = j * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//此时j为左子树</span></span><br><span class="line">                <span class="keyword">if</span> (j+<span class="number">1</span> &lt;= length &amp;&amp; a[j] &lt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//若左子树大于右子树，则挪动指针，指向右子树</span></span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">                    <span class="comment">//将大元素放置顶堆</span></span><br><span class="line">                    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> length = a.length - <span class="number">1</span>; length &gt; <span class="number">0</span>; length--) &#123;</span><br><span class="line">            heapSort(a, length / <span class="number">2</span> - <span class="number">1</span>, length);</span><br><span class="line">            <span class="comment">//将堆顶堆底元素互换</span></span><br><span class="line">            <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>] = a[length];</span><br><span class="line">            a[length] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进版（逻辑上更好理解了，老师的思路，但复杂度我觉得没有达到nlogn）</strong></p><p>1、先构建大顶堆，然后在进行堆顶元素的顺序调整，一个需要遍历数组个数-1次，剩下那个自动就是有序的，所以为for (int j = a.length; j &gt; 1; j–) {}</p><p>2、构建大顶堆思路，先用临时变量存入索引值，然后与子树进行比较大小，当指针确定所以节点子树位置后，与所以节点的值进行比较，比索引大则赋值，最后将原先索引的值放置子树节点位置</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = a.length; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将堆顶元素与堆底互换</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建大顶堆（升序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待处理的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 待处理非叶子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 待处理数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; length; k = <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; a[k] &lt; a[k+<span class="number">1</span>]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; temp) &#123;</span><br><span class="line">            a[i] = a[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前节点不大于索引节点，那么大顶堆已形成，因为是从下之上的</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/post/33cb1151.html"/>
      <url>/post/33cb1151.html</url>
      
        <content type="html"><![CDATA[<p>Java中常用的查找有</p><ul><li>线性查找</li><li>二分查找/折半查找</li><li>插值查找</li><li>斐波那契查找/黄金分割点查找</li></ul><p>都是比较简单的，除了斐波那契查找</p><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src">leidl97/algorithm-src</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h2><p><strong>思想</strong></p><p>必须为有序的，可以正序，也可以倒序</p><p><strong>每次切一半，找到返回找不到向左右继续查</strong></p><p>先按照给定数据的一半找起，如果目标值比mid大，则向右递归，反之，向左递归。</p><p>优化：可以查找重复数据，在找到元素之后，向左右依次进行比较，查找所有相同的元素</p><p>需要注意的是边界值问题 left必须为&lt;=而不是&lt;</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> act)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; act) &#123;</span><br><span class="line">            search(arr, left, mid, act);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; act) &#123;</span><br><span class="line">            search(arr,mid+<span class="number">1</span>, right, act);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到数据&quot;</span>);</span><br><span class="line">            list.add(arr[mid]);</span><br><span class="line">            <span class="keyword">int</span> i = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; arr.length) &#123;</span><br><span class="line">                <span class="keyword">while</span> (arr[i++] == arr[mid]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;找到数据&quot;</span>);</span><br><span class="line">                    list.add(arr[mid]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (arr[j--] == arr[mid]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;找到数据&quot;</span>);</span><br><span class="line">                    list.add(arr[mid]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到的数据有&quot;</span>+list.size()+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有该数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a><strong>插值查找</strong></h2><p>与二分查找类似，主要解决二分查找的部分情况下效率不高的问题，比如一个1到10的数组，找最边上的1或者10那么就需要查找很多次</p><p><strong>换言之就是找mid的方式改变，因数由1/2变为下面的，我也不知道怎么算出来的</strong></p><p><img src="https://pic3.zhimg.com/v2-a1967e3b780fd89f483e24ca46cdd872_b.png" alt="img"></p><p>那么，key就是你查找的目标值</p><p>将二分查找代码的这处替换即可</p><blockquote><p>int mid = left + (right - left) * (act - arr[left]) / (arr[right] - arr[left])</p></blockquote><p>所以说对于比较均匀的查找表来说，采用插值查找速度较快</p><p>不均匀的情况下，速度不一定比二分快</p><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a><strong>斐波那契查找</strong></h2><p>我称之为<strong>玄学查找</strong>，只是换了一个mid点，还贼难懂，快的话也没有哪一个能确切的说明，有的是说加减比乘除快，我没实际测试过，其实也就是换了个mid查找位置。</p><p><strong>这个查找需要花费点时间，其实也就是改变了中间节点mid的位置</strong></p><p>斐波那契查找也称为黄金分割法查找，将一条线段分割为两个部分，<strong>其中一部分比上全长之比等于另一部分与这部分之比</strong>，取其前三数字的近似值为0.618。</p><p>中间值不在由中间值或者插值得到，而是处于黄金分割点附近</p><p>F = { 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , . . . } </p><p><img src="https://pic4.zhimg.com/v2-d57ff5da52c62eff6e49a71af8ce147b_b.png" alt="img"></p><p><strong>难点</strong></p><p><strong>1、为什么需要拆分为f(k-1) -1 而不是 f(k-1)？</strong></p><p>需要找到黄金分割点，也就是mid点，可以按照此点作为判断的标志，方便进行向前向后进行查找，当然也可以另作定义，不过写起来会比较麻烦</p><p><img src="https://pic4.zhimg.com/v2-1c7e2006cb084079a86aa8b8ec8ed74b_b.png" alt="img"></p><p>花时间的点</p><p><strong>2、为什么向前查找是k-1，向后查找是k-2</strong></p><p><img src="https://pic1.zhimg.com/v2-d1ae773072cd7b38251a0470f935498c_b.png" alt="img"></p><p>花时间的点</p><p><strong>为什么斐波那契查找更有效率？</strong></p><p>二分法采用的是除法，而这是加减法</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">        sort(a,<span class="number">1234</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;1,1,2,3,5,8,13,21&#125;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        fib[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; fib.length; i++) &#123;</span><br><span class="line">            fib[i] = fib[i-<span class="number">1</span>] + fib[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> act)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//fib下标k</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;<span class="comment">//黄金分割点</span></span><br><span class="line">        <span class="keyword">int</span>[] f = fib();<span class="comment">//拿到斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取到黄金分割点，数列长度大于数组长度且最接近的数组值</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//f[k]的值可能大于数组长度，所以需要扩容。原数组的长度要接近斐波那契的值</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(arr,f[k]-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将temp为0的位置填充</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = arr[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环查找</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + f[k-<span class="number">1</span>] - <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span> (act &lt; temp[mid]) &#123;</span><br><span class="line">                <span class="comment">//向左查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k--，全部 = 前面 + 后面，前面有F[K-1]个元素，可以继续拆分为f[k-2] + f[k-3]，在f[k-1]的前面继续查找</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(act &gt; temp[mid])&#123;</span><br><span class="line">                <span class="comment">//向右查找</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k-2，全部 = 前面 + 后面，后面有f[k-2]个元素，将其拆分，需要在f[k-3]的位置进行查找，原来是k-1,现在是k-3所以要-2</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//找到,需要进一步判断下标，防止越界</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt; high) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;找到元素,下标为：&quot;</span>+mid);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;找到元素,下标为：&quot;</span>+high);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;未找到元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/post/ee040603.html"/>
      <url>/post/ee040603.html</url>
      
        <content type="html"><![CDATA[<ol><li>为什么需要图</li><li>图的相关概念</li><li>图的表示方式</li><li>DFS（深度优先遍历）</li><li>BFS（广度优先遍历）</li><li>最小生成树之prim算法</li><li>最小生成树之KrusKal算法</li><li>最短路径之Dijkstra算法</li><li>最短路径之Floyed算法</li></ol><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src.git">https://gitee.com/leidl97/algorithm-src.git</a></p><h2 id="一、为什么需要图？"><a href="#一、为什么需要图？" class="headerlink" title="一、为什么需要图？"></a><strong>一、为什么需要图？</strong></h2><p>处理多对多</p><h2 id="二、图的相关概念"><a href="#二、图的相关概念" class="headerlink" title="二、图的相关概念"></a><strong>二、图的相关概念</strong></h2><p>顶点</p><p>边</p><p>路径</p><p>无向图—顶点之间没有方向的图</p><p>有向图—顶点之间有方向的图</p><p>带权图—每个路径有值的图，也叫网</p><h3 id="三、图的表示方式"><a href="#三、图的表示方式" class="headerlink" title="三、图的表示方式"></a><strong>三、图的表示方式</strong></h3><p>二维数组和链表，也可以称为邻接矩阵和邻接表</p><p><img src="https://pic4.zhimg.com/v2-6707c1fdf7b97341be54d5bad122527b_b.png" alt="img"></p><p>可以看到0表示不是直接相连，有很多边都是不存在的，会造成空间上的一定损失</p><p>邻接表的话只关心存在的边，因此没有空间浪费，邻接表由数组+链表组成</p><p><img src="https://pic1.zhimg.com/v2-2c04f5e37ac97909f6c1c7d89712d5dc_b.png" alt="img"></p><h3 id="图的遍历方式有两种，一种是DFS（深度优先）另一种是BFS（广度优先）"><a href="#图的遍历方式有两种，一种是DFS（深度优先）另一种是BFS（广度优先）" class="headerlink" title="图的遍历方式有两种，一种是DFS（深度优先）另一种是BFS（广度优先）"></a>图的遍历方式有两种，一种是DFS（深度优先）另一种是BFS（广度优先）</h3><h3 id="四、DFS（深度优先遍历）"><a href="#四、DFS（深度优先遍历）" class="headerlink" title="四、DFS（深度优先遍历）"></a><strong>四、DFS（深度优先遍历）</strong></h3><p>depth first search</p><p>重点在于<strong>递归下去，回溯上来</strong></p><p><strong>难点</strong></p><p>1、判断遍历的条件</p><p>for循环遍历二维数组，如果为1且未使用过，则将下个顶点继续递归</p><p><strong>精髓</strong></p><p>1、用<strong>任意</strong>一个顶点来遍历所有的顶点（如果图是连通的）</p><p>2、每条边都会遍历两次，所以标记数组就起到了作用</p><p><strong>思路</strong>（如图所示）</p><p>首先创建一个图类，定义两个属性，一个二维数组和判断是否使用过的数组。给一个创建图的初始化方法。二维数组的行下标作为顶点。根据上图构建一个图，然后进行遍历。下图与我的代码思路是一致的，只不过我的实现方式更简单，图上是用了adj数组来记录，我是二维，所以我的遍历是有序的，图上是 0 –&gt; 2,代码实现是0 –&gt; 1最终都会遍历完毕</p><p>图</p><p><img src="https://pic3.zhimg.com/v2-f0889e3f263613f687b58014f1dcf346_b.png" alt="img"></p><p>二维数组遍历方式（假如从顶点0开始）</p><p><img src="https://pic1.zhimg.com/v2-cdcb71ee9f00d91a3c8b5a0496a54d58_b.png" alt="img"></p><p>不明白可以代码debug在参照图</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先输出当前行下标</span></span><br><span class="line">       System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">       <span class="comment">//将该顶点置为已使用状态</span></span><br><span class="line">       <span class="keyword">this</span>.used[i] = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.matrix[i].length; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[i][j] == <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.used[j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.dfs(j);</span><br><span class="line">               <span class="comment">//不能写return，否则不会回溯</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="五、广度优先遍历（BFS）"><a href="#五、广度优先遍历（BFS）" class="headerlink" title="五、广度优先遍历（BFS）"></a><strong>五、广度优先遍历（BFS）</strong></h2><p><strong>Breath First Search</strong></p><p>与DFS不同的是，BFS执着于一个顶点的遍历，看看这个顶点能有多少个边，如果没有，那么则使用遍历过的第一个顶点作为新顶点继续遍历，直到结果输出</p><p>实现不同的是，DFS是递归，BFS使用一个队列实现，不用递归</p><p><strong>思路图（主要是queue的使用）</strong></p><p><img src="https://pic4.zhimg.com/v2-c537181c85eb1b7aefee24d7ac2786eb_b.png" alt="img"></p><p>二维数组顺序（与上面同样的数组）</p><p><img src="https://pic3.zhimg.com/v2-33bc93fa3d3ee44f9c07a0ae0c3ec02e_b.png" alt="img"></p><p>需要注意的是如果图不连通，那么结果就不会全部遍历</p><p>方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(i);</span><br><span class="line">    <span class="keyword">this</span>.used[i] = <span class="keyword">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;bfs遍历结果为&quot;</span>);</span><br><span class="line">    System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//获得队列头下标</span></span><br><span class="line">        <span class="keyword">int</span> head = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.matrix[head].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[head][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.used[j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果结果为0并且没使用过，说明通过该顶点走不通，跳出循环，换队列中下个顶点继续</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果为0但使用过，说明该顶点已输出，则遍历下一位数</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果结果为1并且没有使用过，说明该顶点可以到达该边，输出并置为已使用</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.used[j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                queue.offer(j);</span><br><span class="line">                System.out.print(j + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.used[j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、最小生成树之prim算法"><a href="#六、最小生成树之prim算法" class="headerlink" title="六、最小生成树之prim算法"></a>六、最小生成树之prim算法</h2><p>prim，修路问题，实际上是求最小生成树的问题（Minimum Cost Spanning Tree）简称MST。</p><p>给定一个带权的无向连通图。如果选取并生成一棵树，使树上所有边的权总和为最小</p><p>算法主要有普利姆算法（prim）和克鲁斯卡尔算法（Kruskal）</p><p><strong>prim算法思想</strong></p><p>对于加一个加权无向图如果求出它的最小生成树，按照<strong>顶点</strong>的方式进行发起，给定一个图，假设如图所示，从顶点A生成</p><p><img src="https://pic2.zhimg.com/v2-584dcaea45e2592da28abcd757a22ce5_b.png" alt="img"></p><p>那么过程如下（使用过的边不在参与，下面有过程图）</p><p>1、与A顶点有关的边有AC,AB,AG，其中权值最小的边为AG（2）</p><p>2、&lt;A,G&gt;其中顶点集合有A和G，以他们为顶点的边有，AC,AB,GE,GF,GB,其中GB的权值最小（3）</p><p>3、顶点集合为&lt;A,G,B&gt;,以他们为顶点的边有AC,BD,GE,GF,其中GE权值最小（4）</p><p>4、顶点集合为&lt;A,G,B,E&gt;,以它们为顶点的边有AC,BD,GF,CE,EF，其中EF权值最小（5）</p><p>5、顶点集合为&lt;A,G,B,E,F&gt;同理，边有AC,CE,FD,BD,其中FD权值最小（4）</p><p>6、顶点集合为&lt;A,G,B,E,F,D&gt;边有AC,CE,其中权值最小的围殴AC(7)</p><p>最后最小生成树生成，权值为25，7个顶点，6条边</p><p><img src="https://pic2.zhimg.com/v2-1366e3c309b9d92d1957049e55057441_b.png" alt="img"></p><p><strong>难点</strong></p><p><strong>1、构建过程中需要判断是否构成了环，如何判断？</strong></p><p>如图所示在构建最小生成树的时候在第六步 AC的权是5小于AB的权7，很明显应该选择AC</p><p><strong>那么如何判断AB是非法的？</strong>（以下用0表示A。1表示B，以此类推）</p><p>首先是获得一个终点数组，方法由getEnd实现，也是该算法的精髓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入顶点，返回该顶点的终点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (end[i] != <span class="number">0</span>) &#123;</span><br><span class="line">           i = end[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>采用一个终点的判断方法，假设坐标i的终点与坐标j的终点是一样的，则构成了环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否构成了环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//比如边BG 传入值为1，6或者6，1都代表的是一条边，这里判断默认前顶点比后顶点的值小，只取1，6</span></span><br><span class="line">        <span class="comment">//所以当为6，1的情况时，应当做i,j值的调换</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            i = j;</span><br><span class="line">            j = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = getEnd(i,end);</span><br><span class="line">        <span class="keyword">int</span> n = getEnd(j,end);</span><br><span class="line">        <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">            <span class="comment">//构成了环</span></span><br><span class="line">            b = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则构建终点数组</span></span><br><span class="line">            end [m] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该判断同样适用下面的克鲁斯卡尔算法</p><p>稍后用克鲁斯卡尔算法来解释此终点的含义</p><p><strong>核心方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成方法，目标数组，起点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String,Integer&gt; <span class="title">cal</span><span class="params">(<span class="keyword">int</span>[][] act, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存权值</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//存备选边全部结果集</span></span><br><span class="line">        Map&lt;String,Integer&gt; allMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//存顶点</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//顶点集合加入一个起点值</span></span><br><span class="line">        list.add(start);</span><br><span class="line">        <span class="comment">//定义值</span></span><br><span class="line">        <span class="keyword">int</span> min = MAX,tempi = <span class="number">0</span>,tempj = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">while</span> (list.size() &lt; act.length) &#123;</span><br><span class="line">            <span class="comment">//获得此次生成的图的最小权值的边是哪条</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; act.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (act[i][j] != <span class="number">0</span> &amp;&amp; act[i][j] &lt; min &amp;&amp; !<span class="keyword">this</span>.isExist(i,j,allMap)) &#123;</span><br><span class="line">                        <span class="comment">//说明顶点处有边</span></span><br><span class="line">                        min = act[i][j];</span><br><span class="line">                        tempi = i;</span><br><span class="line">                        tempj = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断该备选边构建的图是否会构成环，不构成则加入结果集</span></span><br><span class="line">            <span class="keyword">if</span> (!isValid(tempi, tempj)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.put(tempi,tempj,min,map,list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//备选边如果构成了环不进行处理的话，会一直进行判断该备选边</span></span><br><span class="line">            allMap.put(tempi + <span class="string">&quot;:&quot;</span> + tempj,min);</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            tempi = <span class="number">0</span>;</span><br><span class="line">            tempj = <span class="number">0</span>;</span><br><span class="line">            min = MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果输出</strong></p><p><img src="https://pic1.zhimg.com/v2-7bb3adfac4f91d9888b64cb585d5685c_b.png" alt="img"></p><h2 id="七、最小生成树之KrusKal算法"><a href="#七、最小生成树之KrusKal算法" class="headerlink" title="七、最小生成树之KrusKal算法"></a>七、最小生成树之KrusKal算法</h2><p>同样的是一个求最小生成树的算法，不过prim是顶点，这个是<strong>边</strong></p><p><img src="https://pic2.zhimg.com/v2-dae31c02218541fb0f4ebcab5af6e189_b.png" alt="img"></p><p>构建过程如下</p><p><img src="https://pic2.zhimg.com/v2-e3a831fd41125a792cfbf8b9af873e51_b.png" alt="img"></p><p><strong>用终点的方式判断是否存在环的问题，如图在3-4的过程中，舍弃了权值更小的CE与CF选择了BF，如何做到？</strong></p><p>1、创建一个数组end来存储该终点。利用每一步来增加该数组的值</p><p>2、第一步选择EF边，E的终点是F</p><p>3、第二步选择CD边，C的终点是D</p><p>4、第三步选择DE边，D的终点是E，而E的终点是F，所以最终D的终点是F</p><p>5、第四步在判断CE边的时候，C的终点是D，而D的终点上一步得到F，所以C的终点是F,</p><p>E的终点通过第一步得到也是F，CE两点得到相同的终点，那么构成环，不选择该边</p><p>6、CF同理，C的终点为F，而F的终点之前没有，根据方法返回本身，也就是终点F，此时CF的终点也相同，也不选择该边</p><p>7、BF同理，B的终点之前没有返回本身B，F的终点为F，不同，故可以选择</p><p><strong>核心方法</strong>（很多可以用prim算法的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Map&lt;String,Integer&gt; <span class="title">cal</span><span class="params">(<span class="keyword">int</span>[][] act)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//最小生成树结果集合</span></span><br><span class="line">       Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">//备选边全部集合（包含可能构成环的）</span></span><br><span class="line">       Map&lt;String,Integer&gt; allMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> min = <span class="number">65535</span>,tempi = <span class="number">0</span>,tempj = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (map.size() &lt; act.length-<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; act.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; act.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = act[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (temp &gt; <span class="number">0</span> &amp;&amp; temp &lt; min &amp;&amp; !isExist(i, j, allMap)) &#123;</span><br><span class="line">                        tempi = i;</span><br><span class="line">                        tempj = j;</span><br><span class="line">                        min = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断该备选边构建的图是否会构成环，不构成则加入结果集</span></span><br><span class="line">           <span class="keyword">if</span> (!Prim.isValid(tempi, tempj)) &#123;</span><br><span class="line">               map.put(tempi + <span class="string">&quot;:&quot;</span> + tempj,min);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//备选边如果构成了环不进行处理的话，会一直进行判断该备选边</span></span><br><span class="line">           allMap.put(tempi + <span class="string">&quot;:&quot;</span> + tempj,min);</span><br><span class="line">           tempi = <span class="number">0</span>;</span><br><span class="line">           tempj = <span class="number">0</span>;</span><br><span class="line">           min = <span class="number">65535</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://pic2.zhimg.com/v2-c2a8c8fd150531c3742550cd1190350d_b.png" alt="img"></p><h2 id="八、最短路径之Dijkstra算法"><a href="#八、最短路径之Dijkstra算法" class="headerlink" title="八、最短路径之Dijkstra算法"></a>八、最短路径之Dijkstra算法</h2><p>迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点<strong>距离最近</strong>且<strong>未访问过</strong>的顶点的邻接节点，直到扩展到终点为止 — 百度百科</p><p>迪杰斯特拉算法又叫做单源最短路径算法。用于计算一个节点到其他所有节点的最短路径</p><p><strong>最短路径的性质</strong></p><p>路径是有向的（当然包含无向的，举例是拿无向图测试的，也可以拿有向图测试）</p><p>权重不一定表示距离—也可以表示花费、时间等</p><p>并不是所有顶点都是可达的—为了简化问题一般都是可达的（强连通）</p><p>负权重回事问题复杂，Dijkstra不善于解决负权重问题</p><p>最短路径不一定只有一条</p><p>很多人都认为Dijkstra是一种贪心的思想，但我更愿意归纳为<strong>动态规划</strong>的思想，原因在于不断更新来获取最优的值。</p><p><strong>举例</strong></p><p>如图求G到各个顶点的最短距离</p><p><img src="https://pic4.zhimg.com/v2-4886625f9b78c1fde1c8a6e376650fa7_b.png" alt="img"></p><p>第一步：构建dis距离数组，dis[6]为0（自己到自己为0），其余初始化为N（∞）</p><p><img src="https://pic3.zhimg.com/v2-168540db2259da8e479eec72fb40747a_b.png" alt="img"></p><p>第二步：构建queue队列，存放遍历的顶点。以G点遍历后更新dis</p><p><img src="https://pic2.zhimg.com/v2-ecb179401b4950233fa757826cca2fed_b.png" alt="img"></p><p>第三步：首先找到最近的边GA(2)，将A加入队列，在以A点进行遍历，找到B，C（G点遍历过）</p><p>AB=6 GAB=2+6=8 &lt; 现在的3不更新。AC=7 GAC=2+7=9 &lt; N更新dis</p><p><img src="https://pic1.zhimg.com/v2-a07a7d4c8c568dbed4723f574c1f7e18_b.png" alt="img"></p><p>第四步：现在G、A都遍历过了，找到离G最近的B，开始遍历B点，找到D，BD=9 那么GBD=3+9=12 &lt; N 更新dis</p><p><img src="https://pic2.zhimg.com/v2-eaefa0fb78ada3d10ba9703a22d814ad_b.png" alt="img"></p><p>第五步：同理，下一个是E，遍历E点，得到EC=8 GEC=4+8=12 &gt; 4不更新。EF=9 GEF = 4+9=13 &gt; 6不更新</p><p>第六步：下一个是F，得到FD=4 GFD=6+4=10 &lt; 12 dis更新</p><p><img src="https://pic4.zhimg.com/v2-46de1f2ce9eb09f604f7175bc652c6a7_b.png" alt="img"></p><p>第七步：下一个是C，A、E都遍历过了，找不到，跳过</p><p>第八步：最后是D，也全部遍历过了，也跳过，最后得到的dis表为，这个就是G到各个顶点的最短距离</p><p><img src="https://pic2.zhimg.com/v2-8b32dea8dbaa4735bb585bdc0fc1ef6d_b.png" alt="img"></p><p>可以看出迪杰斯特拉的思想就是<strong>不断遍历邻近节点来更新距离表</strong></p><p><strong>代码思路</strong></p><p>构建图，采用邻接矩阵的方式记录（用99表示∞）</p><p><img src="https://pic1.zhimg.com/v2-755d7c30663a94943656ef7fbfcc3a1c_b.png" alt="img"></p><p><strong>如何取到这些顶点的顺序？</strong></p><p>设置一个方法，每次获得dis表中最近的一次路径下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得下一个顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>[] dis,  <span class="keyword">int</span>[] used)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = N;</span><br><span class="line">    <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt; min) &#123;</span><br><span class="line">            min = dis[i];</span><br><span class="line">            result = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果得到G到遍历当前顶点的最优距离？</strong></p><p>顶点的当前值 = G到当前顶点的距离 + 当前顶点到遍历顶点的距离</p><p>比如GAC = GA + AC = 2 + 7 = 9</p><p><strong>如何进行遍历？</strong></p><p>用每次得到的顶点进行遍历，一共需要遍历n-1次，由于遍历之前初始化dis也算1次，所以方法中只需要遍历n-2次，以下为初始化dis的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得dis数组,n表示顶点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getDis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> dis[] = <span class="keyword">new</span> <span class="keyword">int</span>[act.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; dis.length; i++) &#123;</span><br><span class="line">        dis[i] = act[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用两个for循环搞定，第一层用来决定遍历的次数也就是n-2次，第二次用来写距离逻辑，getMin方法取到的顶点依次进行遍历更新dis数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用邻近顶点的方式遍历,n表示从哪个顶点遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] newCal(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//使用过的顶点，1代表已使用</span></span><br><span class="line">    <span class="keyword">int</span>[] used = <span class="keyword">new</span> <span class="keyword">int</span>[act.length];</span><br><span class="line">    used[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始化dis数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dis = getDis(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; act.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = getMin(dis, used);</span><br><span class="line">        <span class="comment">//遍历n-2次就可以了，初始化的时候遍历过一次，最后一次其余顶点都遍历过了没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; act.length; j++) &#123;</span><br><span class="line">            <span class="comment">//当前的路径值 = 遍历顶点到temp顶点的最优值（比如GA）+ temp到i顶点的值（比如AB）</span></span><br><span class="line">            <span class="keyword">int</span> len = dis[temp] + act[temp][j];</span><br><span class="line">            <span class="keyword">if</span> (used[j] == <span class="number">0</span> &amp;&amp; len &lt; dis[j])&#123;</span><br><span class="line">                <span class="comment">//如果比当前dis中的小，则更新</span></span><br><span class="line">                dis[j] = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将该顶点置为已使用</span></span><br><span class="line">        used[temp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下</strong></p><p><img src="https://pic3.zhimg.com/v2-3902549db808f3bac396140af18e6826_b.png" alt="img"></p><h2 id="最短路径之Floyed算法"><a href="#最短路径之Floyed算法" class="headerlink" title="最短路径之Floyed算法"></a>最短路径之Floyed算法</h2><p>求每个顶点到所有顶点的最短路径</p><p>这句话的意思为A到ABCDEFG的最短、B到ABCDEFG的最短</p><p>之前理解错了。。以为A经过所有点的最短，B经过所有点的最短，做完后发现不一样么</p><p>方向正确后，考虑怎么实现，其实我愿称之为Dijkstra的暴力破解法，Dijkstra巧妙的利用邻近点来依次遍历得到最新的值，floyed直接使用三个for循环来得到解决</p><p><strong>代码实现关键点</strong></p><p>1、直接用本身进行不断更新</p><p>返回的结果比如act[0][1]表示A到B的最短路径</p><p>2、利用<strong>中间顶点</strong>不断遍历，而不是起始点或终点</p><p>这个会导致第一层for循环的变量应该是中间顶点的坐标</p><p><img src="https://pic4.zhimg.com/v2-4886625f9b78c1fde1c8a6e376650fa7_b.png" alt="img"></p><p>如图AD的最短路径为A–G–F–D，中间节点有G、F，最短路径可能是A–G–D 或者是 A—F–D，但AF经过G点，而遍历从A–G遍历，所以AG会比AGF最优值取得更近，那么AD的最优值就是A–G–D了</p><p>方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span>[][] act)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; act.length; j++) &#123;</span><br><span class="line">        <span class="comment">//这层的j表示中间顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; act.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这层的i表示起始顶点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt; act.length; k++) &#123;</span><br><span class="line">                <span class="comment">//这层的k表示到达的顶点</span></span><br><span class="line">                <span class="comment">//距离 = 起始点到中间点的距离 + 中间点到终点的距离</span></span><br><span class="line">                <span class="keyword">int</span> len = act[i][j] + act[j][k];</span><br><span class="line">                <span class="comment">//如果比数组中的值小则进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (len &lt; act[i][k]) &#123;</span><br><span class="line">                    act[i][k] = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://pic2.zhimg.com/v2-2191b2118392c6e91f79dd47c4efd235_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/post/1f4ac2fb.html"/>
      <url>/post/1f4ac2fb.html</url>
      
        <content type="html"><![CDATA[<ol><li>栈的特点</li><li>栈的场景</li><li>栈的介绍</li><li>Java实现</li><li>用数组实现</li><li>用链表实现（含尾插法和头插法）</li><li>场景应用</li><li>栈的表达形式（前缀、中缀、后缀）</li></ol><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src">leidl97/algorithm-src</a></p><h2 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h2><p>LIFO（后入先出）</p><p>《算法》将它比喻为桌子上的文件，后放上去的先拿起来阅读</p><p><img src="https://pic4.zhimg.com/v2-97348f23798d935807f9222d1c896c2b_b.png" alt="img"></p><p>出自《算法第四版》第78页</p><h2 id="栈的场景"><a href="#栈的场景" class="headerlink" title="栈的场景"></a>栈的场景</h2><p>算术表达式求值，比如《算法第四版》所提到的Dijkstra的黄河算术表达式</p><p><img src="https://pic1.zhimg.com/v2-e44cab9e8a152c8ec3852ba137f39bb0_b.png" alt="img"></p><p>《算法第四版》第81页</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先入后出的一个有序列表</p><p>限制线性表中元素的插入和删除只能在同一端进行的特殊线性表。允许插入和删除的一端为变化的一端，成为栈顶（top），另一端为固定的一端成为栈底（bottom）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>可以用数组和链表的方式实现</p><h3 id="用数组实现"><a href="#用数组实现" class="headerlink" title="用数组实现"></a><strong>用数组实现</strong></h3><p>定义变量3个，大小，栈顶，栈本身</p><p>方法定义4个，入栈，出栈，判断栈满，判断栈空</p><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a><strong>Java实现</strong></h3><p><strong>属性定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈顶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> top;</span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] stack;</span><br><span class="line"><span class="comment">//栈的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.top = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法定义</strong></p><p>入栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.top++;</span><br><span class="line">    <span class="keyword">this</span>.stack[top] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="keyword">this</span>.stack[<span class="keyword">this</span>.top];</span><br><span class="line">    <span class="keyword">this</span>.stack[top] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.top--;</span><br><span class="line">    System.out.println(<span class="string">&quot;出栈成功：&quot;</span>+val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断栈满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top == <span class="keyword">this</span>.size - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断栈空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用链表方式实现"><a href="#用链表方式实现" class="headerlink" title="用链表方式实现"></a><strong>用链表方式实现</strong></h3><h3 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a><strong>Java实现</strong></h3><p>属性定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> MyLinkedListStack next;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyLinkedListStack</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyLinkedListStack cur = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        System.out.println(cur);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法（不推荐）"><a href="#尾插法（不推荐）" class="headerlink" title="尾插法（不推荐）"></a><strong>尾插法（不推荐）</strong></h3><p>逆向思维，反人类，需要分情况讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈---尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(MyLinkedListStack stack)</span> </span>&#123;</span><br><span class="line">    MyLinkedListStack cur = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈---尾插法</span></span><br><span class="line"><span class="comment">//分情况讨论，如果没有元素则提示栈空，如果只有一个元素则让该元素出栈，将该节点置为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出栈元素为：&quot;</span>+head.next);</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedListStack cur = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出栈元素为：&quot;</span>+cur.next);</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插法（推荐）"><a href="#头插法（推荐）" class="headerlink" title="头插法（推荐）"></a><strong>头插法（推荐）</strong></h3><p>简单，这里可见<strong>队列用尾插，栈用头插</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈---头插法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;出栈元素为：&quot;</span>+head.next);</span><br><span class="line">    head.next = head.next.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈---头插法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushHead</span><span class="params">(MyLinkedListStack stack)</span> </span>&#123;</span><br><span class="line">    stack.next = head.next;</span><br><span class="line">    head.next = stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a><strong>场景应用</strong></h2><p>用自定义栈来实现</p><p>给一个字符串表达式，输出最后计算结果</p><p>如：7*9-3+4/2+6-2</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a><strong>难点</strong></h3><p>①连续减法运算，需要考虑变号的情况</p><p>②数字为多位数运算情况</p><h3 id="代码实现（中缀表达式）"><a href="#代码实现（中缀表达式）" class="headerlink" title="代码实现（中缀表达式）"></a><strong>代码实现（中缀表达式）</strong></h3><p>获得字符优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字越大，优先级越高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> plusPriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> subPriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> multiply = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">            priority = Normal.multiply;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">            priority = Normal.multiply;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">            priority = Normal.plusPriority;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">            priority = Normal.subPriority;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            priority = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断两个字符的优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPriority</span><span class="params">(<span class="keyword">char</span> c,Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//c的优先级</span></span><br><span class="line">    <span class="keyword">int</span> cPriority = Normal.getPriority(c);</span><br><span class="line">    <span class="comment">//栈中元素的优先级</span></span><br><span class="line">    <span class="keyword">int</span> oPriority = Normal.getPriority((<span class="keyword">char</span>)o);</span><br><span class="line">    System.out.println(cPriority+<span class="string">&quot;:&quot;</span>+oPriority);</span><br><span class="line">    <span class="keyword">return</span> (cPriority-oPriority) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素出栈操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈计算操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">char</span> c, MyStack numStack, MyStack opreStack)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;出栈计算&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> num1 = (<span class="keyword">int</span>)numStack.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)numStack.pop();</span><br><span class="line">    <span class="keyword">char</span> c1 = (<span class="keyword">char</span>)opreStack.pop();</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c1 == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//后出来的操作之前出来的</span></span><br><span class="line">        result = num1 * num2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        result = num1 + num2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        result = num2 - num1;</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        result = num2 / num1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;暂不支持该运算符&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数字压入栈</span></span><br><span class="line">    numStack.push(result);</span><br><span class="line">    <span class="comment">//操作符压入栈</span></span><br><span class="line">    opreStack.push(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈内的最后运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈内最后运算,，最后只会剩下加减运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(MyStack numStack, MyStack opreStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = (<span class="keyword">int</span>)numStack.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)numStack.pop();</span><br><span class="line">    <span class="keyword">char</span> c1 = (<span class="keyword">char</span>)opreStack.pop();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (opreStack.top != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//表示里面还有值，那么就去判断是否为-号，若为减法，则需要进行变号运算</span></span><br><span class="line">        <span class="comment">//对现有运算符进行变号</span></span><br><span class="line">        <span class="keyword">if</span> (c1 == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            c1 = (<span class="keyword">char</span>)opreStack.stack[opreStack.top] == <span class="string">&#x27;-&#x27;</span> ? <span class="string">&#x27;-&#x27;</span> : c1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c1 = (<span class="keyword">char</span>)opreStack.stack[opreStack.top] == <span class="string">&#x27;-&#x27;</span> ? <span class="string">&#x27;+&#x27;</span> : c1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = c1 == <span class="string">&#x27;+&#x27;</span> ? num1 + num2 : num2 - num1;</span><br><span class="line">    numStack.push(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的计算方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line">    MyStack numStack = <span class="keyword">new</span> MyStack(array.length);</span><br><span class="line">    MyStack opreStack = <span class="keyword">new</span> MyStack(array.length);</span><br><span class="line">    <span class="keyword">int</span> isNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加入一个判断多位数的标志</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建一个存放多位数的数组,，默认最多十位数</span></span><br><span class="line">    <span class="keyword">int</span>[] duo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = array[j];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            isNum = <span class="number">1</span>;<span class="comment">//表示为数字</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//若不为数字，将对位数组进行处理，然后压入栈</span></span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">                    sum = sum + duo[count-i-<span class="number">1</span>]*((<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i));</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(sum);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (isNum) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">if</span> (opreStack.isEmpty())&#123;</span><br><span class="line">                    opreStack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isPriority(c,opreStack.stack[opreStack.top])) &#123;</span><br><span class="line">                    <span class="comment">//如果传入的比栈中的优先级高则直接压入栈</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;压入栈&quot;</span>);</span><br><span class="line">                    opreStack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则进行出栈计算操作</span></span><br><span class="line">                before(c,numStack,opreStack);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                duo[count] = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//如果是遍历的最后一个元素则直接压入栈</span></span><br><span class="line">                <span class="keyword">if</span> (j == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    numStack.push(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!opreStack.isEmpty()) &#123;</span><br><span class="line">        after(numStack, opreStack);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(numStack);</span><br><span class="line">    System.out.println(opreStack);</span><br><span class="line">    System.out.println(<span class="string">&quot;该字符串[&quot;</span>+str+<span class="string">&quot;]运算的结果为：&quot;</span>+numStack.stack[numStack.top]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的表达形式"><a href="#栈的表达形式" class="headerlink" title="栈的表达形式"></a>栈的表达形式</h2><p>分为前缀表达式（波兰表达式），中缀表达式，后缀表达式（逆波兰表达式）</p><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a><strong>前缀表达式</strong></h3><p>举例说明：（3+4）x5-6对应的前缀表达式为- x + 3456</p><p>前缀表达式计算机求值规则</p><p><strong>从右向左扫描</strong>，遇到数字时，将数字压入栈，遇到运算符的时候，弹出栈顶的两个数，用运算符对他们做相应的运算 （栈顶元素和次顶元素），并将结果入栈，重复上述过程直到扫描完，最后运算出的值即为前缀表达式的结果</p><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a><strong>中缀表达式</strong></h3><p>就是常见的运算表达式，比如（3+4）x5-6</p><p>人好理解，先+在x在-，但是计算机不好理解，还得进行判断优先级问题，往往会将中缀表达式转换为后缀表达式</p><h3 id="后缀表达式（重要）"><a href="#后缀表达式（重要）" class="headerlink" title="后缀表达式（重要）"></a><strong>后缀表达式（重要）</strong></h3><p>又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作符之后</p><p>比如（3+4）x5-6的后缀表达式为34+5x6-</p><p>与前缀不同的是后缀<strong>从左到右扫描</strong>，符合人类思维</p><p>计算机运算的时候应该为后缀表达式，但之前一直使用的是中缀表达式，所以需要先将中缀表达式转换为后缀表达式进行运算</p><h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a><strong>运算规则</strong></h3><p>将传入的队列一次遍历，遇到数字入栈，遇到运算符则将栈顶两个数字出栈，与运算符进行计算，将计算的结果入栈，最后栈中最后一个数字为运算结果。</p><h2 id="后缀转中缀"><a href="#后缀转中缀" class="headerlink" title="后缀转中缀"></a>后缀转中缀</h2><p>思路/规则</p><p>1、创建一个栈s1，用来存储运算符。一个队列s2，用来存放中间结果。</p><p>2、逐个扫描，如果栈为空，直接进入s1</p><p>3、如果为数字，则直接进入队列</p><p>4、如果为左括号，则直接入栈</p><p>5、如果为运算符，如果栈顶元素为运算符，那么比较优先级，若优先级小于等于栈顶元素，则将栈顶元素弹到队列中，否则直接入栈</p><p>6、如果为右括号，将栈中元素依次弹出，直到遇到左括号，最后将左括号弹出</p><p>7、输出队列s2，即为后缀表达式</p><p>使用代码验证如下中缀</p><p>中缀：1+(（2+3）x 4) - 5/ 对应的后缀1 2 3 + 4 * + 5 -  / 对应的结果16</p><p>完成后使用代码完成一个更复杂的运算，包含多位数，加减乘除，小括号</p><p><img src="https://pic2.zhimg.com/v2-8e1facd5bf3179d0427d47021c3241e5_b.png" alt="img"></p><p>上述表达式可以参照此图思路编写代码</p><h2 id="整体代码部分"><a href="#整体代码部分" class="headerlink" title="整体代码部分"></a>整体代码部分</h2><p>1、字符串转集合</p><p>2、集合转队列</p><p>3、队列进行运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenterToAfter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有多位数，加减乘除，小括号</span></span><br><span class="line">        String before = <span class="string">&quot;12+((2+3)*4)/4-5&quot;</span>;<span class="comment">//12, 2, 3, +, 4, *, 4, /, 5, -, +  / 12</span></span><br><span class="line">        Queue&lt;String&gt; queue = todo(before);</span><br><span class="line">        System.out.println(<span class="string">&quot;后缀转中缀的结果为：&quot;</span> + queue);</span><br><span class="line">        String result = afterCal(queue);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串表达式：【&quot;</span> + before + <span class="string">&quot;】运算的结果为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中缀转后缀的算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">todo</span><span class="params">(String before)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建栈s1</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="comment">//创建队列s2</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//第一步将传入的字符串转换为ArrayList</span></span><br><span class="line">        <span class="comment">//因为遍历起来好处理，处理多位数的情况</span></span><br><span class="line">        List&lt;String&gt; list = stringToList(before);</span><br><span class="line">        <span class="comment">//遍历，按照规则进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; list.size(); i++) &#123;</span><br><span class="line">            String cur = list.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//如果为数字，则直接入队列</span></span><br><span class="line">                queue.offer(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;(&quot;</span>.equals(cur))&#123;</span><br><span class="line">                <span class="comment">//如果为左括号，直接入栈</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//如果栈为空则直接入栈</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;)&quot;</span>.equals(cur)) &#123;</span><br><span class="line">                <span class="comment">//弹出栈中元素直到碰到左括号</span></span><br><span class="line">                <span class="keyword">while</span> (!stack.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    queue.offer(stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//非常重要！！！将左括号弹出栈，避免后续与运算符混合</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若栈顶元素不为左括号，则需要进行处理后入栈</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> beforePriority = getPriority(stack.peek());</span><br><span class="line">                    <span class="keyword">int</span> nowPriority = getPriority(cur);</span><br><span class="line">                    <span class="comment">//若新运算符的优先级高，则直接入栈，否则将栈顶元素弹出到队列后入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (nowPriority &lt;= beforePriority) &#123;</span><br><span class="line">                        queue.offer(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈中的剩余元素压入队列中</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            queue.offer(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回优先级，默认数字越大，优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s) || <span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s) || <span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;暂不支持该运算符：&quot;</span>+s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串转集合的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">stringToList</span><span class="params">(String before)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">char</span>[] cs = before.toCharArray();</span><br><span class="line">        String string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//判断上个是否为数字</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cs[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; cs[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//如果为数字，那么字符串相加</span></span><br><span class="line">                string += cs[i];</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == cs.length-<span class="number">1</span>) &#123;</span><br><span class="line">                    result.add(string);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="comment">//先将数字部分存入集合</span></span><br><span class="line">                    result.add(string);</span><br><span class="line">                    string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//那么不为数字，直接存入list</span></span><br><span class="line">                result.add(cs[i] + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后缀计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">afterCal</span><span class="params">(Queue&lt;String&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用来计算的栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="comment">//结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : param) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果为数字则直接入栈</span></span><br><span class="line">                stack.push(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//为运算符，进行计算后入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">                        result = num1 + num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">                        result = num1 - num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">                        result = num1 * num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">                        result = num1 / num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有该运算符&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(String.valueOf(result));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a><strong>效果截图</strong></h3><p><img src="https://pic3.zhimg.com/v2-72311138995ecdc0d69d1082605d0ea2_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/post/7b216a3b.html"/>
      <url>/post/7b216a3b.html</url>
      
        <content type="html"><![CDATA[<ol><li>为什么需要树这种数据结构</li><li>树的常用术语</li><li>树结构Java代码实现</li><li>前中后序遍历</li><li>赫夫曼部分</li><li>赫夫曼树</li><li>赫夫曼编码</li><li>赫夫曼加密文件</li><li>二叉树部分</li><li>顺序存储二叉树</li><li>线索化二叉树</li><li>二叉排序树</li><li>平衡二叉树</li><li>多叉树部分</li><li>B+树和B*树</li><li>红黑树</li></ol><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src">https://gitee.com/leidl97/algor</a></p><h2 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a><strong>为什么需要树这种数据结构</strong></h2><p><strong>因为树结构存入读取数据相较于其他数据结构更有效率！</strong></p><p>1、数组存储方式分析</p><p>优点：通过下标方式访问元素，速度快。对于有序数组，还可以使用二分查找来提高检索速度</p><p>缺点：如果要检索具体的某个值，或者插入会整体移动，效率降低</p><p>2、链式结构的分析</p><p>优点：插入和删除一个节点效率较快</p><p>缺点：进行检索时，效率仍然较低，需要从头节点进行遍历</p><p>3、树结构分析</p><p>提高存储，读取的效率，比如利用二叉树排序，既可以保证存储速度，也可以保证读取速度，修改、删除等同样</p><h2 id="树的常用术语"><a href="#树的常用术语" class="headerlink" title="树的常用术语"></a><strong>树的常用术语</strong></h2><ul><li>节点：一个圆圈表示一个节点</li><li>根节点：最上方的节点</li><li>父节点：谁指向它谁就是父节点</li><li>子节点：它指向谁就表示谁是子节点</li><li>叶子节点：最下面一层节点（没有子节点的节点）</li><li>权：表示节点的值</li></ul><p>二叉树，顾名思义就是两个叉，一个节点下最多有两个子节点</p><p><img src="https://pic3.zhimg.com/v2-9f330493d21704ef7096b300554c817a_b.png" alt="img"></p><p>如果所有二叉树的叶子节点都在最后一层，则我们成为满二叉树</p><p><img src="https://pic4.zhimg.com/v2-d5f2f252670ee4f475df5c992d346f63_b.png" alt="img"></p><p>如果最后一层左连续，且其他层都是满的，我们称之为完全二叉树，如图</p><p><img src="https://pic3.zhimg.com/v2-9e7718b8235bfcfdc00b82f10d7d4582_b.png" alt="img"></p><h2 id="树结构Java代码实现"><a href="#树结构Java代码实现" class="headerlink" title="树结构Java代码实现"></a><strong>树结构Java代码实现</strong></h2><p><strong>以二叉树为例</strong></p><p>主要属性：左节点，右节点，权</p><p>属性定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左子树</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">//右子树</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">    <span class="comment">//节点的权</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//初始化节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加，修改节点都是通过不断寻找，如果节点为空进行相应的操作</p><p>但无论是哪种树，删除操作都是最复杂的。后面会详细讨论</p><h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a><strong>前中后序遍历</strong></h2><p><strong>以父为准！</strong></p><p>前序遍历：<strong>父</strong>左右</p><p>中序遍历：左<strong>父</strong>右</p><p>后序遍历：左右<strong>父</strong></p><p>代码实现逻辑（<strong>递归思想</strong>）</p><p><strong>前序遍历</strong></p><p>1、先输出当前节点</p><p>2、向左节点遍历（如果节点不为空）</p><p>3、向右节点遍历（如果节点不为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTraversal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先输出当前节点</span></span><br><span class="line">    System.out.print(node.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="comment">//向左遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeftNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        beforeTraversal(node.getLeftNode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRightNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        beforeTraversal(node.getRightNode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><p>1、向左节点遍历（如果节点不为空）</p><p>2、先输出当前节点</p><p>3、向右节点遍历（如果节点不为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">centerTraversal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先找到最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeftNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        centerTraversal(node.getLeftNode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其次输出当前节点</span></span><br><span class="line">    System.out.print(node.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="comment">//最后向右进行遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRightNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        centerTraversal(node.getRightNode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><p>1、向左节点遍历（如果节点不为空）</p><p>2、向右节点遍历（如果节点不为空）</p><p>3、先输出当前节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTraversal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先找到最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeftNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        centerTraversal(node.getLeftNode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其次向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRightNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        centerTraversal(node.getRightNode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出节点</span></span><br><span class="line">    System.out.print(node.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种遍历进行查找，道理是一样的，重新构建方法，多传入一个目标值value，以前序遍历为准，则代码实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTraversalSearch</span><span class="params">(Node node, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (node.getValue() == value) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到该元素:&quot;</span>+value+<span class="string">&quot;，次数为:&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeftNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        beforeTraversalSearch(node.getLeftNode(),value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRightNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        beforeTraversalSearch(node.getRightNode(),value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赫夫曼树（wpl最小的树）"><a href="#赫夫曼树（wpl最小的树）" class="headerlink" title="赫夫曼树（wpl最小的树）"></a><strong>赫夫曼树（wpl最小的树）</strong></h2><p>介绍：给定n个权值为n个叶子结点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也叫赫夫曼树（HuffmanTree）</p><p><strong>情景模拟</strong>：给你一个数组，要求创建一颗赫夫曼树。比如{13，7，8，3，29，6，1}</p><p>步骤</p><p>1、先排序（这不是重点，怎么实现快怎么来）</p><p>{1，3，6，7，8，13，29}</p><p>2、根据前两个数值相加得到一个权值，在与后面进行比较</p><p>3、直到处理完所有的数字则构建出一颗赫夫曼树</p><p><img src="https://pic2.zhimg.com/v2-03573a5858f5fbca6875ee1d5e1df6fd_b.png" alt="img"></p><p>构建结果如图</p><p><strong>难点</strong></p><p>1、如何判断提供的值已经用完</p><p>用集合，每次排完之后都会删掉左右结点，然后添加父节点，当最后集合中元素数量为1时（集合大小总是先-2在+1，最后剩下的为相加的权值），即为消耗完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">huffmanBuild</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : a) &#123;</span><br><span class="line">        <span class="comment">//向集合加入node对象</span></span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">        Node rigtNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">        Node parent = <span class="keyword">new</span> Node(leftNode.getValue() + rigtNode.getValue());</span><br><span class="line">        <span class="comment">//构建一颗二叉树</span></span><br><span class="line">        parent.setLeftNode(leftNode);</span><br><span class="line">        parent.setRightNode(rigtNode);</span><br><span class="line">        nodes.remove(leftNode);</span><br><span class="line">        nodes.remove(rigtNode);</span><br><span class="line">        nodes.add(parent);</span><br><span class="line">        <span class="comment">//将现有的集合进行排序</span></span><br><span class="line">        Collections.sort(nodes, <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = <span class="keyword">new</span> Tree(nodes.get(<span class="number">0</span>));</span><br><span class="line">    tree.beforeTraversal(tree.getRoot());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a><strong>赫夫曼编码</strong></h2><p>1、属于一种编程算法</p><p>2、在电讯通信中的经典应用</p><p>3、可用于数据文件压缩，压缩率在20% — 90%之间</p><p>4、是可变字长编码（VLC）的一种，称之为最佳编码，是无损压缩</p><p><strong>怎么理解</strong></p><p>假如一串文本为：i like java，会转为ASCII码，在转为二进制，这叫做<strong>定长编码</strong></p><p>一般不会这么做，因为太长了，所以通信领域信息的处理方式为<strong>变长编码</strong></p><p>首先统计字符串中每个字母出现的个数，出现次数越多的，编码越小。但每个字符的编码不能是其他字符的前缀。比如a用1表示，b不能用10表示，这样机器在解码的时候扫描到1就无法进行解码，存在二义性。</p><p>第三种编码方式叫做<strong>赫夫曼编码</strong></p><p>把各个编码<strong>出现的次数称为权值</strong>，然后构建一颗赫夫曼树，规定向左的路径为0，向右路径为1，从根节点到目标结点的路径即为编码</p><p><img src="https://pic3.zhimg.com/v2-39538ac42161132e0d87a94c7c1f2076_b.png" alt="img"></p><p>如图所示，每个字母都会有一个自己的编码，不存在二义性</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a><strong>意义</strong></h3><p>对文本进行压缩</p><p>用程序实现赫夫曼树编码</p><p><strong>难点</strong></p><p>1、如何统计字符出现的次数</p><p>设一个集合，将遍历过的放进去</p><p>2、如何为每个字符设置计数器</p><p>设置一个hashmap用来统计</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h3><p>1、获取需要构成赫夫曼树的叶子结点</p><p>2、利用这些结点构建赫夫曼树</p><p>3、对赫夫曼树进行编码（涉及遍历递归）</p><p>4、对生成的编码集进行压缩（将二进制编码压缩为10进制字节组）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffManCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        List&lt;Byte&gt; encoding = encoding(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩前该文本长度为：&quot;</span>+s.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩前该文本长度为：&quot;</span>+encoding.size()+<span class="string">&quot;。压缩率为：&quot;</span>+ (Double.valueOf(s.length() - encoding.size()) / Double.valueOf(s.length()) * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将文本信息转为赫夫曼编码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Byte&gt; <span class="title">encoding</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = s.getBytes();</span><br><span class="line">        <span class="comment">//定义赫夫曼树结点</span></span><br><span class="line">        List&lt;HuffManTree&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义已经存在的字符集合</span></span><br><span class="line">        List&lt;Byte&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义已经存在的字符出现的次数集合</span></span><br><span class="line">        Map&lt;Byte,Integer&gt; flags = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建构建赫夫曼树所需的结点信息</span></span><br><span class="line">        nodeBuild(flags,bytes,nodes,bs);</span><br><span class="line">        <span class="comment">//利用这些结点构建赫夫曼树</span></span><br><span class="line">        HuffManTree huffManTree = huffmanBuild(nodes);</span><br><span class="line">        <span class="comment">//设置编码集</span></span><br><span class="line">        Map&lt;Byte,String&gt; results = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//进行编码</span></span><br><span class="line">        huffmanEncoding(huffManTree, results,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        results.forEach((k,v) -&gt; System.out.println(<span class="string">&quot;数据为：&quot;</span>+k+<span class="string">&quot;。对应的编码值为：&quot;</span>+v));</span><br><span class="line">        <span class="comment">//将字长进行压缩</span></span><br><span class="line">        <span class="keyword">return</span> zip(bs,results);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取需要构成赫夫曼树的叶子结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flags 计算次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 放入结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes 结果集中的结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bs 原始数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nodeBuild</span><span class="params">(Map&lt;Byte,Integer&gt; flags, List&lt;Byte&gt; bytes,List&lt;HuffManTree&gt; nodes, <span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bytes.contains(b)) &#123;</span><br><span class="line">                <span class="comment">//说明已经存在</span></span><br><span class="line">                flags.put(b, flags.get(b)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明第一次遍历到</span></span><br><span class="line">            flags.put(b, <span class="number">1</span>);</span><br><span class="line">            bytes.add(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flags.forEach((k,v) -&gt; nodes.add(<span class="keyword">new</span> HuffManTree(k,v)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Byte&gt; <span class="title">zip</span><span class="params">(<span class="keyword">byte</span>[] bs, Map&lt;Byte,String&gt; results)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//替换原有编码</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//生成新编码</span></span><br><span class="line">        List&lt;Byte&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.print(<span class="string">&quot;原始数据为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bs) &#123;</span><br><span class="line">            System.out.print(b + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将原始byte数组的值替换为对应的编码</span></span><br><span class="line">        <span class="keyword">for</span> (Byte b : bs) &#123;</span><br><span class="line">            sb.append(results.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); i+=<span class="number">8</span>) &#123;</span><br><span class="line">            s = i+<span class="number">8</span> &lt; sb.length() ? sb.substring(i,i+<span class="number">8</span>) : sb.substring(i,sb.length());</span><br><span class="line">            <span class="keyword">byte</span> a = (<span class="keyword">byte</span>)Integer.parseInt(s, <span class="number">2</span>);</span><br><span class="line">            bytes.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bytes);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;该编码的字长为：&quot;</span>+sb.length());</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffManTree 赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> results 编码值哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 记录编码值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">huffmanEncoding</span><span class="params">(HuffManTree huffManTree, Map&lt;Byte,String&gt; results, String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进行遍历，然后处理</span></span><br><span class="line">        <span class="keyword">if</span> (huffManTree.b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当前遍历到的元素不为0，说明为结点元素，需要给一个编码值</span></span><br><span class="line">            results.put(huffManTree.b, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (huffManTree.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里不能写s += &quot;0&quot;，因为返回上一层已经在上一层先赋值在使用，所以上层会延续下层的值</span></span><br><span class="line">            huffmanEncoding(huffManTree.left, results, s + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (huffManTree.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            huffmanEncoding(huffManTree.right, results, s + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HuffManTree <span class="title">huffmanBuild</span><span class="params">(List&lt;HuffManTree&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要实现Comparable接口并重写对应的方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            HuffManTree leftNode = list.get(<span class="number">0</span>);</span><br><span class="line">            HuffManTree rigtNode = list.get(<span class="number">1</span>);</span><br><span class="line">            HuffManTree parent = <span class="keyword">new</span> HuffManTree(leftNode.weight + rigtNode.weight);</span><br><span class="line">            <span class="comment">//构建一颗二叉树</span></span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rigtNode;</span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rigtNode);</span><br><span class="line">            list.add(parent);</span><br><span class="line">            <span class="comment">//将现有的集合进行排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后剩下的是这颗赫夫曼树的头节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;成功构建该树，前序遍历结果如下&quot;</span>);</span><br><span class="line">        preTraversal(list.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preTraversal</span><span class="params">(HuffManTree node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preTraversal(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preTraversal(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="赫夫曼解码"><a href="#赫夫曼解码" class="headerlink" title="赫夫曼解码"></a><strong>赫夫曼解码</strong></h2><p>能编就会解，反着来就可以</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a><strong>步骤</strong></h3><p>1、根据编码集results创建解码集</p><p>2、将给定的byte编码集先转为8位2进制字符串</p><p>3、将得到的二进制串按照解码集去解码得到byte集合</p><p>4、将byte集合转为byte数组</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 赫夫曼解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 需要解密的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> results 编码集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decoding</span><span class="params">(List&lt;Byte&gt; bytes, Map&lt;Byte,String&gt; results)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据编码集results创建解码集</span></span><br><span class="line">    Map&lt;String, Byte&gt; decoding = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    results.forEach((k,v) -&gt; decoding.put(v,k));</span><br><span class="line">    <span class="comment">//将给定的byte编码集先转为8位2进制字符串</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = bytes.get(i);</span><br><span class="line">        <span class="comment">//返回的为二进制的补码</span></span><br><span class="line">        String string = Integer.toBinaryString(b);</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            string = string.substring(string.length() - <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示8位整数，不够高位补0，最后一位且为正数不做处理</span></span><br><span class="line">        <span class="keyword">if</span> (i != bytes.size() - <span class="number">1</span> &amp;&amp; b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            string = String.format(<span class="string">&quot;%08d&quot;</span>,Integer.parseInt(string));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(string);</span><br><span class="line">    &#125;</span><br><span class="line">    String result = sb.toString();</span><br><span class="line">    <span class="comment">//创建结果集</span></span><br><span class="line">    String temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    List&lt;Byte&gt; byteResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] array = result.toCharArray();</span><br><span class="line">    <span class="comment">//将得到的二进制串按照解码集去解码得到byte集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : array) &#123;</span><br><span class="line">        temp += c;</span><br><span class="line">        Byte b = decoding.get(temp);</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            byteResults.add(b);</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将byte集合转为byte数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[byteResults.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bs.length; i++) &#123;</span><br><span class="line">        bs[i] = byteResults.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(bs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赫夫曼加密文件"><a href="#赫夫曼加密文件" class="headerlink" title="赫夫曼加密文件"></a><strong>赫夫曼加密文件</strong></h2><p>思路：用IO流的方式转为字节，传入编码方法，得到新的字节及编码集，写入对象流中。解压同理，利用对象流读取字节和编码集后，传入解码方法得到对应的字节数据</p><p>可以去git地址看源码</p><h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a><strong>顺序存储二叉树</strong></h2><p><strong>作用是堆排序的时候会用到</strong></p><p>用一组连续的存储单元存放二叉树中的结点数组转二叉树</p><p>顺序存储二叉树的特点为</p><ol><li>顺序二叉树通常只考虑完全二叉树</li><li>第n个元素的左子节点为2*n+1</li><li>第n个元素的右子节点为2*n+2</li><li>第n个元素的父节点为（n-1）/2</li><li>其中n表示二叉树中第几个元素，从0开始</li></ol><p>有这几个规则后就可以很容易的写出实现代码</p><p>就是用数的遍历方式输出数组中的值，比如前序遍历代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index为数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组为空，无需遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a[index]);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>*index + <span class="number">1</span>) &lt; a.length) &#123;</span><br><span class="line">        <span class="comment">//向左遍历</span></span><br><span class="line">        preOrder(a, <span class="number">2</span>*index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>*index + <span class="number">2</span>) &lt; a.length) &#123;</span><br><span class="line">        <span class="comment">//向右遍历</span></span><br><span class="line">        preOrder(a, <span class="number">2</span>*index + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a><strong>线索化二叉树</strong></h2><p><strong>相关概念</strong></p><p><strong>空指针域</strong>：一些节点的左右子树有的并没有，没有的就叫做空指针域，一个节点可能有0-2个空指针域，空指针域= 节点 + 1也就是n+1</p><p>怎么算出来的（了解）</p><p>因为n个节点有2n个指针 又因为n个节点中有n-1条边（节点之间的线被称之为边，比如两个节点只有一条边，三个有两条边，以此类推） 剩下的空链域就是2n-(n-1)=n+1，即n+1个空指针域（有边的则表示存在指针依赖关系，一个节点最多有两条边，减去有关系的也就是n-1条边，剩下的n+1即为没有指向关系的即为空指针域）</p><p><strong>线索二叉树</strong>它解决了无法直接找到该结点在某种遍历序列中的前趋和后继结点的问题，出现了二叉链表找左、右孩子困难的问题，线索二叉树又分为前序线索化，中序线索化和后序线索化，分别用不同的逻辑去实现。</p><p><img src="https://pic4.zhimg.com/v2-3698162aaa8422fe7ccd74087a9d2c7f_b.png" alt="img"></p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><strong>二叉排序树</strong></h2><p>概念，任何一个非叶子结点，其左子结点都比其小，右子结点都比其大</p><p>现在给定一个数组，将其中的值构建为一颗二叉排序树</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">     Node node = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; a.length; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> temp = a[i];</span><br><span class="line">         findNullPoint(temp, node);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//找到空结点</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNullPoint</span><span class="params">(<span class="keyword">int</span> a, Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (a &lt;= node.value) &#123;</span><br><span class="line">         <span class="keyword">if</span> (node.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">             node.leftNode = <span class="keyword">new</span> Node(a);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         findNullPoint(a, node.leftNode);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (a &gt; node.value) &#123;</span><br><span class="line">         <span class="keyword">if</span> (node.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">             node.rightNode = <span class="keyword">new</span> Node(a);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         findNullPoint(a, node.rightNode);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a><strong>删除结点</strong></h3><p>考虑三种情况</p><ul><li>删除节点没有子节点</li><li>删除节点只有一个子节点</li><li>删除节点有两个子节点</li></ul><p><strong>处理方式</strong></p><ul><li>直接删除（没有子节点）</li><li>将删除节点的父节点指向其子节点（只有一个子节点）</li><li>如果删除节点是父节点的左子节点，则替换为删除节点的最右子树（一直向右遍历）</li><li>如果删除删除节点为父节点的右子节点则将删除位置替换为删除节点的最左子树</li></ul><p><strong>难点</strong></p><p>1、当删除结点有两个子节点的时候应该如何处理</p><p>将该节点下的所有结点的值存入数组中，然后重新构建树节点，放入父节点下（我当时的做法，会比较消耗性能，所以稳妥的做法是上面提到的解决方法，也就是第二种方法）</p><p>第二种方法为找到待删除结点的右子树中最小的结点N，然后取出，new一个结点使指等于结点N，左子树指向待删除的左子树，右子树指向待删除的右子树，当然取出结点如果有右子树，那么将其父节点与其链接，如图所示</p><p><img src="https://pic1.zhimg.com/v2-d38e85f2eeaf91324149b0b80020b55c_b.png" alt="img"></p><p>来源于《算法第四版》</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除结点,需要考虑叶子结点，有一个子节点，有两个子节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node node, Node deleteNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.value == node.value) &#123;</span><br><span class="line">        <span class="comment">//说明删除的为根节点，直接返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不能删除根节点！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到需要删除的结点&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.leftNode.value == deleteNode.value) &#123;</span><br><span class="line">            <span class="comment">//相等的就判断结点类型</span></span><br><span class="line">            <span class="keyword">if</span> (node.leftNode.leftNode == <span class="keyword">null</span> &amp;&amp; node.leftNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明为叶子结点,直接将其置为空</span></span><br><span class="line">                node.leftNode = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.leftNode.leftNode != <span class="keyword">null</span> &amp;&amp; node.leftNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明有两个子节点</span></span><br><span class="line">                buildSort(node.leftNode);</span><br><span class="line">                list.remove(Integer.valueOf(node.leftNode.value));</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    temp[i] = list.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">                Node tempNode = buildTree(temp);</span><br><span class="line">                node.leftNode = tempNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.leftNode.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//只有一个左子节点，将其替换</span></span><br><span class="line">                node.leftNode = node.leftNode.leftNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//只有一个右子结点，将其替换</span></span><br><span class="line">                node.leftNode = node.leftNode.rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delete(node.leftNode, deleteNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.value &gt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到需要删除的结点&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.rightNode.value == deleteNode.value) &#123;</span><br><span class="line">            <span class="comment">//相等的就判断结点类型</span></span><br><span class="line">            <span class="keyword">if</span> (node.rightNode.leftNode == <span class="keyword">null</span> &amp;&amp; node.rightNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明为叶子结点,直接将其置为空</span></span><br><span class="line">                node.rightNode = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.rightNode.leftNode != <span class="keyword">null</span> &amp;&amp; node.rightNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明有两个子节点</span></span><br><span class="line">                buildSort(node.rightNode);</span><br><span class="line">                list.remove(Integer.valueOf(node.rightNode.value));</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    temp[i] = list.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">                Node tempNode = buildTree(temp);</span><br><span class="line">                node.rightNode = tempNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.rightNode.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//只有一个左子节点，将其替换</span></span><br><span class="line">                node.rightNode = node.rightNode.leftNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//只有一个右子结点，将其替换</span></span><br><span class="line">                node.rightNode = node.rightNode.rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delete(node.rightNode, deleteNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildSort</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先找到最左节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeftNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        buildSort(node.getLeftNode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其次输出当前节点,list为全局静态变量</span></span><br><span class="line">    list.add(node.getValue());</span><br><span class="line">    <span class="comment">//最后向右进行遍历</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRightNode()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        buildSort(node.getRightNode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a><strong>平衡二叉树（AVL）</strong></h2><p>二叉树可能会存在的问题（复杂度会出现O（N）的情况）</p><p><img src="https://pic1.zhimg.com/v2-d801d7dbdd76a77d1a3858ab15f54928_b.png" alt="img"></p><p>这样的构造如同一个链表</p><p>更像一个单链表，查询速度明显降低</p><p><strong>解决方案：平衡二叉树（AVL）</strong></p><p>小科普：为什么叫AVL？（了解）</p><p>由前苏联的数学家 <strong>A</strong>delse-<strong>V</strong>elskil 和 <strong>L</strong>andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。我还纳闷了，怎么平衡二叉树缩写能没有B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一颗平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildBalanceTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        Node.findNullPoint(temp, node);</span><br><span class="line">        <span class="comment">//对不满足平衡二叉树的条件进行旋转</span></span><br><span class="line">        turn(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><p><strong>左右两个子树高度差绝对值不能超过1</strong>，并且左右两颗子树都是一颗平衡二叉树</p><p>平衡二叉树实现的方式有：红黑树，AVL（算法），替罪羊树，Treap，伸展树等。</p><p>相关概念：左旋，右旋，双旋</p><p><strong>AVL最对进行两次旋转就可以达到平衡</strong></p><p>右子树高度高，进行左旋转</p><p>相反，左子树高度好，进行右旋转</p><p><strong>旋转的目的：降低树的高度（不是为了好看）</strong></p><p><img src="https://pic3.zhimg.com/v2-1132908c097827b958d0c3368c32bf2a_b.png" alt="img"></p><p>假如此时的一颗树状况如上，右子树高，则进行左旋操作，分为6步</p><p>1、new一个结点，值为当前结点（默认为根节点）</p><p>2、将新节点的左子树指向当前结点的左子节点</p><p>3、将新结点的右子节点指向当前结点的右子节点的左子节点</p><p>4、将当前结点的值变为右子树结点的值</p><p>5、将当前结点的左子树指向为新节点</p><p>6、将当前结点的右子树指向当前结点的右子节点的右子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行左旋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建新节点，值与当前结点相同</span></span><br><span class="line">    Node temp = <span class="keyword">new</span> Node(node.value);</span><br><span class="line">    <span class="comment">//2、将新节点左子树指向当前结点的左子树</span></span><br><span class="line">    temp.leftNode = node.leftNode;</span><br><span class="line">    <span class="comment">//3、将新节点的右子树指向当前结点的右子树的左子树</span></span><br><span class="line">    temp.rightNode = node.rightNode.leftNode;</span><br><span class="line">    <span class="comment">//4、将当前结点的值变为当前结点的右子树结点的值</span></span><br><span class="line">    node.value = node.rightNode.value;</span><br><span class="line">    <span class="comment">//5、将当前结点的左子树指向新节点</span></span><br><span class="line">    node.leftNode = temp;</span><br><span class="line">    <span class="comment">//6、将当前结点的右子树指向当前结点右子树的右子树</span></span><br><span class="line">    node.rightNode = node.rightNode.rightNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右旋反过来就行</p><p><img src="https://pic3.zhimg.com/v2-4dbbbf9215593fdebd44609b86cd3a6a_b.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行右旋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建新节点，值与当前结点相同</span></span><br><span class="line">    Node temp = <span class="keyword">new</span> Node(node.value);</span><br><span class="line">    <span class="comment">//2、将新节点右子树指向当前结点的右子树</span></span><br><span class="line">    temp.rightNode = node.rightNode;</span><br><span class="line">    <span class="comment">//3、将新节点的左子树指向当前结点的左子树的右子树</span></span><br><span class="line">    temp.leftNode = node.leftNode.rightNode;</span><br><span class="line">    <span class="comment">//4、将当前结点的值变为当前结点的左子树结点的值</span></span><br><span class="line">    node.value = node.leftNode.value;</span><br><span class="line">    <span class="comment">//5、将当前结点的右子树指向新节点</span></span><br><span class="line">    node.rightNode = temp;</span><br><span class="line">    <span class="comment">//6、将当前结点的左子树指向当前结点左子树的左子树</span></span><br><span class="line">    node.leftNode = node.leftNode.leftNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>旋转的条件</strong></p><p>高度差超过1</p><p>难点</p><p>1、判断当前树的高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(node.leftNode == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.leftNode), node.rightNode == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.rightNode)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此方法妙在+1，如果没有+1那么在返回上一层的时候将是0，最终结果始终是0，不会发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查该树的状态 0 表示平衡二叉树</span></span><br><span class="line"><span class="comment"> * -1表示左子树高</span></span><br><span class="line"><span class="comment"> * 1表示右子树高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isCheckNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lh = getLeftHeight(node);</span><br><span class="line">    <span class="keyword">int</span> rh = getRightHeight(node);</span><br><span class="line">    <span class="keyword">if</span> (lh &gt; rh &amp;&amp; lh - rh &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rh &gt; lh &amp;&amp; rh -lh &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-0bb8cc39a31c33b5b9b0b153a01f69df_b.png" alt="img"></p><p>上图为特殊情况，一次旋转并不能称为平衡二叉树，所以需要进行双旋。<strong>需要在旋转前在进行一次判断，看是否需要进行双旋</strong>（旋转一次不能满足，所以需要旋转两次）</p><p><strong>难点</strong></p><p>1、左旋前先判断当前结点的右节点的左子树高度是否大于当前结点的左子树高度，如果大于则对当前结点的右子树进行右旋</p><p>2、同样的，右旋前先判断当前结点左子节点的右子树高度是否大于当前结点的右子树高度，如果大于则对当前结点的左子树进行左旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">turn</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = isCheckNode(node);</span><br><span class="line">    <span class="keyword">if</span> (status == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//进行右旋</span></span><br><span class="line">        <span class="keyword">if</span> (getHeight(node.leftNode.rightNode) &gt; getHeight(node.rightNode)) &#123;</span><br><span class="line">            <span class="comment">//进行局部旋转</span></span><br><span class="line">            turnLeft(node.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        turnRight(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//进行左旋</span></span><br><span class="line">        <span class="keyword">if</span> (isCheckNode(node.rightNode.leftNode) &gt; isCheckNode(node.leftNode)) &#123;</span><br><span class="line">            <span class="comment">//进行局部旋转</span></span><br><span class="line">            turnRight(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        turnLeft(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a><strong>多叉树</strong></h2><p>为什么需要多叉树</p><p>二叉树虽然说效率比较高，但是也会存在问题，结点数 = 2的高度次方 -1 。假如节点数过多的话，在构建二叉树的时候，需要进行多次IO操作，速度会有影响，高度同样也会很高，降低操作速度</p><p><strong>多叉树的优点</strong></p><p>通过重新组织结点，降低树的高度</p><p>几个分叉就表示几结点</p><p>文件系统几数据库系统的设计者利用磁盘预读的原理，将一个结点大小设为等于一个页（页的大小通常为4k），这样每个结点只需要一次IO就可以完全载入。所以B树应用广泛（B+也是）</p><p><strong>2-3树是最简单的B树结构</strong>，特点如下</p><p><strong>那什么是B树？</strong></p><p>B表示balance，也就是平衡树</p><p>1、所有叶子结点都在同一层（也是B树的特点）</p><p>2、有两个子节点的节点叫二节点，二节点要么没有节点，要么有两个子节点</p><p>3、有三个子节点的节点叫二节点，三节点要么没有节点，要么有三个子节点</p><p>4、2-3树是由二节点和三节点构成的树</p><p><img src="https://pic4.zhimg.com/v2-0c73e9c2398c41099ea0fb7525c6cc9b_b.png" alt="img"></p><p>如图所示</p><p>除了2-3树外，还有2-3-4树，道理是一样的</p><p><img src="https://pic1.zhimg.com/v2-9392f217484b68715a3a378eda29a7d4_b.png" alt="img"></p><h2 id="B-树和B-树（不详细，后续补充）"><a href="#B-树和B-树（不详细，后续补充）" class="headerlink" title="B+树和B*树（不详细，后续补充）"></a><strong>B+树和B*树（不详细，后续补充）</strong></h2><p>B即balanced，没有B-树 ，其实是B树</p><p>B树的阶：指最多节点的个数，比如2-3树的阶为3</p><p>数据分布在整个树中，即叶子节点和非叶子节点都存放数据</p><p>搜索性能相当于在关键字全集内做一次二分查找</p><p>B+树是B树的变体，所有的数据存于叶子节点中，也叫做稠密索引，且列表中的关键字恰好是有序的，不可能在非叶子节点命中，非叶子节点中的叫索引不是数据，非叶子节点的数据也叫做稀疏索引，所以说更加适合文件系统，所以B树与B+树各自都有用途，取决于应用场景</p><p>这个思想是怎么来的，假设给定一个单链表有27条数据，则可以分为3 * 9 层</p><p><img src="https://pic3.zhimg.com/v2-858cfce3ee279d6d46a2b2b01be7ba9a_b.png" alt="img"></p><p>B*树是B+树的变体，在B+树的非根和非叶子节点在增加指向兄弟的指针</p><p><img src="https://pic2.zhimg.com/v2-d29abdae7a015cefa5ecb565b0924ae9_b.png" alt="img"></p><h2 id="红黑树（过于复杂，后续补充代码）"><a href="#红黑树（过于复杂，后续补充代码）" class="headerlink" title="红黑树（过于复杂，后续补充代码）"></a><strong>红黑树（过于复杂，后续补充代码）</strong></h2><p><strong>前置条件</strong>：二叉排序树（BST），平衡二叉树（AVL）</p><p>跟AVL类似，都是平衡二叉树，不同的是AVL是以左右子树的高度差不超过1做限制，所以是全局变动，数据量变大之后会出现性能问题。而红黑树的出现解决了这个问题，它采用局部变动的方式达到一种自平衡，靠的就是<strong>旋转</strong>跟<strong>变色</strong>，旋转操作前面也提到了，变色就是红变黑，黑变红。<strong>难的是什么时候旋转？什么时候变色？</strong>由于它是一种局部自平衡，所以并不是一颗完美的平衡二叉查找树，但左右子树的黑节点层数是相等的，所以我们又称这种平衡叫做<strong>黑色完美平衡</strong></p><p>跟AVL树一样都需要一个规则来进行判断，不满足的话则进行平衡操作</p><p>红黑树有5点规则需要遵守，也可以说红黑树的性质</p><p>1、结点不是红的就是黑的。</p><p>2、根节点是黑色</p><p>3、每个叶子结点都是黑的（指null结点）</p><p>4、每个红节点的两个子节点都是黑的，不能出现连续的两个红色结点</p><p>5、从任意结点到叶子结点都包含相同数目的黑色结点</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a><strong>插入</strong></h3><p>插入的时候还是按照二叉排序树的规则去插，逐一比较插入，插入后不满足条件在进行平衡。插入结点为红节点</p><p>分场景讨论</p><p><strong>场景1：插入时该树没有结点</strong></p><p>将红节点变色</p><p><strong>场景2：插入该值已存在</strong></p><p>直接找到该值然后重新赋值</p><p><strong>场景3：插入的时候父节点为黑色</strong></p><p>满足红黑树的性质直接插入即可</p><p><img src="https://pic2.zhimg.com/v2-c642394b034f7dafddc44e2f0f40e521_b.png" alt="img"></p><p><strong>场景4：插入的时候父节点为红色</strong></p><p>不满足性质4，也可以得出插入结点一定有祖父结点（父节点的父节点）(根据性质2)</p><p>在分情况讨论</p><p>4.1：叔叔结点为红色</p><p>当前结点情况为黑红红，最简单的处理方式为红黑红，然后在左后续处理（需要注意的是叔叔也需要变为黑色）</p><p><img src="https://pic2.zhimg.com/v2-ea2b0f9b42916263e437faa734e9aa65_b.png" alt="img"></p><p>如果此时pp结点的父节点为黑色，则无需做任何处理</p><p>如果pp结点父节点为红色，则违反性质4，需要设置pp结点为当前结点，继续做平衡处理</p><p><strong>4.2：叔叔结点不存在或者为黑色，并且父节点为左子节点</strong></p><p>首先来说，叔叔不可能为黑节点，否则违反性质5</p><p><strong>4.2.1：插入结点为P的左子节点</strong></p><p>怎么处理：首先变色：父节点变为黑色，祖父为红，然后进行右旋</p><p><img src="https://pic3.zhimg.com/v2-7cfb97601107f63110f6e86a0f734f3a_b.png" alt="img"></p><p><strong>4.2.2：插入结点为P的右子节点</strong></p><p>将p左旋（变为上面的情况），然后变色，最后将PP右旋</p><p><img src="https://pic1.zhimg.com/v2-466816fee2df23c4f70d0e5b68efc2f8_b.png" alt="img"></p><p><strong>4.3：叔叔结点不存在或者为黑色，并且父节点为右子节点</strong></p><p><strong>4.3.1：插入为左子节点</strong></p><p><strong>4.3.2：插入为右子节点</strong></p><p>情况同上，反过来就行</p><p>删除过于复杂，捋顺了再来补充</p><p>以上图片大多来源于网络，侵删</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/post/b6c47025.html"/>
      <url>/post/b6c47025.html</url>
      
        <content type="html"><![CDATA[<ol><li>队列的特点</li><li>单向队列</li><li>环形队列</li><li>单向链表</li><li>双向链表</li><li>环形链表</li></ol><p>以下只给出思路与关键方法，算法的源代码放在了git中，需要的自取</p><p><a href="https://gitee.com/leidl97/algorithm-src">https://gitee.com/leidl97/algor</a></p><h2 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h2><p>先进先出 （FIFO）</p><p>可以理解为排队，先排的先进入。如图所示</p><p><img src="https://pic3.zhimg.com/v2-440610472e4afb0892bad7cf428f7046_b.png" alt="img"></p><p>出自《算法第四版》第78页</p><h2 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h2><h3 id="思想（如何定义数据）"><a href="#思想（如何定义数据）" class="headerlink" title="思想（如何定义数据）"></a><strong>思想（如何定义数据）</strong></h3><p>用数组实现，头指针指向开始的前一个位置用-1表示，默认位置为0</p><p>尾指针指向最后一个元素的位置也用-1表示（初始情况下，没有元素，所以指向-1，当元素加入后尾指针会+1，将值添加到尾指针所在的位置）</p><p><img src="https://pic3.zhimg.com/v2-fac105e3e2540fcf82187b9734809bd2_b.png" alt="img"></p><h3 id="判断队列为满"><a href="#判断队列为满" class="headerlink" title="判断队列为满"></a><strong>判断队列为满</strong></h3><p>尾指针指向元素的最后一个位置</p><p><img src="https://pic3.zhimg.com/v2-1da9e86381d4bba2ebe3df67cd0b14ea_b.png" alt="img"></p><h3 id="判断队列为空"><a href="#判断队列为空" class="headerlink" title="判断队列为空"></a><strong>判断队列为空</strong></h3><p>头指针=尾指针</p><h3 id="存入数据"><a href="#存入数据" class="headerlink" title="存入数据"></a><strong>存入数据</strong></h3><p><strong>先移在存</strong>。先让尾指针+1，在将值赋给尾指针所在的位置</p><h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a><strong>取出数据</strong></h3><p><strong>先移在取</strong>。取尾部数据，先让头指针+1，将头指针指向的位置取出</p><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a><strong>Java实现</strong></h3><p>写出这个队列的入队和出队方法，一般采用数组的方式实现</p><p>属性定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="comment">//队列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line"><span class="comment">//队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="comment">//存放队列的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//this可以省略，但是写上显得思路更清晰</span></span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    <span class="comment">//队列头指向开始的前一个位置</span></span><br><span class="line">    <span class="keyword">this</span>.begin = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//队列尾指向最后的位置。虽然都是-1但表示的意义不同</span></span><br><span class="line">    <span class="keyword">this</span>.end = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否未满,队列尾为数组最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.end == <span class="keyword">this</span>.maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空 头尾指针相等的时候</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.begin == <span class="keyword">this</span>.end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加数据到队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否满</span></span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列满，不能加入数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.arr[++<span class="keyword">this</span>.end] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取队列数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队列的数据,取数据从后面取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//抛出异常，不用在写return</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列空，不可以取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.arr[++<span class="keyword">this</span>.begin];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示队列数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队列的数据,取数据从后面取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//抛出异常，不用在写return</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列空，不可以取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.arr[++<span class="keyword">this</span>.begin];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示队列头数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示队列的头数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBegin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;该队列为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.arr[begin+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺陷</strong></p><p>不能够复用，用一次就废了，不能频繁添加和删除元素，解决方式为使用环形队列</p><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h3><p>可以想下需要用什么方法来实现复用呢，没错就是<strong>取模</strong></p><p>所以定义数组的时候<strong>牺牲一个空间来做判断</strong></p><p>不同的是，我们定义头指针指向第一个元素也就是0</p><p>尾指针指向数组末尾的下一个位置也为0</p><h3 id="判断队列为空-1"><a href="#判断队列为空-1" class="headerlink" title="判断队列为空"></a><strong>判断队列为空</strong></h3><p>头指针=尾指针。比如刚开始的时候</p><p><img src="https://pic3.zhimg.com/v2-24f7e29d3eb5237c3e6ee55b09cca29e_b.png" alt="img"></p><h3 id="判断队列为满-1"><a href="#判断队列为满-1" class="headerlink" title="判断队列为满"></a><strong>判断队列为满</strong></h3><p>（尾指针+1）%数组大小为头指针所在位置的时候队列为满</p><p><img src="https://pic1.zhimg.com/v2-9152ff299316cf2a05be00e309f43574_b.png" alt="img"></p><h3 id="存入数据-1"><a href="#存入数据-1" class="headerlink" title="存入数据"></a><strong>存入数据</strong></h3><p>与单向不同的是，这次是<strong>先存在移</strong>。先将尾指针指向的区域存入指定数据，然后移动到下一个位置</p><h3 id="取出数据-1"><a href="#取出数据-1" class="headerlink" title="取出数据"></a><strong>取出数据</strong></h3><p><strong>先取在移</strong>。取出当前头指针指向的元素，然后移动到下一个位置</p><h3 id="获取所有元素"><a href="#获取所有元素" class="headerlink" title="获取所有元素"></a><strong>获取所有元素</strong></h3><p>遍历需要想明白?的位置应该怎么填写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i = ?; i &lt; ?; i++) </span><br></pre></td></tr></table></figure><p>第一个?的位置应该是当前头指针指向的元素下标</p><p>第二个?应该为当前头指针下标+元素的有效个数</p><p>如果不这么判断，那就需要判断两个指针谁前谁后的位置了</p><h3 id="获取有效个数"><a href="#获取有效个数" class="headerlink" title="获取有效个数"></a><strong>获取有效个数</strong></h3><p>(尾指针-头指针+数组大小)%数组大小</p><p>其实也就是尾指针-头指针的<strong>绝对值</strong></p><h3 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a><strong>Java实现</strong></h3><p>属性定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="comment">//队列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line"><span class="comment">//队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="comment">//存放队列的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果按照头指向第一个元素，尾指向最后一个元素，当为起始状态时无法判断为空还是为满</span></span><br><span class="line"><span class="comment">//定义添加数据尾指针移动，取数据头指针移动,这样设计牺牲了一个空间，也就是说默认最后一个位置不存数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//this可以省略，但是写上显得思路更清晰</span></span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    <span class="comment">//队列头指向元素的第一个位置</span></span><br><span class="line">    <span class="keyword">this</span>.begin = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队列尾指向元素最后的位置</span></span><br><span class="line">    <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为满,尾+1%maxsize = 头 ：头始终指向第一个元素当加1取模等于尾的时候说明满（尾表示最后一个元素+1）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.end + <span class="number">1</span>)%maxSize == <span class="keyword">this</span>.begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空 头尾指针相等的时候</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.begin == <span class="keyword">this</span>.end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据到队列,尾指针+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否满</span></span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列满，不能加入数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    arr[end] = data;</span><br><span class="line">    end = (end + <span class="number">1</span>) % maxSize;</span><br><span class="line">    System.out.println(<span class="string">&quot;存数据：&quot;</span>+data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取队列头数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队列的数据,头指针+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//抛出异常，不用在写return</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列空，不可以取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> data = arr[begin];</span><br><span class="line">    begin = (begin + <span class="number">1</span>) % maxSize;</span><br><span class="line">    System.out.println(<span class="string">&quot;取数据:&quot;</span>+data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示队列的所有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示队列的所有数据[注意取模]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;该队列为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i&lt; begin+getActive(); i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr[&quot;</span>+i%maxSize+<span class="string">&quot;]=&quot;</span>+arr[i%maxSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示队列的有效数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示队列的有效数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (end + maxSize - begin) % maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>又叫linked list，是有序的列表，一个地址，一个data域用于存数据，一个next域用于指向下一个地址</p><p>链表是以节点的方式存储的</p><p>每个节点包含data域，和next域</p><p>不一定是连续存储</p><p><img src="https://pic4.zhimg.com/v2-04659ac92327043359cbc41fbf1e9a83_b.png" alt="img"></p><p>图片来源于网络</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a><strong>单向链表</strong></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>首先定义一个节点类Node</p><p>有编号（ID），数据和下一个节点至少三个属性</p><p>定义一个节点类，初始化头节点，因为头节点不可以动所以定义辅助节点，用来添加和遍历</p><p>添加：尾插法，判断当前元素的下一个元素是否为空，如果是则在当前节点插入下一个节点，如果不是依次往后寻找，直到找到下一个为空的那个节点然后插入</p><p>遍历：先判断头节点的下一个元素是否为空，否则往下进行寻找，然后一次输出节点</p><p>缺点：不能按照编号顺序添加</p><p><img src="https://pic4.zhimg.com/v2-e05f8e8979f3b82631a3e812a79ef857_b.png" alt="img"></p><h3 id="Java实现-2"><a href="#Java实现-2" class="headerlink" title="Java实现"></a>Java实现</h3><p>测试部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MangerNode mangerNode = <span class="keyword">new</span> MangerNode();</span><br><span class="line">Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="string">&quot;1号老婆&quot;</span>);</span><br><span class="line">Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="string">&quot;2号老婆&quot;</span>);</span><br><span class="line">Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="string">&quot;3号老婆&quot;</span>);</span><br><span class="line">Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="string">&quot;4号老婆&quot;</span>);</span><br><span class="line">mangerNode.add(node1);</span><br><span class="line">mangerNode.add(node2);</span><br><span class="line">mangerNode.add(node3);</span><br><span class="line">mangerNode.add(node4);</span><br><span class="line">mangerNode.show();</span><br></pre></td></tr></table></figure><p>定义结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记当前节点序号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">public</span> String data;</span><br><span class="line"><span class="comment">//下一个节点</span></span><br><span class="line"><span class="keyword">public</span> Node next;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.no = no;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    temp = head.next;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要按照编号顺序添加</p><p>需要去遍历并且判断。从头节点开始，用temp作为辅助变量指向头节点，判断下一个元素的序号no是否大于插入的节点，如果是则找到当前元素。如果等于则为重复节点，否则继续遍历，直到下一个元素为空</p><p>添加代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个节点(高级版)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPro</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="comment">//默认没有重复元素</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.next.no &gt; node.no) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == node.no) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有no为&quot;</span>+node.no+<span class="string">&quot;重复元素不可以  添加&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = temp.next;</span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改：找到后直接修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = head.next;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.no == node.no) &#123;</span><br><span class="line">                    temp.data = node.data;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除：除了找到需要删除的B之外，还需要找到前一个节点A，原来A指向B，现在A指向C，最后删除B（直接赋值就相当于删除）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到A指向B成为指向C然后删除B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = head;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.next.no == node.no) &#123;</span><br><span class="line">                    temp.next = temp.next.next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a><strong>链表反转</strong></h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>分为原来的链表和现在的链表</p><p>重要的核心步骤为</p><p>1、原来当前节点(cur)指向新头节点的下一个节点(new.next)</p><p>2、新头节点(new.next)的下一个指向当前节点(cur)</p><p>画个图</p><p><img src="https://pic2.zhimg.com/v2-05d0d7a63c7139765923be48fb2f8281_b.png" alt="img"></p><p>第一次移动</p><p><img src="https://pic3.zhimg.com/v2-3be85618ee4abc306ec027b00285ad8e_b.png" alt="img"></p><p>第二次移动</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Node headNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当没有节点或者只有一个节点的时候直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (headNode.next == <span class="keyword">null</span> || headNode.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义辅助变量cur，用于遍历原链表</span></span><br><span class="line">        Node cur = headNode.next;</span><br><span class="line">        <span class="comment">//定义cur的下一个节点next，用来记录</span></span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义新节点的头节点</span></span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//next指向cur的下一个节点</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">//cur的下一个节点指向新头节点的下一个节点</span></span><br><span class="line">            cur.next = newHead.next;</span><br><span class="line">            <span class="comment">//新头节点的下一个节点指向cur节点</span></span><br><span class="line">            newHead.next = cur;</span><br><span class="line">            <span class="comment">//cur后移</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时cur已经是head之后反转的一串链表，从新节点给到原节点上，实现原节点的反转</span></span><br><span class="line">        headNode.next = newHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a><strong>效果截图</strong></h3><p><img src="https://pic2.zhimg.com/v2-c0ac2726c0b619ac534dcc9f5d2ea5a9_b.png" alt="img"></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>与单向链表不同的是属性<strong>增加了一个指向前一个节点的pre</strong></p><p>在增删改查上做了些许改变，但也容易实现</p><p>增加：除了需要指向下一个，现在还需要指向上一个</p><p>删除：找到需要删除的节点后，用该节点的前一个指向该节点的后一个，同样的后一个也指向前一个。</p><p>修改：这个没有变化，根据节点找到具体元素后，修改数据即可</p><p>查询：可以进行next遍历，也可以进行pre遍历</p><p><strong>注意</strong>：实现toString方法的时候如果带上next和pre会报栈溢出，已踩坑</p><h3 id="Java实现-3"><a href="#Java实现-3" class="headerlink" title="Java实现"></a>Java实现</h3><p>测试部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        DoubleNode node1 = <span class="keyword">new</span> DoubleNode(<span class="number">1</span>,<span class="string">&quot;老婆1号&quot;</span>);</span><br><span class="line">        DoubleNode node2 = <span class="keyword">new</span> DoubleNode(<span class="number">2</span>,<span class="string">&quot;老婆2号&quot;</span>);</span><br><span class="line">        DoubleNode node3 = <span class="keyword">new</span> DoubleNode(<span class="number">3</span>,<span class="string">&quot;老婆3号&quot;</span>);</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        DoubleNode node4 = <span class="keyword">new</span> DoubleNode(<span class="number">1</span>,<span class="string">&quot;老婆4号&quot;</span>);</span><br><span class="line">        ManagerDoubleNode.add(node1);</span><br><span class="line">        ManagerDoubleNode.add(node2);</span><br><span class="line">        ManagerDoubleNode.add(node3);</span><br><span class="line"><span class="comment">//        ManagerDoubleNode.delete(node3.getNo());</span></span><br><span class="line">        ManagerDoubleNode.update(node4);</span><br><span class="line">        ManagerDoubleNode.show();</span><br></pre></td></tr></table></figure><p>结点定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义节点编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="comment">//定义前一个节点</span></span><br><span class="line"><span class="keyword">public</span> DoubleNode pre;</span><br><span class="line"><span class="comment">//定义数据</span></span><br><span class="line"><span class="keyword">public</span> String data;</span><br><span class="line"><span class="comment">//定义后一个节点</span></span><br><span class="line"><span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">DoubleNode(<span class="keyword">int</span> no, String data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.no = no;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleNode node)</span> </span>&#123;</span><br><span class="line">    DoubleNode temp = ManagerDoubleNode.head;</span><br><span class="line">    <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.next = node;</span><br><span class="line">    node.pre = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">    DoubleNode temp = ManagerDoubleNode.head.next;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.getNo() == no) &#123;</span><br><span class="line">            <span class="comment">//找到该节点，进行删除</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果该节点不是最后一个节点，则它的下一个节点指向temp的前一个节点</span></span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到就挪到下一个位置</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该节点已删除！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该节点不存在，无法删除！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(DoubleNode node)</span> </span>&#123;</span><br><span class="line">    DoubleNode temp = ManagerDoubleNode.head.next;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.getNo() == node.getNo()) &#123;</span><br><span class="line">            <span class="comment">//找到该节点，进行更新操作</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            temp.data = node.data;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到就挪到下一个位置</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该节点已更新！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该节点不存在，无法更新！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DoubleNode temp = ManagerDoubleNode.head.next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><h3 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a><strong>单向环形链表</strong></h3><h3 id="实现思路及代码"><a href="#实现思路及代码" class="headerlink" title="实现思路及代码"></a><strong>实现思路及代码</strong></h3><p>与之前节点定义相同，编号，数据域，下一个指向</p><p>增删改查略有不同，<strong>next现在不会指向null，即使只有一个元素也会指向自己</strong></p><p><strong>判断结束的条件改变</strong>，需要判断当前节点的下一个节点是否为头节点</p><p>遍历代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CircleNode <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(cur);</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>增加不变，找到最后一个位置然后增加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CircleNode circleNode)</span> </span>&#123;</span><br><span class="line">        cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = circleNode;</span><br><span class="line">        circleNode.next = first;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>修改不变，找到对应的no然后修改</p><p>需要注意的是没有了结束的判断条件，所以要先进行no判断然后进行遍历一次的判断</p><p>否则如果没有需要修改的元素，就是一直查找下去，删除同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> no, String data)</span> </span>&#123;</span><br><span class="line">        cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.no == no) &#123;</span><br><span class="line">                cur.data = data;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据修改成功！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未找到需要修改的数据!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除需要注意的地方为：如果删除的为头节点，则需要将头节点变换，我这里将头节点顺延，然后再让需要删除的节点的前一个指向修改后的头节点，因为是单链表，所以需要利用当前节点的下一个进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(CircleNode circleNode)</span> </span>&#123;</span><br><span class="line">        cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.no == circleNode.no) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.next == first) &#123;</span><br><span class="line">                    first = cur.next.next;</span><br><span class="line">                    cur.next = first;</span><br><span class="line">                    System.out.println(<span class="string">&quot;删除的数据为头节点，当前头节点顺延为&quot;</span>+first);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据删除成功！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未找到需要删除的数据!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果指定一个环形链表的大小，需要注意的地方是，在方法中初始化，而不是创建对象的时候进行初始化，i=1的时候进行初始化，其余添加节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MangerCircleNode <span class="title">addByNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大小不能小于1！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MangerCircleNode mangerCircleNode = <span class="keyword">new</span> MangerCircleNode();</span><br><span class="line">        CircleNode newNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                mangerCircleNode.first = <span class="keyword">new</span> CircleNode(i,<span class="string">&quot;老婆&quot;</span>+i+<span class="string">&quot;号&quot;</span>);</span><br><span class="line">                mangerCircleNode.first.next = mangerCircleNode.first;</span><br><span class="line">                cur =mangerCircleNode.first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//添加环形节点</span></span><br><span class="line">                newNode = <span class="keyword">new</span> CircleNode(i,<span class="string">&quot;老婆&quot;</span>+i+<span class="string">&quot;号&quot;</span>);</span><br><span class="line">                cur.next = newNode;</span><br><span class="line">                newNode.next = mangerCircleNode.first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur指向下一个节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mangerCircleNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="经典问题：约瑟夫问题"><a href="#经典问题：约瑟夫问题" class="headerlink" title="经典问题：约瑟夫问题"></a><strong>经典问题：约瑟夫问题</strong></h3><p>编号为1,2,…,n的n个人按顺时针方向围坐一圈，每人具有一个编号（正整数）。从第n个数，从第一个人开始按顺时针方向自1开始顺序报数，报到m时停止报数。报m的人出列，从下一个人在数，如此下去，直至所有人全部出列为止。试设计一个程序求出出列顺序。基本要求 利用单向循环链表存储结构模拟此过程,按照出列的顺序印出各人的编号。实现提示 程序运行后，首先要求用户指定初始报数上限值，然后读取各人的密码。可设n≤30。此题所用的循环链表中不需要“头结点”，请注意空表和非空表的界限。</p><p><img src="https://pic3.zhimg.com/v2-e5c197547d4196885235a1efc41a2286_b.png" alt="img"></p><p>图片来源于网络</p><p><img src="https://pic4.zhimg.com/v2-8e95c3e8fea8c138a18997077fd1f12f_b.png" alt="img"></p><p>图片来源于网络</p><p>以此类推</p><p><img src="https://pic2.zhimg.com/v2-ce276ed31f0be23873e5cc46f0083f21_b.png" alt="img"></p><p>图片来源于网络</p><p>模拟：传入一个m，表示隔m个遍历一次，最后输出遍历后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yusefu</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getCount();</span><br><span class="line">    <span class="keyword">if</span> (m &gt; count) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的数字不能大于链表大小&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//复位</span></span><br><span class="line">        cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;m-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cur);</span><br><span class="line">            first = cur.next;</span><br><span class="line">            <span class="keyword">this</span>.delete(cur);</span><br><span class="line">            cur = first;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得该链表的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cur = first;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(cur.next == first)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加强版，输入三个数字，输出遍历结果</p><p>从第几个数，数几次，创建多大的链表</p><p>模拟一个实际问题</p><p>从第几个小朋友数，数几次，有多少小朋友</p><p>需要注意的是变量的作用域问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo 从第几个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNo 数几次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 一共多少人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yusefu</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNo, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startNo &lt; <span class="number">1</span> || countNo &lt; <span class="number">1</span> || size &lt; <span class="number">1</span> || startNo &gt; size) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数字不合理！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MangerCircleNode mangerCircleNode = <span class="keyword">new</span> MangerCircleNode(size);</span><br><span class="line">        <span class="comment">//确认first为哪一个节点，此时已经是一个环，循环获取即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;startNo-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            mangerCircleNode.first = mangerCircleNode.first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复位</span></span><br><span class="line">        mangerCircleNode.cur = mangerCircleNode.first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;最后出圈的编号为：&quot;</span>+mangerCircleNode.cur.no);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;countNo-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                mangerCircleNode.cur = mangerCircleNode.cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(mangerCircleNode.cur);</span><br><span class="line">            mangerCircleNode.first = mangerCircleNode.cur.next;</span><br><span class="line">            mangerCircleNode.delete(mangerCircleNode.cur);</span><br><span class="line">            mangerCircleNode.cur = mangerCircleNode.first;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="补充：稀疏数组"><a href="#补充：稀疏数组" class="headerlink" title="补充：稀疏数组"></a>补充：稀疏数组</h2><p><strong>什么是稀疏数组？</strong></p><p>将一个二维数组变为一个3xn的数组，这样更省空间，提高存储效率</p><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a><strong>思想</strong></h2><p>当一个数组大部分元素为0，或者一个固定值，可以使用稀疏数组保存</p><p>会将一个2x2的二维数组转化为一个3xn的数组，如下表</p><p><img src="https://pic3.zhimg.com/v2-5ce4f464a99d3820ecb65f41214e7162_b.png" alt="img"></p><h3 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a><strong>应用需求</strong></h3><p>五子棋</p><h3 id="二维—-gt-稀疏"><a href="#二维—-gt-稀疏" class="headerlink" title="二维—&gt;稀疏"></a><strong>二维—&gt;稀疏</strong></h3><p> 1、遍历原始的二维数组，得到有效数据的个数sum</p><p>2、根据sum创建稀疏数组 sparseArr int[sum+1][3]</p><p>3、将二维数组的有效数据存入稀疏数组中</p><h3 id="稀疏—-gt-二维"><a href="#稀疏—-gt-二维" class="headerlink" title="稀疏—&gt;二维"></a><strong>稀疏—&gt;二维</strong></h3><p>1、先读取稀疏数组的第一行，根据得到的数据创建原始的二维数组，chessArr = int[row][col]</p><p>2、读区稀疏数组后几行的数据，并赋给原有的二维数组即可</p><p><strong>Java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个棋盘，0表示未落子，1表示黑子，2表示白子</span></span><br><span class="line">        <span class="keyword">int</span> chessArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">10</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row)&#123;</span><br><span class="line">                <span class="comment">//按十进制输出+tab</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="number">0</span>)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转稀疏 row为列 col为行</span></span><br><span class="line">        <span class="keyword">int</span> row = chessArr[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> col = chessArr.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;row=&quot;</span>+row+<span class="string">&quot;col=&quot;</span>+col);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = col;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = row;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;chessArr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;chessArr[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sparseArr[a][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[a][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[a][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row1 : sparseArr)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row1)&#123;</span><br><span class="line">                <span class="comment">//按十进制输出+tab</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//怎么遍历数组的行数与列数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   1   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   2   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   1   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">0   0   0   0   0   0   0   0   0   0   </span><br><span class="line">row=10col=11</span><br><span class="line">11  10  3   </span><br><span class="line">1   2   1   </span><br><span class="line">2   3   2   </span><br><span class="line">3   4   1   </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员眼中的《盗梦空间》</title>
      <link href="/post/f9f5e0c2.html"/>
      <url>/post/f9f5e0c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="不同人眼中的递归"><a href="#不同人眼中的递归" class="headerlink" title="不同人眼中的递归"></a>不同人眼中的递归</h2><p><img src="https://pic1.zhimg.com/v2-ea26b18aa92ebaea5ca0a495c2a070e4_b.png" alt="img"></p><p>你眼中的盗梦空间：不停做梦</p><p><img src="https://pic4.zhimg.com/v2-ad2cba93d842306485c59f1a48e8846b_b.png" alt="img"></p><p>程序员眼中的盗梦空间</p><h2 id="那什么是递归？"><a href="#那什么是递归？" class="headerlink" title="那什么是递归？"></a>那什么是递归？</h2><p><img src="https://pic3.zhimg.com/v2-1728f802af33e408bfec7a82ddc411c6_b.png" alt="img"></p><p><strong>自己调用自己</strong>，最简单的一个案例就是阶乘的问题</p><p>1! = 1 |  2! = 2x1 | 3! = 3x2x1 | =&gt; f(n) = n x f(n-1) 【当n=1结束】</p><h2 id="递归有三个需要知道"><a href="#递归有三个需要知道" class="headerlink" title="递归有三个需要知道"></a>递归有三个需要知道</h2><p>这个递归要做什么？</p><p>这个递归怎么结束？</p><p>当程序执行到一个方法时，就会开辟一个独立的空间（栈），而且其中变量互不影响</p><h2 id="《盗梦空间》场景重现"><a href="#《盗梦空间》场景重现" class="headerlink" title="《盗梦空间》场景重现"></a><strong>《盗梦空间》场景重现</strong></h2><p><strong>这个递归要做什么？</strong>=&gt; 盗梦空间中做了什么</p><p>其实做梦就是一个递归，如果睡觉/下药那么就会做梦</p><p>在梦中在睡觉/给下药 那么又做梦，目前是梦中梦</p><p>第三层在做梦，就是梦中梦中梦……</p><p>用程序可以这么表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dream</span><span class="params">(String action)</span> </span>&#123;</span><br><span class="line">    dream(<span class="string">&quot;做梦 / 下药 / 听音乐 / 猛烈撞击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会无限做梦，电影中到第五层之后人的脑子就已经不行了，会烧坏脑子，虽然程序比人脑强上不少，可以循环很多次，但架不住它快啊，烧的比人脑还要快，最终会导致栈溢出，程序停止</p><p><strong>所以结束条件就显得十分重要</strong>，先来看盗梦中是怎么结束的？</p><p><img src="https://pic2.zhimg.com/v2-3676e15a883bd9b564ace9115cc2b4a5_b.gif" alt="img"></p><p>听音乐/收到猛烈撞击 会醒过来，回到上一层梦境中，那么程序就变为了这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dream</span><span class="params">(String action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;听音乐&quot;</span>.equals(action) || <span class="string">&quot;猛烈撞击&quot;</span>.equals(action)) &#123;</span><br><span class="line">        <span class="comment">//返回上一层</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dream(<span class="string">&quot;做梦 / 下药 / 听音乐 / 猛烈撞击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会开辟一个独立的空间（栈）也好理解，没有做梦空间还怎么做梦？</p><p>方法局部的变量是独立的，不会相互影响。总不能第2层做梦会影响第一层的人（当然除了死掉，不过那个算结束条件）</p><h2 id="递归场景复现"><a href="#递归场景复现" class="headerlink" title="递归场景复现"></a>递归场景复现</h2><p>马踏棋盘问题—一个经典的回溯问题</p><p><img src="https://pic4.zhimg.com/v2-73040a1abca56c1e0103c5c2b315b117_b.png" alt="img"></p><p><strong>问题描述</strong></p><p>如果给定一个m x n的棋盘，在给定一个马儿棋子的初始位置，按照马走日的规则，如何可以在每个方格只进入一次的情况下，走完整个棋盘。</p><p>当然，存在棋盘或者有些起始点不能使马儿走完整个棋盘的情况。</p><p><strong>问题解析</strong></p><p>马儿在任意一个点，总是会有可走的选择，如果可以走的话，选取一个点走，走不通的话就返回上一步，重新考虑下一个点进行尝试</p><p><strong>Java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[][] act,<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将马儿当前位置置为已使用，记录当前步数</span></span><br><span class="line">    act[i][j] = step;</span><br><span class="line">    <span class="keyword">if</span> (step == act.length * act.length) &#123;</span><br><span class="line">        <span class="comment">//如果达到预定步数，则打印，并退出程序</span></span><br><span class="line">        print(act);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到可以落子的坐标集合</span></span><br><span class="line">    List&lt;Luozi&gt; ls = next(act, i, j);</span><br><span class="line">    <span class="keyword">for</span> (Luozi l : ls) &#123;</span><br><span class="line">        <span class="comment">//递归调用可用坐标</span></span><br><span class="line">        DFS(act,l.i,l.j,step+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有达到预定步数，将此点置为0，进行回溯</span></span><br><span class="line">    <span class="keyword">if</span> (step &lt; act.length * act.length) &#123;</span><br><span class="line">        act[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1981128172</span><br><span class="line">10271811229</span><br><span class="line">720930316</span><br><span class="line">263124153413</span><br><span class="line">2163532234</span><br><span class="line">36252251433</span><br></pre></td></tr></table></figure><p>以上只提供了核心方法，如需要，源代码请到git上查看：<a href="https://gitee.com/leidl97/algorithm-src">leidl97/algorithm-src</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员必备的软技能</title>
      <link href="/post/f7500981.html"/>
      <url>/post/f7500981.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic1.zhimg.com/v2-b36bacb948002cf8c6d91ccee37fd1bc_b.jpg" alt="img"></p><h2 id="怎么知道这本书的"><a href="#怎么知道这本书的" class="headerlink" title="怎么知道这本书的"></a>怎么知道这本书的</h2><p>有一天逛博客的时候看到别人推荐，正好想入手两本书了，又不想对一堆技术书。简单的看了下，觉得挺不错，果断入手！</p><h2 id="这本书怎么样"><a href="#这本书怎么样" class="headerlink" title="这本书怎么样"></a>这本书怎么样</h2><p>作者是老美，是个程序员。说的大部分还是能感同身受的。整体来说是一本好书，值得程序员一看。</p><h2 id="这书讲的什么"><a href="#这书讲的什么" class="headerlink" title="这书讲的什么"></a>这书讲的什么</h2><p>提到了一个程序员除了技术之外哪些技能是比较重要的。比如自我营销，理财，健身，职场道理，生产力之类的。看个目录基本也就知道需要培养哪些能力了。</p><h2 id="重点环节"><a href="#重点环节" class="headerlink" title="重点环节"></a>重点环节</h2><p>接下来就来聊一聊这本书传达的一些观点</p><blockquote><p>给老板打工，不如当作为自己打工</p></blockquote><p>工作是属于公司的，职业生涯是你的。干久了，你就是再走公司的路，离了公司，屁也不是。所以每天不要只放眼于工作内容。不干点自己的事，永远都在为公司打工。每个程序员都得有自己的规划，往后不一定是程序员，你需要考虑如何才能实现自己的价值</p><blockquote><p>设定一个目标，将目标分解为可达目标，完成后激励自己</p></blockquote><p><img src="https://pic1.zhimg.com/v2-d0798f5c6f691feef4f90078c497409c_b.jpg" alt="img"></p><p>从小这个道理我就知道了，葫芦娃不能白看，一座大山怎么搞，一个个切下来消灭呗。激励这个因人而异，我认为将小任务完成后成就感就可以满足我</p><blockquote><p>给予尊重，学会聆听，换位思考，控制情绪</p></blockquote><p>有点鸡汤了，不过是职场必备，尤其要学会控制你的情绪，没人惯着你，大家都很忙，当你不知道应该怎么做的时候，沉默也是一个很不错的选择</p><blockquote><p>远离毒瘤</p></blockquote><p>你有时候会发现，有的人他就是难以相处，有的人就是喜欢抓住机会去恶心别人，对生活总是悲观的。那么建议你远离他们。不要试图改变他们，也不要和这些人融入。人是会受环境影响的。但如果有些时候不得不面对，要么逆来顺受，要么去别的部门或者换工作。不要抱怨！真的是百害无一利，你会比祥林嫂还惨。</p><blockquote><p>圈子不同，不必强融</p></blockquote><p>有的人你会发现他们很优秀，有的人性格很不错，但确实走不到一块，那也不要勉强，也不要刻意去迎合他们。</p><blockquote><p>不要做无意义的事情</p></blockquote><p>作者的观点是不要看电视（2012年）映射到咱们这个时代就是不要玩手机。这听起来有点扯，或许是不要刷抖音，微博这些消磨时间的软件。工具没有好坏，只是不同的人发挥的用处也会不同，有很多人建议什么不要刷抖音，快手的，我反而认为没必要戒掉，你也不会去戒。我本人不玩抖音，微博。只是觉得给我有价值的东西并不多，因为我这两个都用过。我更愿意接触一些有价值的东西。哪怕不是在学习，看一看生活常识，纪录片，理财之类的，都会比鹅叫强。</p><blockquote><p>面试内推是很重要的</p></blockquote><p>按照作者观点来说，内推会比社招更容易的多，而且一些岗位也会越好。本人只经历过校招，没有切身经历的也就不乱说了。</p><blockquote><p>专业化很重要，不要都会一点点。先专业，在拓展分支</p></blockquote><p>这个我很赞成，刚从大学买入职场我想很多一批人会迷惑，不知道将来应该怎么走，怎么规划，我真的是不想当一辈子程序员，也不想只局限于一种技术，或者一种语言，但又怕都会一点，又都不精。作者一席话让我茅塞顿开，我也是很认同。</p><p>初为职场人，应当将你所在的领域专业化。之后在拓展分支。“但值得注意的是，专业程度越深，潜在的机会就会越少，但获得机会的可能性越大。”作者这个意思就是尽管专业化不要怕，现在猎头那么多，你是块儿料，都抢着要你。正如《天下无贼》的一幕</p><p><img src="https://pic3.zhimg.com/v2-330a322879473c2fecf41bec5efafa86_b.png" alt="img"></p><blockquote><p>不要和我杠，你杠就是你对</p></blockquote><p>有的人总是会被别人左右，总是情绪化，比如自己很努力写的一篇文章被人质疑诋毁了，自己的一篇干货文章，硬说为带货文章。自己做的一件事不能被别人理解，还要遭人冷嘲热讽等等。如果你总是第一时间找这些人理论，解释自己是对的。那么这一步你就已经走错了，有句话叫不做亏心事，不怕鬼上身。群众的眼睛是雪亮的，不需要你去站出来。而且他们本身就是挑事的，你认真起来不正中下怀了吗。事后输赢重要吗，自己时间也浪费了，心情也破坏了，那时候你真的吃了一碗凉粉还重要吗。所以要佛系，他们杠就是他们对，认真你就输了</p><p><img src="https://pic1.zhimg.com/v2-5ef1b0632686c6d86e8b61716fed5498_b.png" alt="img"></p><blockquote><p>让老板或直系领导知道你在做什么</p></blockquote><p>到职场之后最大的转变就是学生时代会有作业，老师会定期查看你的成果。但职场不会，如果你一直默默无闻，领导很难知道你做了什么，这样几年下来，你始终是一个乖孩子，永远不会得到成长</p><blockquote><p>要讲玛德，要有底线</p></blockquote><p>作为一名程序员，技术和道德两方面都得有。作者举得例子过于抽象。总体来说就是要<strong>坚守正道!</strong></p><p>一个人要有底线，一个程序员也应该有底线。技术本无罪，代码要用到合适的地方，往大了说不能损害国家利益，损害社会，损害公司。往小了说不能影响他人，比如说你窃取女同事的电脑摄像头权限，晚上xx（此处省略一万个字）</p><p><img src="https://pic3.zhimg.com/v2-c8bdc1964e1894d786c9979411d0f3be_b.png" alt="img"></p><blockquote><p>已结果为导向，过程是给你看的</p></blockquote><p>很多时候结果才是重要的，不要讲什么努力，那只能证明你不行，比如一个需求，人家三天，你一个礼拜，明明很努力了啊，为什么还是不行。这时候你应该好好反思自己，怎么样提高自己的效率。职场只有功劳，没有苦劳。当然过程有时候还是很重要的哈，不能一刀切。你看人家老王咋30分钟，你咋只有3分钟。</p><blockquote><p>不局限于一种技术，而不是技术不重要</p></blockquote><p>作者说不要把自己一个“C 工程师”或者“java 工程师”。这样太局限了。</p><p>当然我听过Java工程师，但没听过Java架构师。没有哪一种语言是最强的，当然除了PHP［doge］。应该让自己专注于一个领域，我目前是做企业级应用开发，涉及的技术很广泛，并不只会一门Java就可以做好的。技术始终服务于业务。价值从哪里产出的，就是业务。让自己成为这行的专家，找工作困难？不存在的。</p><blockquote><p>你多牛并不重要，重要的是让别人知道你有多牛</p></blockquote><p>这就是作者所说的自我营销，你需要在行业中有影响力，有的人说金子总会发光的，你看人家诸葛亮，藏深山老林里不也被发现了吗。那是你只知其一不只其二。诸葛亮没有自我营销？那你就大错特错了。诸葛亮其实是一个很能炒作的家伙。先说人脉：结识徐庶，凤雏等牛人一起拜水镜先生为师，娶了极丑的黄月英，虽丑但多才多艺，从老婆身上也学到不少东西，比如木牛流马。她爹还是当地名士，圈中大佬，事业上得到了很大的帮助。哥哥诸葛瑾在孙权那做官。诸葛还很有才，自比管仲乐毅。但别人还是一句“时人莫之许也”。就是别人都觉得在吹牛，只有自己的好朋友崔周平和徐庶知道真的有才。这哪能行，所以诸葛好穷游，知天下事，识天下人，使自己成为大V，静待伯乐到来。所以真么牛的人还得需要自我营销才能进大厂，你认为你不需要吗？</p><blockquote><p>无论在职业生涯的哪个阶段，都要会营销自己</p></blockquote><p>紧接着作者阐述这个，无论你是刚入职场还是好几年了，都需要营销自己。有的人会说，我就是很菜啊，没有东西可让别人看，也不会营销自己。我也是刚入职场一年。写的文章没什么没人阅读。我就当给自己写了，我每篇也都在用心去写。好酒不怕巷深。相信终究会有量变引起质变的一天！</p><blockquote><p>多写文章，参与开源项目，最好共用一个昵称</p></blockquote><p>这个是怎么营销。上面是我总结适合咱们的，开源项目水平不够的话，可以等机会。主要是多写文章，以别人看懂为目的。最好共用一个昵称。李白也只有太白一个字，辨识度很重要。一说鲁迅那就是周树人，还能是谁？</p><p><img src="https://pic2.zhimg.com/v2-d2648ba06105a68c94de42aad50615d9_b.png" alt="img"></p><blockquote><p>搭建blog费时费力，应当讲精力放在写文章上</p></blockquote><p>我也搭建过自己的博客，费时费力的，后端，前端，编辑器，写出来还得租服务器，这样你文章的曝光度也非常低，而搭建一个blog是一个很苦逼的过程，大学可以试试，我也是在大学搞的。工作后就不建议了，直接在热度高的平台注册一个账号就可以写了，还是应该把精力放在写文章上。</p><blockquote><p>把你的成果的90%都做成免费的，你可把他视为对未来的投资</p></blockquote><p>这个应该不用过多解释，你就是收钱也没人看啊。拼夕夕起家的时候不也是到处砸钱，到处找人砍吗？pei！一说就来气，不把员工当人啊。</p><blockquote><p>尝试在公开场合讲话</p></blockquote><p>我以前也不敢，现在皮的很。那都是练出来的。</p><p>只要我不要脸，就不会不好意思。只要我不尴尬，尴尬的就是别人。</p><p><img src="https://pic3.zhimg.com/v2-add49c32ab9687bf60016a5e67a0f67e_b.png" alt="img"></p><blockquote><p>写书的目的不是为了赚钱，而是名誉</p></blockquote><p>就算你是为了赚钱，那也赚不了啊，钱不是那么好挣的。确实一本好书会让你很有影响力</p><p><img src="https://pic3.zhimg.com/v2-624f648e971df474a7eecbdb960625e2_b.png" alt="img"></p><blockquote><p>写的烂也要写，不写水平就不会提高</p></blockquote><p>出书需要高水平，写文章不用啊，烂不怕，怕你不写，除了爱新觉罗·弘历之外，没人会越写越烂</p><blockquote><p>孰能生巧，越做越好</p></blockquote><p>不要天马行空，今天想做这，明天想干那。前期就是需要不断重复，代码不敲只看是肯定学不会的。干IT，注苦逼，需要有很强的自学能力和进行不断的学习</p><blockquote><p>学位不是必要的，但是却是重要的</p></blockquote><p>同样面试一家企业，有学位你只需要达到70%，没有你需要达到100%</p><blockquote><p>找出短板，消除短板</p></blockquote><p>人最怕的就是自作聪明，不懂装懂。</p><p>坑现在不踩，以后还会踩得，以后摔一跤不一定能爬起来，所以吃亏要趁早，而且要会吃亏，吃亏不是福，会吃才是福。</p><blockquote><p>专注</p></blockquote><p>作者阐述了专注的一堆好处，什么效率更高之类的。在我看来最实用的就是可以让时间过的更快。看眼时间，已经能下班打卡了。</p><blockquote><p>学会理财</p></blockquote><p>理财重要吗，现在一大堆人都在讲。你想一个问题就知道了，以前有一万块叫万元户，现在家家都是万元户。</p><p>钱是会一直贬值的，所以如何打理是值得学习的，起码你需要学会如何跑赢通货膨胀，其实我希望我未来的老婆能会理财，那多幸福啊</p><blockquote><p>学会健身</p></blockquote><p>身体不好，就会容易手抖，手抖就容易发错几个字。含泪变为临时工，被公司一脚踢开。</p><p>有条件办个健身卡，但是你得去！</p><p>没条件的总之能跑着就不要骑车，能骑车就不要走着，能走着就不要一直坐着。</p><blockquote><p>学会拥抱失败</p></blockquote><p>谁没有过失败，还是谁又能不失败，凭借的就是谁能在无数的失败中站起来！</p><p><img src="https://pic1.zhimg.com/v2-baf534412fa4e0baef801632a91fa93c_b.png" alt="img"></p><h2 id="最后说一说"><a href="#最后说一说" class="headerlink" title="最后说一说"></a>最后说一说</h2><p>有条件的还是希望看看原著，支持正版！</p><p>一千个读者就有一千个哈姆雷特。</p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人见解 </tag>
            
            <tag> 软技能 </tag>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端程序员应该对vue了解多少</title>
      <link href="/post/ad27c5a8.html"/>
      <url>/post/ad27c5a8.html</url>
      
        <content type="html"><![CDATA[<h2 id="我与vue的相遇"><a href="#我与vue的相遇" class="headerlink" title="我与vue的相遇"></a>我与vue的相遇</h2><p>按理来说，我一个搞后端的应该是碰不到这玩意儿的，但缘分到了挡都挡不住，目前碰了两次，第一次是在我个人毕设中，第二次是公司项目。</p><p>说说第一次吧，当时毕设是spring+bootstrap+vue实现的。当时前端也没用到复杂的东西，比如webpack和vue-cli这些，这次公司项目中接触到vue，看见一些脚手架之类的东西，认为还是有必要看一下的，在之前到公司之前也就零零碎碎开始了解了。借此机会整理有关vue的内容，而且我感觉前端比后端有意思多了，js指不定就是我的第二语言</p><h2 id="这篇文章的意义"><a href="#这篇文章的意义" class="headerlink" title="这篇文章的意义"></a>这篇文章的意义</h2><p>看完这篇文章你将收获身为后端的我们应该掌握哪些内容，为什么这些内容是重要的，去哪学，怎么学效率高。但经验总是别人的，如果你想真正学会什么东西，还需要静下心来学习，从来没有可以速成的东西，学习是一种不断的积累。</p><h2 id="前言酸溜溜不如看正文"><a href="#前言酸溜溜不如看正文" class="headerlink" title="前言酸溜溜不如看正文"></a>前言酸溜溜不如看正文</h2><p>vue是一个前端框架，类似Java中的spring框架。</p><p>回到主题，我当时学习spring框架的时候首先是系统性的学习了一遍，在之后就是利用spring框架独立搞了几个项目出来。也算是spring框架的入门了。不过也花费了不少时间，对于时间紧张的打工人来说，作为一个后端不可能跟spring一样系统性的学一遍。但也不能不学，真指望用jq行走天下吗？<br><strong>但咱搞后端的凭什么要明白前端框架？</strong>其实干IT这行也没必要分那么清，就算你现在完全不碰前端，也不保证以后不碰吧，<strong>干IT的能挣得了高薪，还得耐得住寂寞</strong>，如果你能保证你往后的每份工作不接触前端，那么可以不用去了解前端。否则，前端是非常有必要接触的。</p><p>对于目前的主流框架而言，分别是Vue、React、angular。很多大厂都在用React，但门槛较高，不用说搞后端的了，就算专门搞前端的也得掂量掂量。Vue最常用也是最容易入门的一套框架。他降低了前端的门槛。而且作者<a href="https://baike.baidu.com/item/%E5%B0%A4%E9%9B%A8%E6%BA%AA/2281470?fr=aladdin">尤雨溪</a>是国人，文档很友好，而且写的也很细。Vue无疑是前端中最香的。可以这么说后端学前端vue必会（前提具备前端三剑客的知识）</p><h2 id="后端程序员学到什么程度？"><a href="#后端程序员学到什么程度？" class="headerlink" title="后端程序员学到什么程度？"></a>后端程序员学到什么程度？</h2><p>这个就是接下来的问题了，关于这个问题网上给出的并不多，有也说不到点儿上。当然任何知识都是掌握越多越好</p><ul><li>起码vue的代码到我手里我能看懂。这个类似于看外语，每个词儿你得知道什么意思。</li><li>不研究前端八股文，可以利用vue+element-ui快速构建一个项目</li><li>熟悉掌握一些项目中常用技术比如双向绑定，事件调用，接口联调那些</li><li>理解组件化开发，前端模块化，webpack，vue-cli，vite等知识</li><li>项目可以直接下开源的学习，不必从0到1构建。但你要门清，比如项目结构，组件通信，方法调用等</li></ul><h2 id="为什么学vue，jq不香吗？"><a href="#为什么学vue，jq不香吗？" class="headerlink" title="为什么学vue，jq不香吗？"></a>为什么学vue，jq不香吗？</h2><p>我是从远古时代过来的，js学到jq再到vue，当时vue还没有模块化的概念，直接引入一个vue.js开发。可以这么说，jq是真的不香。</p><ul><li>vue的最大特点：<strong>数据和页面解耦。</strong>你能想象jq的$冲突是什么感觉吗，还查不出原因呢的那种。反正企业项目开发我是遇到过，我当时引入JQuery使用AJAX出现了$冲突的情况，那么多的代码根本也找不出冲突的点，也不知道冲突的原因，虽然最后通过换命名解决，但处理这种问题也会降低工作效率。</li><li>jq很杂，似乎什么都有，而vue给你一套全家桶，用什么拿什么，各司其职。</li><li>vue的目的是让你舍弃dom操作，转为数据操作。jq通常指定事件需要一个选择器，获取dom元素，在给予其行为，这本来不应该是程序员应该关心的</li><li>这里不是说vue和jq水火不容，也可以一块去使用，jq样式效果和动画效果还是很出色的，要根据具体场景去完成业务需求</li></ul><h2 id="我没有用vue做过项目，怎么学效率高？"><a href="#我没有用vue做过项目，怎么学效率高？" class="headerlink" title="我没有用vue做过项目，怎么学效率高？"></a>我没有用vue做过项目，怎么学效率高？</h2><p>很多人都是认可在项目中学习，你没做过，没关系，我做过呀。所以我也会告诉你vue需要学的一些核心东西，我建议系统性的学习下，我是通过看<a href="https://v3.cn.vuejs.org/">官方文档</a>和<a href="https://www.bilibili.com/video/BV1zq4y1p7ga">b站视频</a>学习的，一共500多集，内容为vue2+vue3，之前我看了一套200集视频感觉没学下什么，又学了一套。这套我觉得还不错，推荐给你们。只是在vue3重复的内容还是有点多。最后利用我学的一点知识也是帮我司写了一个小模块出来，感觉还是有成就感。 </p><h2 id="vue项目核心技术有哪些？"><a href="#vue项目核心技术有哪些？" class="headerlink" title="vue项目核心技术有哪些？"></a>vue项目核心技术有哪些？</h2><p>我最初使用springboot+vue做了一个在线看小说的系统，前端用的bootstrap+vue（当时只单纯的将vue替换jq去使用了）</p><p>这个项目vue主要比较多的就是双向绑定、axios异步获取数据、将数据遍历展现到页面、事件的绑定与监听，对我毕设来说足够了实现了</p><p>我现在写的项目中涉及的很全，不在局限于简单的拖拉拽。可谓是真正的模块化与工程化开发，和用spring写后端差不多</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>后面的就是一些关键知识点了，零散的知识点会单独开一篇文章放进去</p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>不同于早两年的拖拉拽，前端也逐渐站了起来，各大企业也在重视前端人员，离不开的原因之一就是前端跟后端一样也实现了工程化</p><p>好处：自成体系，提高开发效率，降低技术选型，前后端联调带来的沟通成本。</p><p>说人话：有人帮你把能做的都做了，只要按照约定进行配置，按照给定语法进行开发即可</p><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>如果我们面对复杂问题的时候，通常的处理方式：</p><ol><li>任何人的处理信息逻辑的能力都是有限的，所以在面临非常复杂的问题的时候，不太可能搞定 </li><li>人天生有一种能力就是将问题去拆分，在项目管理中WBS是一个重要的内容。思想其实是一致的。那就是将一个复杂的问题，拆分成很多小问题去处理，那么再大的问题只要分的足够细化，也就迎刃而解了</li></ol><p>组件化也是类似的思想</p><ol><li>如果将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得十分复杂，jsp中不仅包括Java代码和html代码，还包括css样式，js函数，都在一个页面，找起来麻烦，代码观赏性也不佳。非常不利于后续的管理和扩展</li><li>如果能将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么后续的管理与维护就非常容易了</li></ol><h2 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么"></a>vue是什么</h2><p>构架用户界面的一个前端框架，后端的spring</p><h2 id="有啥优点"><a href="#有啥优点" class="headerlink" title="有啥优点"></a>有啥优点</h2><ul><li>渲染页面结构更加方便（数据驱动视图）</li><li>提供独特的书简绑定机制，轻松处理交互行为</li><li>工作重心转移，不在放在处理DOM上</li></ul><h2 id="vue2与vue3"><a href="#vue2与vue3" class="headerlink" title="vue2与vue3"></a>vue2与vue3</h2><ul><li>vue2是比较经典的一个版本，也是企业用的版本，所以企业开发还是需要学习vue2的知识</li><li>vue3是2020年9月18日发布的，有较大的更新，可以说在近两年企业还是会以2为主，然后向3转移，现在学3刚刚好</li></ul><h2 id="vue全家桶"><a href="#vue全家桶" class="headerlink" title="vue全家桶"></a>vue全家桶</h2><ul><li>vue（核心库）</li><li>vue-router（路由）</li><li>vuex（状态管理）</li><li>vue组件库（快速搭建UI效果的方案）</li></ul><h2 id="vue特性"><a href="#vue特性" class="headerlink" title="vue特性"></a>vue特性</h2><ul><li>数据驱动视图（单向数据绑定）<br>vue起到了监听数据变化的作用，数据的变化会驱动视图自动更新<br><img src="https://image.leidl.top/img/image-20210823192330191.png" alt="image-20210823192330191"></li><li>双向数据绑定<br>辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中<br><img src="https://image.leidl.top/img/image-20210823192802732.png" alt="image-20210823192802732"></li></ul><h3 id="M-V-VM"><a href="#M-V-VM" class="headerlink" title="M-V-VM"></a>M-V-VM</h3><p>Model-View-ViewModel,M表示抽离出的obj(new Vue)、V表示DOM(html + css)、VM表示监听M修改V，是双向绑定的要点。来一张经典图<br><img src="https://image.leidl.top/img/image-20210823193148997.png" alt="image-20210823193148997"><br>工作原理<br><img src="https://image.leidl.top/img/20210906164344.png" alt="image-20210906164344403"></p><h2 id="MVVM怎么工作的？（了解）"><a href="#MVVM怎么工作的？（了解）" class="headerlink" title="MVVM怎么工作的？（了解）"></a>MVVM怎么工作的？（了解）</h2><p>ViewModel通过bind让obj中的dom能够实时显示，在通过listener监听dom事件，通过method来修改数据 <strong>说白了也就是监听+绑定实现的</strong></p><h2 id="vue经典结构"><a href="#vue经典结构" class="headerlink" title="vue经典结构"></a>vue经典结构</h2><p><code>el</code>：类型string，决定你管理哪一块dom，这也是vue的一个优势点，整个代码按块管互不影响。</p><p><code>data</code>：类型object，vue中需要存放的数据对象，这里可以存放的对象类型也是比较丰富的</p><p><code>method</code>：类型function，定义一些方法，可以指令调用，也可以在其他地方调用</p><p><img src="https://image.leidl.top/img/image-20210823194447037.png" alt="image-20210823194447037"></p><h2 id="下面是在我学习过程中的总结，我认为所需要知道的知识点，另外放了一篇文章"><a href="#下面是在我学习过程中的总结，我认为所需要知道的知识点，另外放了一篇文章" class="headerlink" title="下面是在我学习过程中的总结，我认为所需要知道的知识点，另外放了一篇文章"></a>下面是在我学习过程中的总结，我认为所需要知道的知识点，另外放了一篇文章</h2><p><a href="https://leidl.top/post/3f6c447b">后端的vue笔记</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这只是个开始，纸上得来终觉浅。利用项目学习，从项目中学，学之于项目，我立志于当一名全干攻城狮，只想拥有更加广阔的视野</p>]]></content>
      
      
      <categories>
          
          <category> IT碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 个人见解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之spring</title>
      <link href="/post/ceb39ac4.html"/>
      <url>/post/ceb39ac4.html</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈你对spring的理解"><a href="#谈谈你对spring的理解" class="headerlink" title="谈谈你对spring的理解"></a>谈谈你对spring的理解</h1><ul><li>是一个轻量级框架，解决企业开发的问题，使开发者可以更加专注于开发</li><li>他提供了很多功能，底层依赖于两个特性，DI（Dependency Injection）和AOP（Aspect-Oriented Programming）</li><li>IOC控制反转，指对象的调用权由开发者转为Spring容器，负责对象的所有生命周期（创建，管理等）</li><li>为什么需要IOC？最重要的就是解耦。</li><li>如何实现？工厂 + 反射</li><li>IOC是设计理念，DI是实现方式。有接口注入，setter注入和构造器注入</li><li>AOP的出现解决了代码重复的问题，并进行了解耦</li><li>AOP作为OO（面向对象）的一种补充，常用与业务行为无关，对公共逻辑进行封装，并命名为切面（Aspect）。常用于日志，权限认证和事务处理等</li></ul><h1 id="谈谈spring的IOC"><a href="#谈谈spring的IOC" class="headerlink" title="谈谈spring的IOC"></a>谈谈spring的IOC</h1><p>IOC就是控制反转，指对象的管理权由程序员变为spring管理，用来解决<code>对象管理和依赖</code>的问题</p><p>IOC可以理解为一个对象工厂，控制反转是一种思想，而依赖注入就是实现方式了，最大的好处就降低耦合度</p><p>在注入一个对象时，很可能不是原本的对象而是代理对象（使用到了AOP）</p><h1 id="谈谈spirng的AOP"><a href="#谈谈spirng的AOP" class="headerlink" title="谈谈spirng的AOP"></a>谈谈spirng的AOP</h1><p>AOP面向切面编程，解决非业务代码的抽取问题，常用于日志，事务处理，权限控制等，减少系统重复代码，降低耦合度，提供拓展性和可维护性</p><p>在spring中实现依赖是后置处理器（BeanPostProcessor）</p><p>底层利用动态代理实现，如果代理的对象实现了某个接口，那么就会使用jdk代理，否则使用cglib代理</p><p>AOP如何进行切入的，通过beanPostProcessor后置器类来干预</p><h1 id="谈谈spring的生命周期"><a href="#谈谈spring的生命周期" class="headerlink" title="谈谈spring的生命周期"></a>谈谈spring的生命周期</h1><p>一般对象生命周期：java -&gt; class -&gt; 加载到JVM中 -&gt; 提供使用</p><p>spring：实例化Bean -&gt; 设置属性 -&gt; BeanPostProcessor前置处理 -&gt; init -&gt; 后置处理 -&gt; 使用 -&gt; destroy</p><h1 id="spring如何解决循环依赖"><a href="#spring如何解决循环依赖" class="headerlink" title="spring如何解决循环依赖"></a>spring如何解决循环依赖</h1><p>比如A依赖B，B依赖A。<br>实例化A，发现依赖B，转头去实例化B，B发现需要A，但A已经实例化了，B完成创建，返回到A中，A完成创建</p><h1 id="spring分为了多少个模块，或者说能干什么？"><a href="#spring分为了多少个模块，或者说能干什么？" class="headerlink" title="spring分为了多少个模块，或者说能干什么？"></a>spring分为了多少个模块，或者说能干什么？</h1><p>图片详细见spring.io</p><ul><li>spring core：框架核心部分，包括IOC（Inversion of Control）和DI</li></ul><h1 id="spring中使用了哪些设计模式？"><a href="#spring中使用了哪些设计模式？" class="headerlink" title="spring中使用了哪些设计模式？"></a>spring中使用了哪些设计模式？</h1><ul><li>工厂：beanFactory</li><li>单例：默认为单例模式</li><li>代理：AOP用到了JDK代理和CGLIB代理</li><li>模版：比如RestTemplate，JpaTemplate等，解决重复代码问题</li><li>观察者：各种监听器</li><li>适配器：SpringMVC过程</li></ul><h1 id="谈谈-Transactional注解"><a href="#谈谈-Transactional注解" class="headerlink" title="谈谈@Transactional注解"></a>谈谈@Transactional注解</h1><ul><li>事务分为编程式事务（手动提交回滚，侵入性强）和声明式事务（AOP）</li><li>只对public起效，由springAOP决定的，拦截处理，可能影响性能</li><li>基于spring的AOP机制</li></ul><h2 id="隔离级别—4种"><a href="#隔离级别—4种" class="headerlink" title="隔离级别—4种"></a>隔离级别—4种</h2><p>指若干个并发事务的隔离程度—从前往后没</p><ul><li>读取未提交（会出现脏读、不可复读）—基本不使用</li><li>读取已提交（会出现不可复读和幻读）</li><li>可重复读（会出现幻读）—默认级别</li><li>串行化</li></ul><h2 id="事务的传播—7种"><a href="#事务的传播—7种" class="headerlink" title="事务的传播—7种"></a>事务的传播—7种</h2><p>如果在事务开始前，一个事务已经存在，此时可以指定该事务的行为</p><ul><li>PROPAGATION_REQUIRED 如果存在事务，则加入该事务，如果没有，则新建一个。—默认值</li><li>PROPAGATION_REQUIRES_NEW 创建一个新的，如果有事务，则把当前事务挂起</li><li>PROPAGATION_SUPPORTS 如果存在事务，则加入该事务，如果没有则以非事务的方式继续</li><li>PROPAGATION_NOT_SUPPORT 不用事务，如果当前有，则挂起</li><li>PROPAGATION_NERVER 不用事务，有事务就抛异常</li><li>PROPAGATION_MANDATORY 如果有则加入，没有就抛异常</li><li>PROPAGATION_NESTED 如果有就嵌套一个，没有则创建一个</li></ul><h2 id="Transactional的失效场景"><a href="#Transactional的失效场景" class="headerlink" title="Transactional的失效场景"></a>Transactional的失效场景</h2><ul><li>作用在非public方法上</li><li>注解的propagation设置错误（support，notsupport，nerver）</li><li>rollbackfor设置错误（指定回滚类型）比如自己设置的异常不会回滚</li><li>本类方法进行了调用，A没有事务注解，B有，A调用了B，外部方法调用了A（与传播机制有关）</li><li>自己在方法内catch了异常</li><li>数据库引擎不支持事务</li></ul><h1 id="谈谈对springMVC的理解"><a href="#谈谈对springMVC的理解" class="headerlink" title="谈谈对springMVC的理解"></a>谈谈对springMVC的理解</h1><p>对servlet进行了封装，屏蔽掉很多的细节。mvc的一个过程<br><img src="https://image.leidl.top/img/20211011184813.jpg" alt="20211011184813"></p><ol><li>用户发送请求给DispatcherServlet</li><li>向HandlerMapping索要对应的请求处理器</li><li>HandlerMapping返回给相应的处理器</li><li>DispatcherServlet给HandlerAdpater传入一个handler</li><li>适配器返回一个能够处理该请求的适配器</li><li>利用该适配器去处理并得到ModelAndView视图对象</li><li>返回给DispatcherServlet视图对象</li><li>使用ViewRouter进行视图解析</li><li>ViewRouter返回给view对象</li><li>DispatcherServlet渲染视图，将视图呈现给用户</li></ol><h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>CLASS定义了这个类有哪些属性方法，但没有定义如何实例化这个bean，比如是否单例，是否延迟加载，调用哪个初始化/销毁方法</p><h1 id="spring如何处理线程并发问题？"><a href="#spring如何处理线程并发问题？" class="headerlink" title="spring如何处理线程并发问题？"></a>spring如何处理线程并发问题？</h1><p>一般情况下，只有无状态的bean才可以在多线程环境下共享，在spring中，绝大部分bean都可以声明为singleton（单例）作用域，因为spring对一些bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p><code>ThreadLocal</code>和<code>线程同步机制</code>都是为了解决多线程中共享变量的访问冲突问题。同步机制采用了时间换空间的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的则需要进行排队。、</p><p>而ThreadLocal采用了空间换时间的方式ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程编码时，可以把不安全的变量封装进ThreadLocal中</p><h1 id="能讲讲spring的生命周期吗"><a href="#能讲讲spring的生命周期吗" class="headerlink" title="能讲讲spring的生命周期吗"></a>能讲讲spring的生命周期吗</h1><p>一般对象的生命周期：new创建 — JVM回收</p><p>spirng的生命周期如下图</p><p><img src="https://image.leidl.top/img/202112271151479.webp" alt="springbean"></p><p><code>容器创建过程描述</code></p><ol><li>spring对bean进行实例化</li><li>将值和引用注入到bean所对应的属性中</li><li>Spring将bean的ID传递给setBean-Name()</li><li>如果bean实现了BeanFactoryAware接口，将调用setBeanFactory()</li><li>调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来</li><li>调用它们的post-ProcessBeforeInitialization()方法</li><li>调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁</li><li>调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li></ol><h1 id="谈谈对springboot的理解"><a href="#谈谈对springboot的理解" class="headerlink" title="谈谈对springboot的理解"></a>谈谈对springboot的理解</h1><ul><li>是spring组件一站式解决方案</li><li>简化spring的难度</li><li>简化繁杂的配置，采用自动配置，便于开发</li></ul><h1 id="谈谈springboot自动配置原理"><a href="#谈谈springboot自动配置原理" class="headerlink" title="谈谈springboot自动配置原理"></a>谈谈springboot自动配置原理</h1><p><a href="https://leidl.top/post/524e74d7.html">空降地址</a></p><p>springbootapplication = springbootconfiguration + commentscan + enableautoconfiguration</p><p>enableautoconfiguration = import + autoconfigurationpackage</p><p>刷新IOC容器，调用getImports方法，将import注解中的组件进行实例化</p><h1 id="谈谈开发中常用的-Autowired是怎么发挥作用的"><a href="#谈谈开发中常用的-Autowired是怎么发挥作用的" class="headerlink" title="谈谈开发中常用的@Autowired是怎么发挥作用的"></a>谈谈开发中常用的@Autowired是怎么发挥作用的</h1><p>可以见<a href="https://leidl.top/post/8e4fa41e.html">这篇文章</a></p><h1 id="知道-Autowired和-Resource之间的区别吗？"><a href="#知道-Autowired和-Resource之间的区别吗？" class="headerlink" title="知道@Autowired和@Resource之间的区别吗？"></a>知道@Autowired和@Resource之间的区别吗？</h1><ul><li>@Autowired是spring提供的，@Resource是Java提供的</li><li>@Autowired按类型装配，@Resource按名称装配</li></ul><p>谈谈对springcloud的理解</p><blockquote><p>为什么会出现？<br>不管商业还是用户，在业务初期都很简单，我们通常会将他们实现为单体应用。随着业务的逐渐发展，产品也会越来越复杂，单体结构也会越来越复杂，会带来很多问题比如<br>代码结构混乱（代码多了），导致管理困难<br>开发困难，开发人员需要不断解决冲突问题，降低开发效率<br>排查成本高，修bug上线，需要重新编译打包，成本很高<br>等等的问题表示单体结构逐渐不适应开发，微服务架构逐渐开始取代单体架构，而springcloud是目前最常用的微服务架构框架，已经在企业级开发中大量应用<br>什么是springcloud？<br>是一个框架的集合，简化了分布式系统基础设施的开发。有<br>注册中心，配置中心，路由，服务调用，熔断器等，都可以利用springboot风格做到一键启动和部署<br>目标：<code>协调各个微服务，简化分布式系统开发</code></p></blockquote><p>spring推出的一套微服务解决方案，对其中出现的基础场景做出了规范。在这套标准中，spring集成了了Netflix公司的OSS开源套件，比如Eureka、Zuul（网关）、Ribbon（负载均衡）、Hystrix（服务熔断），但随着OSS的停止维护，spring官方也自研了一些组件，另外阿里也整合了spring的标准同时加入自身技术，成了另一套解决方案spring cloud alibaba，其中包括dubbo（RPC通信）、Nacos（注册中心）、sentinel（降级限流）等等</p><h1 id="各个组件及其作用"><a href="#各个组件及其作用" class="headerlink" title="各个组件及其作用"></a>各个组件及其作用</h1><p>注册中心</p><ul><li>用来监控各个微服务是否能正常运行</li><li>奈飞的Eureka，阿里巴巴的Nacos</li><li>自我保护机制：server在一定时间没有收到client的心跳便会提出服务，如果丢失了大量的心态，就会进入自我保护机制，因为可能出现了网络延迟问题，客户端还正常</li></ul><p>服务调用</p><ul><li>feign：在此实现下，只需创建一个接口并使用注解来配置即可（内置ribbon）</li><li>openFeign：在feign基础上支持SpringMVC的注解，通过动态代理实现负载均衡调用其他服务</li><li>ribbon：客户端的负载均衡工具</li></ul><p>服务降级</p><ul><li>服务雪崩：微服务调用时间长或不可用，会引起系统崩溃，如果还调用了别的模块，就会发生级联故障，或者叫雪崩</li><li>Hystrix：降级熔断限流，向调用方返回一个符合预期，可处理的备选响应，而不是长时间的等待或抛出无法处理的异常，这样就避免了故障的蔓延，导致雪崩</li></ul><p>服务网关</p><ul><li>gateway：代替zuul，基于webflux框架实现，而webflux底层使用的是通信框架Netty（异步非阻塞）<br>可以进行反向代理、鉴权、流量控制、熔断，日志监控</li></ul><p>Nacos</p><ul><li>注册中心 + 配置中心</li></ul><p>sentinel</p><ul><li>hystrix的阿里版</li><li>相较于hystrix，sentinel可以作为一个组件独立出来，可以细粒度进行统一配置</li></ul><h1 id="熔断器的过程"><a href="#熔断器的过程" class="headerlink" title="熔断器的过程"></a>熔断器的过程</h1><ol><li>到达一定阈值（默认10秒超过20个请求）</li><li>到达一定失败率（20个请求10个失败）</li><li>断路器开启，所有请求将不会转发</li><li>一段时间后（默认5秒），先放一个请求，如果成功，断路器关闭，如果失败，则继续开启</li></ol><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>更多内容可点击参照<a href="https://mp.weixin.qq.com/s?__biz=MzkxMDI2NTc2OQ==&mid=2247485879&idx=1&sn=0ae52a7a8a7bbdcc02a636675a9dc5bf">这篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之中间件</title>
      <link href="/post/eb04e0a.html"/>
      <url>/post/eb04e0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>mq就是消息队列，在队列中的成为生产者，取数据的叫消费者</p><h2 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h2><p><code>解耦</code>：比如对象A依赖B,C，如果不用会频繁改动源码，不便于维护，如果将A与其余对象之间加入消息队列，A只需要给mq，其余对象也只需要从mq中取。不需要在改A的代码</p><p><code>异步</code>：假设A调B,C,D的方法，总时长为A+B+C+D，如果A为核心业务，其余的为非核心，用户体验会很不好，主要的已经完了，将非核心业务交给mq去做，加大吞吐量和用户体验</p><p><code>削峰/限流</code>：请求多的时候，每台服务器承受能力有限，如果过多，容易把系统搞掉，这时候消息队列可以将多余请求加入队列中，来避免这种情况</p><h1 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h1><p>c语言编写，高性能nosql数据库，基于内存，读写快，可做缓存，分布式锁</p><h1 id="为什么用redis"><a href="#为什么用redis" class="headerlink" title="为什么用redis"></a>为什么用redis</h1><p>传统的关系型数据库无法满足所有的场景，无法应对并发高的情况，容易将db打崩。</p><p>查的快，并发高，支持持久化</p><p>为什么快：</p><ul><li>内存操作，访问数据库是从硬盘读取的</li><li>基于hashmap的数据结构</li><li>单线程避免多线程的上下文切换，不用考虑线程竞争，不用考虑锁的问题</li><li>使用多路复用IO模型，非阻塞IO</li></ul><p>单线程不应该很耗时吗？会fork子进程来处理，不影响当前线程，保证性能</p><h1 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h1><p>string、list、hash、set、zset、HyperLogLog、Geo、Pub/Sub。</p><ul><li>String：字符串，简单的k-v，v可以是字符也可以是数字，v是2进制安全的，可以存图片或序列化的对象，最大512M</li><li>Hash：hget / hset / hgetall字典，多用于存储一个对象</li><li>List：链表，双端队列实现一个list，多用于存储消息队列，关注列表，支持正反遍历：lpush+lpop=Stack(栈)，lpush+rpop=Queue（队列）</li><li>Set：无序，不可重复集合，求交集并集，比如共同好友</li><li>Zset：有序的set，得分排行榜，数据结构是一个跳表</li></ul><h1 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h1><p>将内存的数据写入磁盘，防止数据丢失。有<code>RDB</code>和<code>AOF</code>。</p><p>RDB：快照，默认持久化方式，一定时间(或手动save)会将内存中的数据存于硬盘中，数据文件卫dump.rdb。这个过程是fork一个子进程完成的不会影响主进程的IO操作，保证了性能，缺点：会丢失一部分数据</p><p>AOF：追加。在rdis执行写命令的时候记录到单独的日志文件中，重启redis会重新持久化日志文件以恢复数据。缺点是文件比较大，恢复比较慢</p><h1 id="如何选择持久化方式"><a href="#如何选择持久化方式" class="headerlink" title="如何选择持久化方式"></a>如何选择持久化方式</h1><ul><li>如果可以承受一定时间的数据丢失，使用RDB持久化方式，因为快</li><li>在redis4.0之后支持了混用模式，允许数据丢失。建议一起开启</li></ul><h1 id="内存满了，业务还在写数据会怎么样"><a href="#内存满了，业务还在写数据会怎么样" class="headerlink" title="内存满了，业务还在写数据会怎么样"></a>内存满了，业务还在写数据会怎么样</h1><p>淘汰不活跃的，将新的加进去，做好监控和扩容，及时提高阈值</p><h1 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h1><p>就是缓存大量失效。请求打到数据库</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>过期时间随机分布，避免同时失效<br>热点数据不过期<br>限流熔断，避免后端承受请求压力</p><h1 id="怎么做持久化的"><a href="#怎么做持久化的" class="headerlink" title="怎么做持久化的"></a>怎么做持久化的</h1><p>RDB全量，AOF增量</p><h1 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h1><p>fork子进程来进行RDB，cow（copy on write）子进程创建后，父进程继续提供读写服务</p><h1 id="redis同步机制了解吗"><a href="#redis同步机制了解吗" class="headerlink" title="redis同步机制了解吗"></a>redis同步机制了解吗</h1><p>可以使用主从同步。主节点做一次备份，将后续修改记录到内存buffer，再将RDB全量复制并加载到内存，在通过后续增量AOF进行同步</p><h1 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h1><p>非法请求，缓存和数据库中都没有，可能会导致服务瘫痪</p><h2 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h2><ul><li>前端参数校验</li><li>布隆过滤器</li><li>将空对象也缓存，下次直接返回（设置一个较短的过期时间）</li><li>请求限流</li></ul><h2 id="缓存与数据库不一致"><a href="#缓存与数据库不一致" class="headerlink" title="缓存与数据库不一致"></a>缓存与数据库不一致</h2><ul><li>主动更新缓存、异步更新缓存</li><li>缓存失效，重新查询数据库</li><li>双写一致性，更新数据库同时更新缓存</li></ul><h1 id="说说持久化"><a href="#说说持久化" class="headerlink" title="说说持久化"></a>说说持久化</h1><p>有RDB（默认）和AOF</p><ul><li>RDB快照，隔段时间保存一次硬盘，文件为dump.rdb。fork子进程进行，保证了性能。但数据安全性低，会丢失一部分数据</li><li>AOP追加，每次写时候记录到单独日志文件中，同时开启优先AOF，解决了数据一致性问题。但带来的问题就是大，恢复比较慢</li></ul><h1 id="如何保证热点数据"><a href="#如何保证热点数据" class="headerlink" title="如何保证热点数据"></a>如何保证热点数据</h1><p>采取淘汰策略：常见的有LRU</p><h1 id="淘汰策略有哪些"><a href="#淘汰策略有哪些" class="headerlink" title="淘汰策略有哪些"></a>淘汰策略有哪些</h1><p><img src="https://image.leidl.top/img/20211028201122.jpg" alt="out"></p><h1 id="BloomFilter（布隆过滤器）"><a href="#BloomFilter（布隆过滤器）" class="headerlink" title="BloomFilter（布隆过滤器）"></a>BloomFilter（布隆过滤器）</h1><p>概念：70年布隆提出，用于检索一个元素是否在集合中，空间效率和时间效率高于其他算法，但有误伤率和删除困难</p><p>原理：当元素加入集合，通过k个散列函数将元素映射为一个位数组的k个点，如果有0则一定存在，如果全1则不一定存在<br><img src="https://image.leidl.top/img/20210928172759.awebp" alt="bloom"></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之mysql</title>
      <link href="/post/121bde1d.html"/>
      <url>/post/121bde1d.html</url>
      
        <content type="html"><![CDATA[<h1 id="说说三大范式个人怎么理解的？"><a href="#说说三大范式个人怎么理解的？" class="headerlink" title="说说三大范式个人怎么理解的？"></a>说说三大范式个人怎么理解的？</h1><p>第一范式：每列不可再分</p><p>第二范式：在第一范式基础上，非主键列全部依赖于主键（可以接受冗余）</p><p>第三范式：在第二范式基础上，不依赖其他非主键，也就是消除冗余。比如用户表一个人的id作为主键，部门名称就违反了3NF，因为部门名称依赖于部门id，不完全依赖于id</p><p>一般满足3NF就可以了，根据业务的不同来适当进行字段冗余，减少表之间的连接，减少IO，提高查询效率</p><h1 id="innodb的聚集索引与非聚集索引"><a href="#innodb的聚集索引与非聚集索引" class="headerlink" title="innodb的聚集索引与非聚集索引"></a>innodb的聚集索引与非聚集索引</h1><p>聚集索引：表记录顺序与索引记录顺序一致。找到了索引就相当于找到了数据。所以一般来说主键就是<br>非聚集索引：不一致，找到索引没找到数据，根据索引上的指在回表查询</p><blockquote><p>非聚集举例：select no,name from student where no = ‘test’。查到no的主键，再根据主键查一次</p></blockquote><h1 id="对innodb了解吗"><a href="#对innodb了解吗" class="headerlink" title="对innodb了解吗"></a>对innodb了解吗</h1><p>innodb底层结构使用B+树<br><code>为什么不用红黑树或者AVL？</code><br>因为是二叉树的变种，而B树是多叉树，一个节点能存更多的信息，所以在相同的数据下，树的高度更低，IO次数更少<br><code>为什么不用B树？</code><br>B+的非叶子节点不存数据，在相同数据下，高度更低，IO更少</p><h2 id="聚集索引特点"><a href="#聚集索引特点" class="headerlink" title="聚集索引特点"></a>聚集索引特点</h2><ul><li>聚集索引只能有一个，非可以有多个</li><li>聚集物理连续，非逻辑连续</li></ul><h1 id="b树与b-的区别"><a href="#b树与b-的区别" class="headerlink" title="b树与b+的区别"></a>b树与b+的区别</h1><ul><li>b树每个节点都存数据，b+只有叶子节点</li><li>b+降低了b的高度，减少查询的IO时间</li><li>b树和b+树都是平衡树，但是b树要求每个索引后面直接跟着数据，b+树则是非叶子结点会冗余到下一层，直到叶子结点层再追加数据。mysql的innodb页默认大小为<code>16kb</code>，如果不跟数据只存索引，一个节点可以多存更多的索引，最后达到更多索引全放内存里，加快速度</li><li>InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放<code>键值</code>+<code>指针</code>。</li><li>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据</li></ul><h1 id="innodb与myisam的区别"><a href="#innodb与myisam的区别" class="headerlink" title="innodb与myisam的区别"></a>innodb与myisam的区别</h1><ul><li>m支持表锁，i另外还支持行锁</li><li>m不支持事务，i支持</li><li>m不支持外键，i支持</li><li>m不支持崩溃恢复，i支持（依赖于redo log（重做日志））这也是事务持久性的体现。（undo日志保证原子性）</li></ul><h1 id="innodb引擎的四大特性"><a href="#innodb引擎的四大特性" class="headerlink" title="innodb引擎的四大特性"></a>innodb引擎的四大特性</h1><ul><li>插入缓冲（insert buffer）</li><li>二次写（double write）</li><li>自适应hash（ahi）</li><li>预读（read ahead）</li></ul><h1 id="mysql事务隔离级别（与spring一致）"><a href="#mysql事务隔离级别（与spring一致）" class="headerlink" title="mysql事务隔离级别（与spring一致）"></a>mysql事务隔离级别（与spring一致）</h1><p>由低到高</p><ul><li>READ-UNCOMMITTED(读取未提交)：导致脏读、不可复读、幻读</li><li>READ-COMMITTED(读取已提交)：可阻止<code>脏读</code>，导致不可复读、幻读</li><li>REPEATABLE-READ(可重复读)：对同一个字段怎么读都是一致的。可阻止<code>脏读</code>、<code>不可复读</code>。导致幻读</li><li>SERIALIZABLE(可串行化)：全部阻止。一般用于<code>分布式事务</code></li></ul><blockquote><p>脏读：A事务读取数据进行修改还没提交，B事务访问该数据，这个数据是还未提交的，所以是脏数据<br>不可重复读：A事务多次读同一条数据，如果在此期间B事务修改了数据，会导致A事务读取到的数据不一致—重点在<code>修改</code><br>幻读：在A事务查询过程中，B事务插入几条数据，导致A发现了一些本来不存在的记录，如同幻觉—重点在<code>新增</code>、<code>删除</code></p></blockquote><h1 id="mysql事务特性"><a href="#mysql事务特性" class="headerlink" title="mysql事务特性"></a>mysql事务特性</h1><p>ACID<br>原子性（Atomicity）:要么同时成功，要么同时失败。由undo log保证，记录修改前的信息<br>一致性（Consisency）：应该由代码去保证，出现异常就需要回滚，而不是强行提交<br>隔离性（Isolation）：并发执行，互不干扰，如果在同一时刻操纵同一数据，可能就会出现脏，幻，重复读的问题<br>持久性（Durability）：数据持久化在硬盘上。用redo log保证，如果挂了可以崩溃恢复</p><h1 id="怎么实现隔离级别的"><a href="#怎么实现隔离级别的" class="headerlink" title="怎么实现隔离级别的"></a>怎么实现隔离级别的</h1><p>通过MVCC（多版本并发控制）来实现的<br>原理主要通过read view和undo log<br>read view：聚集索引都包含下面两个必要的隐藏列<br><code>trx_id</code>：一个事务每次对某条聚集索引记录进行改动时，都会把该事务的id赋值给trx_id隐藏列<br><code>roll_pointter</code>：每次对某条聚集索引记录进行改动时，都会把旧的版本写入undo日志中，这个隐藏列就相当于一个指针，通过他找到该记录修改前的信息<br>undo log存储了多个版本的历史数据，根据规则去读取某一历史版本的数据，这样就可以在无锁的情况下实现读写并行，提高数据库性能</p><h1 id="说说mysql（innodb）的常见锁"><a href="#说说mysql（innodb）的常见锁" class="headerlink" title="说说mysql（innodb）的常见锁"></a>说说mysql（innodb）的常见锁</h1><ul><li>行锁：指命中索引，锁的是索引节点，如果没有命中索引，那么就是锁的整张表，也就是表锁</li><li>行锁又可以分为读锁（共享锁，S锁）和写锁（排他锁，X锁）</li><li>共享锁又称读锁。若事务A加上S锁，其他事务只能读，不能修改（加X锁）</li><li>排他锁又称写锁。若事务A加上X锁，不能读也不能写</li><li>表锁：锁整张表，不会死锁，容易锁冲突，性能相对较低</li><li>乐观锁（需自己实现）通过版本号去实现，减少上锁开销，适合于读多写少的情况</li></ul><h1 id="说说你对mysql是怎么调优的"><a href="#说说你对mysql是怎么调优的" class="headerlink" title="说说你对mysql是怎么调优的"></a>说说你对mysql是怎么调优的</h1><ol><li>explain查看sql是否走了索引</li><li>是否索引失效，造成的原因是函数 / 语法 / 计算等</li><li>是否select了过多的字段</li><li>join的表是否过多，加大join buffer</li><li>是否进行了排序，加大sort buffer</li><li>通过优化逻辑来提高查询速度，比如深分页的问题</li><li>数据过多，分库分表</li><li>机器配置导致性能过低，适当增加资源</li><li>本地缓存，分布式缓存</li></ol><h1 id="如果走索引线上还是慢怎么办"><a href="#如果走索引线上还是慢怎么办" class="headerlink" title="如果走索引线上还是慢怎么办"></a>如果走索引线上还是慢怎么办</h1><ul><li>这种情况一般是数据查询量大导致的，首先考虑把旧数据删除（挪到Hive中），数据量降低，自然就快了</li><li>如果不删除，那么在访问数据库之前，能不能加一层缓存</li><li>如果有字符串检索的场景，可以将表中的数据导入ElasticSearch，后续线上查询就可以直接走了（会有同步程序）</li><li>如果还不是就得考虑做聚合表的，请求查聚合表，不走原表</li></ul><h1 id="如果除了读，提交的也很慢怎么办"><a href="#如果除了读，提交的也很慢怎么办" class="headerlink" title="如果除了读，提交的也很慢怎么办"></a>如果除了读，提交的也很慢怎么办</h1><ul><li>如果是单库，可以考虑主从读写分离，主写从读，由主库发送bin log保证数据一致性（异步）</li><li>如果主从还不行，就需要考虑分库分表了。比如订单表进行拆分，这样明显的好处就是分摊请求，一般按照userId作为分库分表的键</li><li>分库分表的id一般可以采用雪花算法，mysql自增</li></ul><h1 id="分库分表怎么进行数据迁移？"><a href="#分库分表怎么进行数据迁移？" class="headerlink" title="分库分表怎么进行数据迁移？"></a>分库分表怎么进行数据迁移？</h1><ul><li>增量信息都写一份</li><li>将旧数据移入新表中</li><li>开启双读（用于过度）</li><li>读流量切新表</li><li>停止老表的写入</li></ul><h1 id="你们使用的哪种隔离级别"><a href="#你们使用的哪种隔离级别" class="headerlink" title="你们使用的哪种隔离级别"></a>你们使用的哪种隔离级别</h1><p>读取已提交，可重复读可能会导致间隙锁导致死锁<br>MySQL刚开始bin log没有row模式，在读取已提交可能会存在主从不一致的问题，所以默认级别为可重复读</p><h1 id="谈谈mysql的架构"><a href="#谈谈mysql的架构" class="headerlink" title="谈谈mysql的架构"></a>谈谈mysql的架构</h1><p><img src="https://image.leidl.top/img/20211025112150.jpg" alt="20211025112150"></p><p>总体上分为server层和存储引擎层</p><p>server层：跨存储引擎功能都在这一层实现，比如存储过程，触发器，视图，函数，还有bin log日志</p><p>存储引擎层：负责数据的存储和读取，采用可替换式插件架构，支持innodb，myisam等多个存储引擎，redolog是innodb的特有引擎</p><h1 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h1><p>连接 -&gt; 分析 -&gt; 优化 -&gt; 执行</p><p>连接器：主要与<code>身份验证</code>和权限功能相关，类似门卫角色。主要负责登录数据库，进行用户身份认证，如果认证成功，会连接权限表查询用户权限，只要链接不断开，该用户权限修改不受影响</p><p>查询缓存（mysql8移除）：用来缓存select语句结果集。实际业务如果更新比较频繁，查询不建议使用缓存，因为场景比较少，所以8以后进行了移除</p><p>分析器：如果没有命中缓存，交给分析器，主要用来<code>解析sql语句是来干嘛的</code>，检查词法和语法</p><p>优化器：选择一个最优方案去执行。逻辑转换（化简表达式）代价优化（比如多个索引时如何选择，多表查询如何选择关联顺序）</p><p>执行器：执行优化后的语句，执行前校验用户权限，没有返回错误信息，有调用存储引擎，返回执行结果</p><h1 id="sql语句如何执行"><a href="#sql语句如何执行" class="headerlink" title="sql语句如何执行"></a>sql语句如何执行</h1><p>比如一个select语句<code>select * from tb_student  A where A.age=&#39;18&#39; and A.name=&#39; 张三 &#39;;</code></p><p>首先检查是否有权限<br>如果有会查询缓存，如果没有通过分析器去进行词法分析，提取关键元素select，表名，需要查询的列，条件。<br>然后在去检查语法，比如关键词是否正确，没有问题进入优化器</p><p>如上述语句有两个条件，先查前面在查后面，或者反过来，优化器会选择一个效率比较高的方法</p><p>然后进行权限校验，没有返回错误信息，有执行返回结果</p><p>如果是一个更新语句<code>update tb_student A set A.age=&#39;19&#39; where A.name=&#39; 张三 &#39;;</code></p><p>先查询到这个语句，有缓存则用缓存</p><p>拿到查询的结果，将age改为19，innodb将数据保存在内存中，同时记录redo log，此时该日志为prepare状态，然后告诉执行器执行完毕<br>执行器收到通知记录binlog，调用引擎，提交redo log变更为提交状态</p><p>innodb通过redo log来支持事务，如果redo log与bin log（归档，用来备份）只用一个会出现数据不一致的问题</p><p>机器异常重启，redo log用来恢复数据，bin log没有记录，在备份的时候会出现数据不一致<br>或<br>机器异常重启，写完bin log，机器无法恢复数据，但备份又有记录，所以也会出现不一致的情况</p><p>redo log：用于崩溃恢复<br>undo log：用于保证原子性<br>bin log：用于归档备份记录</p><p><a href="https://database.51cto.com/art/202102/645994.htm">详情见这篇文章</a></p><h1 id="什么是MVCC，说说它的原理？"><a href="#什么是MVCC，说说它的原理？" class="headerlink" title="什么是MVCC，说说它的原理？"></a>什么是MVCC，说说它的原理？</h1><p>MVCC（Multi-Version Concurrency COntrol）多版本并发控制。<br>通过版本链，实现多版本，可并发的读写，写读（readView生成策略不同影响）<br>在innodb中有三个基础点</p><ol><li>隐式字段：包含隐式主键，事务id等</li><li>undo log。事务对同一记录的修改，会导致undo log成为一张线性表，链首位最早记录</li><li>ReadView</li><li>已提交隔离级别在每次查询都会生成一个独立的readview，而可重复读只会用第一次生成的readview。</li></ol><h1 id="你们数据量多大？分库分表怎么做的？"><a href="#你们数据量多大？分库分表怎么做的？" class="headerlink" title="你们数据量多大？分库分表怎么做的？"></a>你们数据量多大？分库分表怎么做的？</h1><p>先垂直后水平<br>垂直分表 — 拆分字段<br>水平分表 — 数据迁移</p><p>分表怎么保证id唯一？<br>设置步长。分布式id（比如雪花算法）。主键不再使用，设置新字段作为唯一主键使用</p><p>分表后非sharing-key怎么处理？<br>做映射 + 数仓大宽表 + 异步查询</p><h2 id="多少条数据算大表"><a href="#多少条数据算大表" class="headerlink" title="多少条数据算大表"></a>多少条数据算大表</h2><p>一般来说，B+树的高度不超过3，每一层的索引格个数为16kb/（8（主键大小） + 6（页地址大小））或者<br>16kb /（4+6）算下来就是一千多 x 一千多 x 16（假设一条记录是1k）<br>就是2000万 — 4000万行记录</p><h2 id="谈谈mysql中的锁"><a href="#谈谈mysql中的锁" class="headerlink" title="谈谈mysql中的锁"></a>谈谈mysql中的锁</h2><p>共享锁又称读锁（s锁），能访问，不能修改<br>排他锁又称写锁（x锁），不能与其他锁并存</p><p>表锁：锁表，开销大，并发度最低<br>行锁：锁行，不对其他行有影响，开销小，并发度高<br>页锁：锁页，处于之间，并发度一般</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之基础</title>
      <link href="/post/855673ad.html"/>
      <url>/post/855673ad.html</url>
      
        <content type="html"><![CDATA[<p>参照<a href="https://mp.weixin.qq.com/s?__biz=MzkxMDI2NTc2OQ==&mid=2247486824&idx=1&sn=a00e554cb5c30f237e278ee8ad02ec7a">这篇文章</a></p><h1 id="Java部分"><a href="#Java部分" class="headerlink" title="Java部分"></a>Java部分</h1><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>基本数据和引用数据</p><p>基本有8种按占用内存分别为，byte(1),boolean(1),short(2),char(2),int(4),float(4),long(8),double(8)</p><p><img src="https://image.leidl.top/img/20211102185826.png" alt="type"></p><h1 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h1><p><img src="https://image.leidl.top/img/20211102185944.png" alt="private"></p><h1 id="反射应用场景"><a href="#反射应用场景" class="headerlink" title="反射应用场景"></a>反射应用场景</h1><ul><li>框架（spring通过xml装载bean）</li><li>jdbc</li><li>BeanUtils.copyPropeties</li></ul><h1 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h1><p><img src="https://image.leidl.top/img/20211102195935.webp" alt="OSI"></p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>一句话：确保双方的一个收发数据的能力</p><p>A发给B，B收到了，B知道了自己的的收数据能力和A的发数据能力是可以的</p><p>B发给A，A收到了，A知道了B的发数据与自己的收数据能力</p><p>而此时B还不知道自己的发件和A的收件能力，所以A还会给B再发送一次</p><p>总之就是AB都需要确保四点，我的发送，我的接收，他的发送，他的接收</p><h1 id="为什么是4次挥手"><a href="#为什么是4次挥手" class="headerlink" title="为什么是4次挥手"></a>为什么是4次挥手</h1><p>3次只是表明我同意你关闭连接了，但还不确定是否还有剩余的数据需要发送</p><h1 id="说说ArrayList的扩容"><a href="#说说ArrayList的扩容" class="headerlink" title="说说ArrayList的扩容"></a>说说ArrayList的扩容</h1><p>ArrayList底层由数组实现，默认容量<code>10</code>，初始为一个空数组，在添加元素的时候才会为其扩容，即扩为10。如果容量不够，则会触发grow()进行扩容，grow是扩容的核心方法，将新容量扩为之前的1.5倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="说说CopyOnWriteArrayList"><a href="#说说CopyOnWriteArrayList" class="headerlink" title="说说CopyOnWriteArrayList"></a>说说CopyOnWriteArrayList</h1><p>不在上面直接修改，而是创建一个副本进行修改，这种机制保证了读取不会受到写的干扰</p><p>适合于高并发读，读不会上锁</p><p>缺点：</p><ol><li>写操作消耗内存，原数组内容比较多的情况下会young gc或者full gc</li><li>不能实时读，能做到最终一致性，不能满足实时一致性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么是集合快速失败“fail-fast”？"><a href="#什么是集合快速失败“fail-fast”？" class="headerlink" title="什么是集合快速失败“fail-fast”？"></a>什么是集合快速失败“fail-fast”？</h1><p>多线程操作，在用增强for循环，其实就是集合的迭代器遍历时，如果同时进行遍历修改，就会抛出ConcurrentModificationException异常</p><blockquote><p>原因：ArrayList的父类AbstarctList中有一个modCount变量，每次对集合进行修改时都会modCount++。ArrayList的Iterator中有一个expectedModCount变量，该变量会初始化和modCount相等，每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount的值和expectedmodCount的值是否相等，如果集合进行增删操作，modCount变量就会改变，就会造成expectedModCount!=modCount，此时就会抛出ConcurrentModificationException异常</p></blockquote><p>解决方式</p><ul><li>使用普通for循环</li><li>使用Java8的stream流</li><li>使用CopyOnWriteArrayList（在copy的数据上修改不会影响原数据）</li></ul><h1 id="ArrayList-和-LinkedList-的区别？"><a href="#ArrayList-和-LinkedList-的区别？" class="headerlink" title="ArrayList 和 LinkedList 的区别？"></a>ArrayList 和 LinkedList 的区别？</h1><ul><li>数据结构不同。A是动态数组数据结构进行实现，L是双向链表的方式实现</li><li>查询插入效率不同。A的查询效率高，插入删除低，L次之</li><li>占用内存不同。L更占内存，除了存数据还存向前向后的引用</li></ul><h1 id="HashMap为什么是线程不安全的"><a href="#HashMap为什么是线程不安全的" class="headerlink" title="HashMap为什么是线程不安全的"></a>HashMap为什么是线程不安全的</h1><p>JDK1.7：死循环、数据丢失<br>JDK1.8：数据覆盖。插入之前时间片耗尽，另一个插入，则可能造成数据覆盖。</p><blockquote><p>JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。<br>JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。</span></span><br><span class="line"><span class="comment">头插法会将链表的顺序翻转，这也是形成死循环的关键点.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/littlehaes/article/details/105241194">为什么会造成死循环原因见这篇文章</a></p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>哈希冲突：当key的hash值对数组大小取模后，如果值相同，那么就是哈希冲突，会形成一条entry链</p><p>加载因子：为了减少哈希冲突，官方设定了一个值为0.75，当键值对达到总容量的75%时，则进行扩容。可以空间换时间，将加载因子手动调低。调低会频繁扩容</p><h1 id="如何保证是2的幂次方"><a href="#如何保证是2的幂次方" class="headerlink" title="如何保证是2的幂次方"></a>如何保证是2的幂次方</h1><p>tableSizeFor方法，可以保证返回的值为大于=n的2的幂次方的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= <span class="number">1</span> &lt;&lt; <span class="number">30</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">30</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么扩容是2倍，不是3倍？或者为什么要保证是2的幂次方？"><a href="#为什么扩容是2倍，不是3倍？或者为什么要保证是2的幂次方？" class="headerlink" title="为什么扩容是2倍，不是3倍？或者为什么要保证是2的幂次方？"></a>为什么扩容是2倍，不是3倍？或者为什么要保证是2的幂次方？</h1><ul><li>减少元素位置的移动</li><li>使元素分配更加均匀，减少哈希碰撞</li></ul><h1 id="HashMap的put过程"><a href="#HashMap的put过程" class="headerlink" title="HashMap的put过程"></a>HashMap的put过程</h1><p>首先计算key的hash值，hash = <code>key.hashCode() ^ key.hashCode() &gt;&gt;&gt; 16</code>，高位补0。</p><p>计算下标为<code>index = (table.length - 1) &amp; hash</code></p><p><img src="https://image.leidl.top/img/20211111105633.webp" alt="put"></p><p>根据下标确认元素位置，判断该位置是否为空，如果没有则存入元素，如果有根据不同版本进行处理<br>1.7头插链表。<br>1.8判断Node，决定红黑树还是链表。1.8先插入在判断是否需要扩容</p><p>相关源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Map.put和相关方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建 </span></span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理  </span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树 </span></span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表 </span></span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断该链表尾部指针是不是空的</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//链表结构转树形结构</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么用异或计算hash"><a href="#为什么用异或计算hash" class="headerlink" title="为什么用异或计算hash"></a>为什么用异或计算hash</h1><p>得到的值更加均匀</p><blockquote><p>个人观点：补充一些，hashcode为int类型，4个字节32位，为了确保散列性，肯定是32位都能进行散列算法计算是最好的。 首先要明白，为什么用异或计算，二进制位计算，a 只可能为0,1，b只可能为0,1。a中0出现几率为1/2,1也是1/2，b同理。 位运算符有三种，|，&amp;，……，或，与，亦或。 a,b进行位运算，有4种可能 00，01,10,11 a或b计算 结果为1的几率为3/4,0的几率为1/4 a与b计算 结果为0的几率为3/4,1的几率为1/4, a亦或b计算 结果为1的几率为1/2,0的几率为1/2 所以，进行亦或计算，得到的结果肯定更为平均，不会偏向0或者偏向1，更为散列。 右移16位进行亦或计算，我将其拆分为两部分，前16位的亦或运算，和后16位的亦或运算， 后16位的亦或运算，即原hashcode后16位与原hashcode前16位进行亦或计算，得出的结果，前16位和后16位都有参与其中，保证了 32位全部进行计算。 前16位的亦或运算，即原hasecode前16位与0000 0000 0000 0000进行亦或计算，结果只与前16位hashcode有关，同时亦或计算，保证 结果为0的几率为1/2,1的几率为1/2，也是平均的。 所以为什么是右移16位，个人觉得博主说的原因是一部分， 也有一个原因是右移16位进行亦或计算的结果中， （1）结果的后16位保证了hashcode32位全部参与计算，也保证了0,1平均，散列性 （2）结果的前16位保证hashcode前16位了0，1平均散列性，附带hashcode前16位参与计算。 (3) 16与16位数相同，利于计算，不需要补齐，移去位数数据 更多情况，hashmap只会用到前16位（临时数据一般不会这么大），所以（1）占主因</p></blockquote><h1 id="如何散列"><a href="#如何散列" class="headerlink" title="如何散列"></a>如何散列</h1><p>直接进行hash取余操作，可能导致散列不均匀的情况（参与运算的只有hashcode的低位），最坏情况会形成一个单链表。所以对hashCode做了一定的优化，让高位也参与运算，使其更加平均，减少哈希碰撞，这样的操作叫做扰动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p><h1 id="如何解决hash冲突"><a href="#如何解决hash冲突" class="headerlink" title="如何解决hash冲突"></a>如何解决hash冲突</h1><p>1.8之前，如果有冲突将值加入链表中，又叫拉链法</p><p>1.8之后，链表长度大于8，调用treeifyBin方法，会判断hashmap数组长度是否大于等于64，如果是则转为红黑树，以减少搜索时间，否则执行resize方法扩容</p><h1 id="扩容条件是什么"><a href="#扩容条件是什么" class="headerlink" title="扩容条件是什么"></a>扩容条件是什么</h1><p>大于容量*扩容因子（默认0.75f），loadFactor 越大数组越密，越少越稀疏。0.75是官方给出的一个比较好的临界值。<code>threshold = capacity \* loadFactor</code>，用来衡量是否需要扩容</p><h1 id="扩容怎么实现的"><a href="#扩容怎么实现的" class="headerlink" title="扩容怎么实现的"></a>扩容怎么实现的</h1><ol><li>在jdk1.8中，添加元素个数大于阀值时或者初始化时，就调用resize方法进行扩容；</li><li>每次扩展的时候，新容量为旧容量的2倍；</li><li>扩展后元素的位置要么在原位置，要么移动到原位置 + 旧容量的位置；</li></ol><blockquote><p>在putVal()中使用到了2次resize()方法，resize()方法在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值(第一次为12)，这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+旧容量的位置</p></blockquote><p>resize源码解读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab指向hash桶数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//返回</span></span><br><span class="line">        &#125;<span class="comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 双倍扩容阀值threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class="line">    <span class="comment">// 直接将该值赋给新的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的threshold = 新的cap * 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//新建hash桶数组</span></span><br><span class="line">    table = newTab;<span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    <span class="comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历新数组的所有桶下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class="line">                                <span class="comment">// 代表下标保持不变的链表的头元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                <span class="comment">// loTail.next指向当前e</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// loTail指向当前的元素e</span></span><br><span class="line">                            <span class="comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class="line">                            <span class="comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class="line">                            <span class="comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashSet如何检查重复元素？如何保证数据是不可重复的？"><a href="#HashSet如何检查重复元素？如何保证数据是不可重复的？" class="headerlink" title="HashSet如何检查重复元素？如何保证数据是不可重复的？"></a>HashSet如何检查重复元素？如何保证数据是不可重复的？</h1><p>add()添加时，不仅比较hash值，还会使用equlas比较，HashSet的add()会调用HashMap的put()</p><p>底层就是利用HashMap实现的，在添加相同的key时会覆盖原有的value值，返回原有的value值，所以不会重复</p><p>部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谈谈ConcurrentHashMap的扩容机制"><a href="#谈谈ConcurrentHashMap的扩容机制" class="headerlink" title="谈谈ConcurrentHashMap的扩容机制"></a>谈谈ConcurrentHashMap的扩容机制</h1><p>1.7底层使用segment数组 + hashmap数组 + 链表</p><p>Java7 中 ConcurrentHashMap 使用的分段锁，初始化之后不可以扩容，默认值为16，也就是ConcurrentHashMap中有16个segment，理论上支持16个线程并发写，进行扩容时，实际是segment数组中的HashEntry进行扩容，为原来的2倍，这个时候不需要考虑并发，因为segment是持有独占锁的。</p><p><img src="https://image.leidl.top/img/20211111160440.webp" alt="map7"></p><p>1.8与hashmap一样，node数组 + 链表 / 红黑树</p><p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><h1 id="JDK1-8-中为什么使用内置锁synchronized替换可重入锁-ReentrantLock？"><a href="#JDK1-8-中为什么使用内置锁synchronized替换可重入锁-ReentrantLock？" class="headerlink" title="JDK1.8 中为什么使用内置锁synchronized替换可重入锁 ReentrantLock？"></a>JDK1.8 中为什么使用内置锁synchronized替换可重入锁 ReentrantLock？</h1><ol><li>首先在1.6中，synchronized实现了大量优化，会从无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>并不是每个节点都需要同步支持的，只有头结点需要，使用lock基于AQS每个节点都会继承来获得同步支持，无疑带来了巨大的内存浪费  </li></ol><h1 id="谈谈反射"><a href="#谈谈反射" class="headerlink" title="谈谈反射"></a>谈谈反射</h1><p>可以在类运行时获取类的信息，运行时解释：java文件编译后会变为class文件，而class文件会被jvm装载运行。</p><h1 id="为什么匿名内部类要用final常量"><a href="#为什么匿名内部类要用final常量" class="headerlink" title="为什么匿名内部类要用final常量"></a>为什么匿名内部类要用final常量</h1><p>生命周期不一致，局部变量存于栈中，当方法执行结束后，非final被销毁，而局部内部类的引用还存在，此时内部类在调用的时候就会出错，加了final约束了对象的强一致性，避免了此问题</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>更多内容可点击参照<a href="https://mp.weixin.qq.com/s?__biz=MzkxMDI2NTc2OQ==&mid=2247486824&idx=1&sn=a00e554cb5c30f237e278ee8ad02ec7a">这篇文章</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxMDI2NTc2OQ==&mid=2247485959&idx=1&sn=f20ee47bf82a5b436f2f6157bcc5798b">集合相关文章</a></p><h1 id="谈谈你对JMM的理解"><a href="#谈谈你对JMM的理解" class="headerlink" title="谈谈你对JMM的理解"></a>谈谈你对JMM的理解</h1><p>JMM希望屏蔽各种硬件和操作系统的访问差异，保证Java在各种平台下对内存访问都能达到一致的效果</p><p>解决多线程存在的原子性，可见性，和有序性的问题，JMM主要内容有以下几块</p><ul><li>JMM的抽象结构。线程的所有操作必须于本地内存（私有的），不能操作主内存<br><img src="https://image.leidl.top//imgjmm1.jpeg" alt="jmm1"><br>JMM的操作指令及其作用，从上而下有used，load，store，read，write，lock，unlock<br><img src="https://image.leidl.top//imgJMM2.jpeg" alt="JMM2"></li><li><a href="https://segmentfault.com/a/1190000011458941#item-12">happen-before原则</a>。阐述可见性，有了这个原则我们的代码才不会发生重排序</li><li>volatile。解决可见性和重排。实现依据是内存屏障</li></ul><h1 id="谈谈Object-object-new-Object"><a href="#谈谈Object-object-new-Object" class="headerlink" title="谈谈Object object = new Object()"></a>谈谈Object object = new Object()</h1><p>引用在方法区，变量在栈，对象在堆中<br>占多少内存？在64位系统中16个字节，只有一个对象头占内存，mark word占了8字节，类型指针（classpoint）占了8个字节</p><ul><li>启动了压缩指针 -XX:UseCompressedClassPointers 就是4个byte</li></ul><h1 id="new一个对象要经历哪些过程？"><a href="#new一个对象要经历哪些过程？" class="headerlink" title="new一个对象要经历哪些过程？"></a>new一个对象要经历哪些过程？</h1><ol><li>加载初始化类。查看对象所属的类是否加载到内存中，如果没有则通过对象所属的class文件加载到内存中</li><li>创建对象化。初始化完成后，在进行对象的创建工作</li></ol><p>加载初始化类<br>类加载器收到请求，会将请求委托给父类（以此类推）只有当父类无法加载，子加载器才会尝试加载（可以保证全局唯一性）<br>该模型称为<code>双亲委派模型</code></p><ol><li>加载</li><li>验证（语义，操作）</li><li>准备（为静态变量分配空间）</li><li>解析</li><li>初始化（先父后子，静态变量赋值，执行static代码块）</li></ol><p>创建对象</p><ol><li>在堆中分配对象所需要的内存</li><li>对所有成员变量赋初值（方法区copy到堆赋值）</li><li>执行实例化代码</li></ol><h1 id="谈谈动态代理"><a href="#谈谈动态代理" class="headerlink" title="谈谈动态代理"></a>谈谈动态代理</h1><p>动态代理有常见的两种实现方式，jdk代理和cglib代理<br>jdk利用了反射的机制<br>cglib利用的是asm框架，通过修改字节码生成子类来处理</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之并发编程</title>
      <link href="/post/22580020.html"/>
      <url>/post/22580020.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>详细见<a href="https://leidl.top/post/153083dc.html">juc笔记</a></p><h1 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h1><ul><li>并发有同时处理任务的能力，不一定是同时（cpu时间片交替执行，逻辑上看着是同时，实则不是，使用的一个cpu核心）</li><li>并行是可以同时处理任务（真正的多核运行）</li></ul><h1 id="谈谈进程和线程的区别"><a href="#谈谈进程和线程的区别" class="headerlink" title="谈谈进程和线程的区别"></a>谈谈进程和线程的区别</h1><ul><li>进程是资源分配的最小单位，每个进程都有自己的资源和内存空间，但切换时会有比较大的开销</li><li>为了提高切换效率，减少调度时间，就出现了线程，它是程序执行的最小单位，一个进程通常包含多个线程</li></ul><h1 id="谈谈CAS"><a href="#谈谈CAS" class="headerlink" title="谈谈CAS"></a>谈谈CAS</h1><p>unsafe类下面的一个方法。全称是（compare and swap）比较并交换，可以保证在多线程的的一个环境下对共享变量的修改保证一个原子性。</p><blockquote><p>比如做一个累加操作，需要从主内存中取出做操作，再将内存中的值写回主内存中，多个线程对同一个共享变量做操作，会出现原子性的问题，这个过程可以使用锁来解决，但性能会变差，CAS会把这个共享变量的旧值和期望值进行比较，如果符合则进行更新</p></blockquote><h2 id="CAS的底层原理怎么实现的？"><a href="#CAS的底层原理怎么实现的？" class="headerlink" title="CAS的底层原理怎么实现的？"></a>CAS的底层原理怎么实现的？</h2><p>通过unsafe类实现，是硬件级别的操作，通过OS实现原子性，C++源码中使用cmpxchg来实现，底层会调用lock if mp（多核）如果是多核则加锁</p><p>CAS的缺点？</p><ol><li>do while 如果操作不成功会一直循环，浪费cpu资源</li><li>带来ABA的问题。假设线程A读到的值为10，B为修改为了20，C又修改为了10，在A来说，与内存中的值是一致的，认为没有变过，但实际是变过的。这就是ABA问题。通常使用版本号或时间戳的方式去解决（AtomicStampedReference）</li></ol><h1 id="谈谈synchronized"><a href="#谈谈synchronized" class="headerlink" title="谈谈synchronized"></a>谈谈synchronized</h1><p>互斥锁，每次只能允许一个线程访问共享资源</p><p>修饰的是方法 / 代码块，锁的是对象实例</p><p>修饰的静态方法，锁的类实例</p><p><code>原理</code>：通过反编译class字节码文件发现会生成ACC_SYNCRONIZED关键字来标识。修饰代码块会依赖monitorenter和monitorexit指令</p><p>对象由三部分组成：<code>对象头</code>、<code>实际数据</code>、<code>对齐填充</code>。<br>重点在于对象头，分为几部分，重点是mark word信息会记录锁的信息。</p><p>在1.6之前是重量级锁，来了就阻塞别的线程。加锁是底层操作系统的行为会涉及到内核态和用户态的切换，非常消耗性能<br>之后进行了锁升级。引入了<code>偏向锁</code>和<code>轻量级锁</code>，在JVM层面加锁，不依赖操作系统，没有切换的消耗</p><p>偏向锁：没有竞争环境。markword会记录线程id，线程执行代码前需要比较id，相同则执行代码，如果不同则执行CAS修改，如果修改成功，执行代码，失败说明有竞争，撤销偏向锁，升级为轻量级锁</p><p>轻量级锁：当前线程会在栈帧下创建Lock Record，会把mark record信息拷贝进去，且owner指针指向加锁对象。线程执行代码时，用CAS将mark word指向到lock record，如果成功获取到锁，失败则自旋重试，重试到一定次数后升级为重量级锁</p><h1 id="谈谈AQS"><a href="#谈谈AQS" class="headerlink" title="谈谈AQS"></a>谈谈AQS</h1><p>全称叫做AbstractQueuedSyncronizer，实现锁的一个框架，内部实现关键在于维护了一个<code>先进先出的队列（CLH）</code>与<code>state状态变量</code><br>state则表示当前锁的状态，像ReentrantLock、CountDownLatch、Semaphore都是基于AQS实现的<br>AQS支持独占和共享两种模式<br>核心思想：<br>如果请求资源空闲，则将当前请求资源设置为有效的工作线程，并上锁。<br>如果请求资源被占用，则进入队列等待被唤醒<br>用int state来表示同步状态，使用CAS来进行原子操作实现对值的修改<br>加锁和解锁过程如图<br><img src="https://image.leidl.top//img640.png" alt="加锁及解锁"></p><h1 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h1><p>synchronized的缺陷</p><ul><li>效率低。只有执行完毕或者异常才会释放锁</li><li>不够灵活。仅有一个条件</li><li>不知道有没有获取锁。</li></ul><p>lock</p><ul><li>解决了synchronized的缺陷，多线程竞争一个资源时，得不到锁的线程不停获取锁。高并发导致性能下降，如果可以，那么会提升性能，也不会产生死锁</li></ul><p>在能选择的情况下，不要使用synchronized和lock，用juc下的各种类。在满足业务的情况下，使用synchronized，代码量少，避免出错</p><h1 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h1><p>当前任务在执行完cpu时间片切换到另一个任务之前会保存自己之前的状态，以便下次再切回这个状态，从保存到再次被加载的过程称为一次上下文切换</p><h1 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h1><p>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h1 id="Callable和Future的关系？"><a href="#Callable和Future的关系？" class="headerlink" title="Callable和Future的关系？"></a>Callable和Future的关系？</h1><p>Future接口表示一个异步任务，callable用于产生结果，future用于获取结果</p><h1 id="什么是FutureTask？"><a href="#什么是FutureTask？" class="headerlink" title="什么是FutureTask？"></a>什么是FutureTask？</h1><p>FutureTask表示一个异步任务，可以传一个callable具体实现类，对这个异步运算结果进行等待获取，判断是否可以完成，取消任务等操作。只有在运算完成才可以将结果返回，如果没有完成会加一个get方法进行阻塞。Future对callable和runnable的对象进行了包装，Future也是runnable的实现类，所以也可以放入线程池中</p><h1 id="说说Java中的线程调度算法"><a href="#说说Java中的线程调度算法" class="headerlink" title="说说Java中的线程调度算法"></a>说说Java中的线程调度算法</h1><p>计算机的cpu在任意时刻只能执行一条机器指令，每个线程只有在获得cpu的使用权才可以执行指令。多线程的并发运行，实际上是各个线程轮流获取cpu的使用权，在运行池中会有多个就绪状态的线程等待cpu，jvm负责线程的调度，为多个线程分配cpu的使用权</p><p>两种调度模型：分时调度模型和抢占式调度模型</p><p>分时调度模型：让线程轮流获取cpu的使用权，平均分配每个线程占用的cpu时间片</p><p>抢占式调度模型：让优先级高的先占用cpu，如果优先级相同就随机选择一个线程</p><p>发生以下情况，会终止线程的运行</p><ol><li>调用yield方法让出cpu的占用权力</li><li>调用sleep方法让线程睡眠</li><li>IO阻塞</li><li>一个优先级更高的线程出现</li><li>时间片用完</li></ol><h1 id="谈谈你对volatile的理解"><a href="#谈谈你对volatile的理解" class="headerlink" title="谈谈你对volatile的理解"></a>谈谈你对volatile的理解</h1><p>谈volatile之前，需要先讲讲JMM（Java内存模型），它规定Java变量都存于主内存中，每当有一个线程需要读取主内存时JVM都需要将主内存的变量拷贝一份到工作内存中，多个线程之前并不可见，如果要保证可见性，那么就需要volatile关键字，volatile可以保证可见性，让所有线程可见，在多线程环境下，指令重排可能会出现问题，volatile也可以禁止指令重排。它通过cpu指令的内存屏障实现，会强制刷新cpu缓存。volatile不保证原子性，所以还需要synchronized与atomic原子类来保证原子操作</p><p>总结：volatile是一个JVM提供的轻量级同步机制，保证可见性和禁止指令重排，但不保证原子性</p><h1 id="谈谈volatile"><a href="#谈谈volatile" class="headerlink" title="谈谈volatile"></a>谈谈volatile</h1><ol><li>保证可见性，防止主存与缓存数据的不一致。指示jvm，到主存中读取数据</li><li>防止JVM指令重排，保证多线程环境下也能正常运行</li><li>不支持原子性</li><li>写的时候直接刷新到主内存中，读的时候直接从主内存中读取，复制到工作内存</li></ol><p>为什么能保证可见和重排序<br><code>内存屏障</code>。其实就是JVM的一种指令，JMM的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些指令，实现了可见性和有序性<br>写屏障：告诉CPU在看到store指令，就必须把指令之前的所有数据都同步到主内存中<br>读屏障：在看到Load指令后，让工作内存和cpu高速缓存中的数据失效，重新回到主存中获取数据<br>细分四种屏障类型（了解）<br><img src="https://image.leidl.top//imgimage-20221123154502368.png" alt="image-20221123154502368"></p><p>为什么不保证原子性<br>volatile的可见性保证线程每次在读的时候数据是最新的。但多线程环境下，计算赋值的操作屡次出现，若在计算期间，被volatile修饰的值修改完毕（其他线程），则当前线程的计算作废，所以操作可能会出现丢失问题，进而导致数据不一致</p><p>应用场景</p><ul><li>单一赋值，不包含i++之类的复合赋值</li><li>读多于写，结合内部锁减少内存开销</li><li>单例模式 — 双重检查（先判空再加锁在判空）</li></ul><h1 id="谈谈四大引用"><a href="#谈谈四大引用" class="headerlink" title="谈谈四大引用"></a>谈谈四大引用</h1><ul><li>强引用：new出来的对象。宁愿抛OOM，也不会被回收</li><li>软引用：被softreference修饰，在内存将要溢出的时候进行回收</li><li>弱引用：被weekreference修饰，只要发生垃圾回收，那么就会被回收</li><li>虚引用：被phantomreference修饰，用队列接收对象即将死亡的通知</li></ul><h1 id="谈谈你对threadLocal的理解"><a href="#谈谈你对threadLocal的理解" class="headerlink" title="谈谈你对threadLocal的理解"></a>谈谈你对threadLocal的理解</h1><p>为什么要用？<br>在多线程编程中通常解决线程安全问题会利用synchronized或lock，但这种方式会让未获取到锁的线程阻塞等待，那么如果每个线程都拥有自己的资源，互不影响，这样也不会出现安全问题，这就是threadLocal出现的原因，是一种空间换时间的做法</p><p>是什么<br>顾名思义，表示线程的“本地变量”，即每个线程都拥有该变量副本，与线程之间互不影响</p><p>场景<br>spring，threadLocal的存储类型是一个map，key是datasource，value是connection（为了应对多数据源），用</p><h1 id="ThreadLocal会内存泄露吗？"><a href="#ThreadLocal会内存泄露吗？" class="headerlink" title="ThreadLocal会内存泄露吗？"></a>ThreadLocal会内存泄露吗？</h1><p>详细文章：<a href="https://www.jianshu.com/p/dde92ec37bd1">https://www.jianshu.com/p/dde92ec37bd1</a></p><p><img src="https://image.leidl.top//imgThreadLocal.png" alt="ThreadLocal"></p><p>会。ThreadLocal中包含了ThreadLocalMap，然而ThreadLocalMap的对象是在Thread中的，如果Thread没有结束，则ThreadLocalMap一直不会释放，假如ThreadLocalMap中设置了很多值，而且没有手动设置remove()，则可能会造成内存泄露。</p><h4 id="为什么将map中的key设置为弱引用"><a href="#为什么将map中的key设置为弱引用" class="headerlink" title="为什么将map中的key设置为弱引用"></a>为什么将map中的key设置为弱引用</h4><p>假设如果存储的强引用，其目的是通过threadLocal==null来对threadLocal进行回收。但事实恰好相反<br>在业务代码中执行threadLocal==null操作，由于threadLocalMap的Entry强引用threadLocal，因此在gc的时候进行可达性分析，threadLocal依然可达，对threadLocal并不会进行垃圾回收，这样就无法通过threadLocal==null来对threadLocal进行回收，出现逻辑错误</p><p>如果为弱引用，在threadLocal生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。<br>在threadLocal的生命周期里（set,getEntry,remove）里，都会针对key为null的脏entry进行处理。<br>但还可能出现内存泄漏，所以还需要手动remove</p><h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><p>atomic operation是在多线程环境下避免数据不一致的手段，i++不是一个原子操作，在读取+1时，其他线程可能读取之前的值</p><p>jdk5之前采取同步的方式来保证，之后使用java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步</p><p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</p><p>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</p><p>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p><h2 id="如何保证？"><a href="#如何保证？" class="headerlink" title="如何保证？"></a>如何保证？</h2><p>多个线程只能保证一个修改成功，具有排他性，其他未成功的线程则自选等待，直到执行成功</p><p>引用一段AtomicInteger的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>使用CAS、volatile和native方法保证原子性，从而避免syncronized的性能问题，执行效率大大提高</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h1 id="常用的并发工具类有哪些？"><a href="#常用的并发工具类有哪些？" class="headerlink" title="常用的并发工具类有哪些？"></a>常用的并发工具类有哪些？</h1><ul><li>Semaphore(信号量，收集龙珠)-允许多个线程同时访问某个资源：synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li>CountDownLatch(倒计时器，计数器)：CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行。强调一个线程等多个线程完成某件事情。CountDownLatch方法比较少，操作比较简单。CountDownLatch是不能复用的。</li><li>CyclicBarrier(循环栅栏，停车场)：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。CyclicBarrier是可以复用的。</li></ul><p>CountDownLatch原理：任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><h1 id="在工作中如何确定线程池的大小？"><a href="#在工作中如何确定线程池的大小？" class="headerlink" title="在工作中如何确定线程池的大小？"></a>在工作中如何确定线程池的大小？</h1><p>线程过多会导致增加上下文切换成本</p><blockquote><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。<br>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。<br>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少</p></blockquote><p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</p><p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p><p>有一个简单并且适用面比较广的公式：</p><p><code>CPU 密集型任务(N+1)</code>： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<br><code>I/O 密集型任务(2N)</code>： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。<br>如何判断是 CPU 密集任务还是 IO 密集任务？</p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>更多内容可点击参照<a href="https://mp.weixin.qq.com/s?__biz=MzkxMDI2NTc2OQ==&mid=2247486078&idx=1&sn=a9cf65c7b2599299961bf228a0462153">这篇文章</a></p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p><img src="https://image.leidl.top//imgimage-20221115161956666.png" alt="image-20221115161956666"></p><h1 id="为什么会有公平锁与非公平锁的设计？为什么默认非公平？使用场景？"><a href="#为什么会有公平锁与非公平锁的设计？为什么默认非公平？使用场景？" class="headerlink" title="为什么会有公平锁与非公平锁的设计？为什么默认非公平？使用场景？"></a>为什么会有公平锁与非公平锁的设计？为什么默认非公平？使用场景？</h1><p>非公平锁可以更加充分的利用cpu的时间片<br>当一个线程请求锁获取同步状态，然后释放同步状态，刚释放的锁线程在此刻获取同步的概率就会变得非常大（刚释放的正在使用cpu时间片），减少了性能的开销<br>看业务场景，追求性能非公平，雨露均沾选公平</p><h1 id="产生死锁的原因有什么？如何排查"><a href="#产生死锁的原因有什么？如何排查" class="headerlink" title="产生死锁的原因有什么？如何排查"></a>产生死锁的原因有什么？如何排查</h1><p>1.系统资源不足<br>2.进程顺序不合适<br>3.资源分配不当<br>使用命令jps -l找到进程号，用jstack 进程号，查看诊断信息</p><h1 id="如何终止运行中的线程"><a href="#如何终止运行中的线程" class="headerlink" title="如何终止运行中的线程"></a>如何终止运行中的线程</h1><p>线程无法立即被停止，也不应该由其他线程去终止。只是一种协商机制<br>thread提供了一种interrupt方法，他只会将对象中的中断标识设置为true，写代码根据这个标识去判断即可<br>正解：1.通过volatile变量实现。2.通过AtomicBoolean。3.通过thread的api实现<br>当一个线程正在调用中断方法时，必须保证线程是一个正常运行的状态。如果线程处于阻塞状态（sleep，wait，join等） 那么线程会立即停止阻塞状态，并抛出interruptedException异常</p><h1 id="静态interrupt方法与对象方法的区别"><a href="#静态interrupt方法与对象方法的区别" class="headerlink" title="静态interrupt方法与对象方法的区别"></a>静态interrupt方法与对象方法的区别</h1><p>调的是同一个方法，不同的是传入的clear参数不同，静态的传的true，会将线程的中断状态清空</p><h1 id="唤醒线程的方法有哪些"><a href="#唤醒线程的方法有哪些" class="headerlink" title="唤醒线程的方法有哪些"></a>唤醒线程的方法有哪些</h1><p>wait，notify — 必须先持有锁（synchronized），否则抛异常，必须先调用wait在调用notify，否则程序阻塞<br>juc中的await和singal — 同上情况，锁换为了（lock）<br>lockSupport的park和unpark。无锁块要求，先唤醒后等待支持，需要成双成对使用</p><h1 id="谈谈你对volatile的理解-1"><a href="#谈谈你对volatile的理解-1" class="headerlink" title="谈谈你对volatile的理解"></a>谈谈你对volatile的理解</h1><p><code>两大特性</code><br>有可见性和禁重排特性<br><code>分别阐述</code><br>可见性，写和读操作都是针对于主内存中，保证数据是最新的。<br>写完会立即刷新到主内存中。<br>当读的时候会使该线程工作内存中的数据失效，重新去主内存中去读。<br>禁重排<br>有内存屏障的存在使得被修饰的变量语句顺序不会重排<br>JVM会在生成字节码时加入ACC_VOLATILE关键字，按照JMM的规范在相应的位置插入内存屏障</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>1.与ThreadLocalMap和Thread的关系<br>2.key是弱引用的原因<br>ThreadLocalmap继承了弱引用<br>3.内存泄露的问题<br>4.最后为什么加remove方法<br>不会影响线程池复用对之前线程造成的影响</p><h1 id="谈谈读写锁ReentrantReadWriteLock"><a href="#谈谈读写锁ReentrantReadWriteLock" class="headerlink" title="谈谈读写锁ReentrantReadWriteLock"></a>谈谈读写锁ReentrantReadWriteLock</h1><p>读读共享，读写互斥<br>为什么要用它，ReentrantLock不行？ReentrantLock多个线程读只有一个线程操作<br>而读写锁多个线程读是可以共享的<br>带来了缺点，写锁饥饿的问题，出现了锁降级（将为读锁，不能反之升级  ）<br>写锁饥饿，如果读锁比较多，写锁抢不到</p><h1 id="谈谈对线程池的理解"><a href="#谈谈对线程池的理解" class="headerlink" title="谈谈对线程池的理解"></a>谈谈对线程池的理解</h1><p>线程在每次创建和销毁时都是在内核进行的，这就导致可能创建和销毁的花费比任务花费的时间要多<br>线程池的出现是为了<code>提高线程的复用性</code><br>降低资源消耗：重复利用一定的线程，频繁创建线程会消耗资源，还会降低系统稳定性<br>提高响应速度：当任务到达时，不需要等待创建线程的时间</p><p>项目中用到了么？</p><p>用到了，我负责的项目模块中有一个年度价值统计，需要创建统计模板定时发送信息。每个模板对应一个id，需要在hdfs中去找这个文件，遍历查找操作使用了线程池，因为hdfs遍历操作是一个费时任务，将此过程进行异步化，提高系统的吞吐量，使用ThreadPoolExcutor创建线程池，而不是使用executor（阿里手册不推荐，使用原生方法更能理解线程池运行规则，避免资源被耗尽的风险）</p><p>如何指定线程数？</p><p>看业务情况<br>cpu密集型：n+1<br>io密集型：2n<br>究竟开多少，可以通过压测定</p><p>具体的可以看juc笔记</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>与wait/notify相比使用的是park/unpark，在使用顺序上，wait必须遵守顺序而park不需要，因此更加灵活。<br>condition.await()底层使用LockSupport的park来阻塞线程</p><p>wait和park的区别</p><ol><li>wait需要在synchronized中使用，park是任意地方</li><li>wait抛出了终端异常，需要调用者处理，park不需要</li><li>wait不指定时间需要notify去唤醒，但不一定执行后续内容</li><li>park不指定时间需要unpark唤醒，一定执行后续内容</li></ol><p>为什么unpark放在park之前不会被阻塞，因为unpark相当于一个凭证，使用park时会判断有没有这个凭证</p><h3 id="Execute原理是什么"><a href="#Execute原理是什么" class="headerlink" title="Execute原理是什么"></a>Execute原理是什么</h3><p>当一个任务提交到线程池的时候</p><ol><li>看是否小于核心线程数，如果是，那么创建一个工作线程来执行任务，如果不是则进入2</li><li>看阻塞队列是否已经满了，如果没有满，那么进入阻塞队列中，否则进入3</li><li>如果超过了最大线程数，那么交给RejectedExecutuionHandler来处理任务</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之数据结构</title>
      <link href="/post/6c429b75.html"/>
      <url>/post/6c429b75.html</url>
      
        <content type="html"><![CDATA[<h1 id="说说跳表"><a href="#说说跳表" class="headerlink" title="说说跳表"></a>说说跳表</h1><p>跳表 = 链表 + 多级索引（空间换时间，复杂度为klogn，k为每个几个节点简历一次索引，常数项忽略，那就是logn）<br>允许快速查询，给链表增加索引，查找数据首先在索引层进行遍历，相当于在一个范围内查找，索引层可以多层</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一问一答之项目</title>
      <link href="/post/74fc969.html"/>
      <url>/post/74fc969.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目的难点"><a href="#项目的难点" class="headerlink" title="项目的难点"></a>项目的难点</h1><p>一个单线程web应用，没有spirng对内部的一个调优，且数据库版本较低，当并发数到达一定量的时候，经常会造成线程阻塞的情况</p><ul><li>项目代码4 — 数据库2 — jvm1 — 操作系统0</li><li>在脱离框架后是否可以使用原生技术解决问题—使用HttpUrlConnection来获取IO流，根据流在获取文件（MultipartFile）</li><li>设计模式重构，部分请求在通过并发的方式处理，修改代码减少for循环次数，适度跳出</li><li>流程页面使用页面静态化提高用户访问速度</li><li>将模块抽离，使用spring构建新模块，采取前后端分离的方式</li><li>排除sql语句是否使用了索引（定位慢sql），数据库是否建立了合适的索引</li><li>用缓存来减少数据库的压力 用缓存来减少数据库的压力</li><li>调整jvm堆内存大小</li></ul><h1 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h1><p>秒杀系统就是一个“三高”系统，即高并发、高性能和高可用的分布式系统<br>秒杀设计原则：前台请求尽量少，后台数据尽量少，调用链路尽量短，尽量不要有单点<br>秒杀高并发方法：访问拦截、分流、动静分离<br>秒杀数据方法：减库存策略、热点、异步、限流降级<br>访问拦截主要思路：通过CDN和缓存技术，尽量把访问拦截在离用户更近的层，尽可能地过滤掉无效请求。<br>分流主要思路：通过分布式集群技术，多台机器处理，提高并发能力。</p><h1 id="需求案例"><a href="#需求案例" class="headerlink" title="需求案例"></a>需求案例</h1><ul><li>同时搜索出各个品牌数据银行与策略中心的人群包信息<br>节省性能代码（可用作项目）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        List&lt;A&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ls.add(<span class="keyword">new</span> A(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;10&quot;</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">        ls.add(<span class="keyword">new</span> A(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;20&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">        ls.add(<span class="keyword">new</span> A(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;10&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="comment">//        // 程序运行时间取决于核数</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; collect = getList(ls);</span></span><br><span class="line">        <span class="comment">// 传统方式</span></span><br><span class="line">        List&lt;String&gt; collect = ls.stream().map(a -&gt; a.cal() + <span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">        <span class="comment">//获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMill7is();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;程序运行时间： &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getList</span><span class="params">(List&lt;A&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ls</span><br><span class="line">                .stream()</span><br><span class="line">                .map(a -&gt; CompletableFuture.supplyAsync(() -&gt; a.cal() + <span class="number">2</span>))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .stream()</span><br><span class="line">                .map(CompletableFuture::join)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line">    String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name, String age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>GTA是GMV到AIPL的缩写。指GMV销量，用于反向计算AIPL各环节的人的需求。反向标准是根据过去新客户和老客户的销售比例计算出A、I、P、L的需求体量，再根据不同环节的人群转化率计算出相应的需求人口体量。目的是让品牌在营销上的投入更有针对性。</li></ul><h1 id="项目中用到Redis了吗"><a href="#项目中用到Redis了吗" class="headerlink" title="项目中用到Redis了吗"></a>项目中用到Redis了吗</h1><p>月报跑数据完成之后需要给客户发数据，实时数据会使用Redis，离线的用Hive，一般来说使用Set，List，和Hash结构。<br>发消息会用到模板，每个模板都会有一个独一的id（时间+业务参数），如果要看某天下发的模板，只需要将模板id放入Set中去。<br>看模板的整体链路情况，那么可以用Hash，key位状态，value为人数<br>看某个用户下发的信息，用List即可，使用Redis的数据结构来实现消息的多个维度的统计</p><h1 id="jwt的优缺点"><a href="#jwt的优缺点" class="headerlink" title="jwt的优缺点"></a>jwt的优缺点</h1><p>优点：通用跨语言<br>2. 占用小，便于传输<br>3. 服务端无需保存会话信息，容易水平拓展<br>4. 一处生成，到处使用，可用于分布式系统，解决单点登录的问题</p><p>缺点<br>安全性，使用https防止token被劫持<br>双向解码，不要存储敏感信息</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一问一答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autowired用法案例</title>
      <link href="/post/ce0e685a.html"/>
      <url>/post/ce0e685a.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h1><ul><li>在spring容器中</li><li>在包扫描路径下</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>该注解主要用于创建对象（比较常用的就是CRUD操作）</p><h1 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src.main    </span><br><span class="line">├── java.com.auto.test          // 启动类</span><br><span class="line">│       └── Base.java           // 父接口</span><br><span class="line">│       └── Dog.java            // 子类1</span><br><span class="line">│       └── Cat.java            // 子类2</span><br><span class="line">│       └── MyComponent.java    // 自定义</span><br><span class="line">├── test.java.auto              // 测试类</span><br></pre></td></tr></table></figure><h1 id="测试子类及结论"><a href="#测试子类及结论" class="headerlink" title="测试子类及结论"></a>测试子类及结论</h1><p>先证明@Autowired发挥作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PracticeApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Base dog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功运行并打印<code>猫吃鱼</code><br>结论1：此时Dog类还没有被定义，说明@Autowired是根据类型注入的<br>结论2：@Component必须放在实现类中，如果放到父类中，子类实现其方法无法进行继承（无论有无@Inherited注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Base dog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出<code>狗吃肉</code><br>结论3：因为两个类都实现Base接口，spring无法根据其类型去确定哪一个实现类，会根据名称来确定，如果未指定，则根据变量名确定。此时定义dog，所以输出dog的方法。如果变量名既不是cat也不是dog，那么IDE会提示<code>Could not autowire. There is more than one bean of &#39;Base&#39; type.</code>也无法正常运行</p><p>证明结论2，@Component本身没有实现@Inherited，所以才不能作用于接口吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义接口类并定义继承行为</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponent &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改注解，验证自定义注解可用</span></span><br><span class="line"><span class="meta">@MyComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出<code>狗吃肉</code><br>在将该注解去除，并在Base接口上添加，运行会提示<code>Unsatisfied dependency expressed through field &#39;cat&#39;;</code>无法找到依赖对象，说明没有加入spring容器中，也就证明结论2</p><h1 id="如果多个类实现了一个接口，应该如何指定？"><a href="#如果多个类实现了一个接口，应该如何指定？" class="headerlink" title="如果多个类实现了一个接口，应该如何指定？"></a>如果多个类实现了一个接口，应该如何指定？</h1><p>使用<code>@Qualifier(&quot;cat&quot;)</code>注解，或者使用<code>@Resource(name = &quot;cat&quot;)</code>进行名称指定。这两个注解作用是相同的，但一般使用@Autowired实现</p>]]></content>
      
      
      <categories>
          
          <category> 案例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务笔记</title>
      <link href="/post/659da5b.html"/>
      <url>/post/659da5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud是什么"><a href="#SpringCloud是什么" class="headerlink" title="SpringCloud是什么"></a>SpringCloud是什么</h1><p>微服务一站式解决方案</p><h1 id="Nacos是什么"><a href="#Nacos是什么" class="headerlink" title="Nacos是什么"></a>Nacos是什么</h1><ul><li>服务发现、配置管理、服务管理平台</li><li>注册中心 + 配置中心</li><li>AP（高可用 + 分区容错）或CP（强一致性 + 分区容错）可以来回切换</li><li>存信息AP，经常访问CP</li></ul><h1 id="与ZK的区别"><a href="#与ZK的区别" class="headerlink" title="与ZK的区别"></a>与ZK的区别</h1><ul><li>ZK是CP（强一致性 + 分区容错）</li><li>没有控制台，社区没有nacos活跃</li></ul><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>将读与写分别放于不同的服务器上，主写从读。一主一从或一主多从，适合单机并发读比较多的场景</p><h2 id="如何解决分离后带来的同步问题"><a href="#如何解决分离后带来的同步问题" class="headerlink" title="如何解决分离后带来的同步问题"></a>如何解决分离后带来的同步问题</h2><p>解决了性能问题，如何保证数据一致性，主库同步从库需要时间，如何解决？</p><ul><li>读主库，虽然增加压力，但也有效</li><li>延迟读取</li></ul><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol><li>部署多台数据库</li><li>进行主从复制</li><li>主写从读</li></ol><p>在请求之后加入代理层，用来分发请求。官方的中间件为<code>MySQL Router</code></p><p>或者使用<code>sharding-jdbc</code>，引入jar包使用，<a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/">空降点我</a></p><h2 id="什么是主从复制？"><a href="#什么是主从复制？" class="headerlink" title="什么是主从复制？"></a>什么是主从复制？</h2><p>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>用来解决数据量大造成的性能问题</p><p>sharding-jdbc是常见的工具</p><h2 id="分表的切分方式"><a href="#分表的切分方式" class="headerlink" title="分表的切分方式"></a>分表的切分方式</h2><p>垂直切分：竖着切，将字段分开</p><p>水平切分：将数据进行切分，比如去年和今年的数据分开</p><h2 id="什么情况下需要分库分表"><a href="#什么情况下需要分库分表" class="headerlink" title="什么情况下需要分库分表"></a>什么情况下需要分库分表</h2><ul><li>数据达千万，读写缓慢（分表）</li><li>数据库占用过大，备份时间长（分库）</li><li>并发太大（分库）</li></ul><h2 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h2><ul><li>无法join，分到俩库里了。只能进行一个中转操作</li><li>事务问题</li><li>需要分布式id</li></ul><h1 id="ZK"><a href="#ZK" class="headerlink" title="ZK"></a>ZK</h1><p>服务于分布式系统，用来做统一配置管理，命名服务，分布式锁，集群管理</p><p>zk的数据结构叫znode，可以监听数据变化与节点增减</p><p>统一配置管理：一个公用的common.yml可以挂载znode节点上，如果配置文件变了可及时响应</p><p>统一命名服务：通过域名访问具体ip</p><p>分布式锁：在一个lock节点下获得锁，取判断是否为最小节点，如果是则获得锁，不是就监听比自己小1的节点</p><p>集群：感知节点增减，master进行动态选举</p><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>至少有3个节点，如果一个挂了，还有另外一个提供服务</p><p>不是越多越好，通讯成本增高，容易脑裂（多个leader，如何避免，leader最后启动）</p><p>为啥为奇数：过半机制，解决成本</p><p>选举机制：过半原则：如果添加一个节点，leader会测试是否可用，给follwer发信息，如果得到一半反馈，则认为当前集群是可靠的</p><p>如果leader挂了，需要投票</p>]]></content>
      
      
      <categories>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC笔记</title>
      <link href="/post/153083dc.html"/>
      <url>/post/153083dc.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h3><p>java.util.concurrent工具包的简称，处理线程的一个工具包</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>资源分配的最小单位，在系统中运行的一个应用程序，每个进程都有自己的内存空间和系统资源</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>程序执行的最小单位，一个进程包含多个线程。程序调度的基本单元。<br>线程分为用户线程（默认线程）和守护线程。用户线程会完成程序的业务操作<br>守护线程做一些默默的事情比如GC。用户线程全部结束则守护线程结束</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>monitor监视器，也就是锁（synchronized），方法调用如果有synchronized，执行线程前首先要成功持有管程。在方法执行期间，只有管程的线程，其他任何线程都无法获取到同一个管程。</p><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://image.leidl.top/img/20210901110727.webp" alt="image-20210901110727"></p><p>新建、就绪、阻塞、等待1、等待2、终结</p><p>waiting（不见不散—不来就一直等）</p><p>timed_waiting（过时不候）</p><h4 id="wait和sleep"><a href="#wait和sleep" class="headerlink" title="wait和sleep"></a>wait和sleep</h4><p>1、sleep是Thread的静态方法，wait是object方法，任何对象都能调用</p><p>2、sleep不会释放锁，也不占用锁。wait会释放锁，前提是先占用锁（代码在synchronized中）</p><p>3、都可以被interrupted方法中断</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发：有同时处理多个任务的能力，不一定要同时。一个处理器对多个任务。eg。秒杀，抢票</p><p>并行：同时执行任务的能力。多个处理器对多个任务。</p><p>区别在于是否可以同时</p><p>就好比并发是一个窗口很多人买票，并行是多个窗口很多人买票</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>用来解决多线程访问资源的同步性，可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。</p><p>在1.6之前是重量级锁，之后进行了锁升级，减少锁操作带来的开销</p><h3 id="多线程编程步骤"><a href="#多线程编程步骤" class="headerlink" title="多线程编程步骤"></a>多线程编程步骤</h3><p>1、创建资源类</p><p>2、在资源类中创建属性和操作方法</p><p>3、创建多个线程，调用资源类的操作方法</p><p>4、防止虚假唤醒问题</p><h3 id="LOCK接口"><a href="#LOCK接口" class="headerlink" title="LOCK接口"></a>LOCK接口</h3><p>可重入锁，比synchronized拥有更广泛的操作</p><h3 id="synchronized与lock区别"><a href="#synchronized与lock区别" class="headerlink" title="synchronized与lock区别"></a>synchronized与lock区别</h3><ol><li>接口关键字。lock是一个接口，synchronized是关键字，内置语言实现</li><li>死锁问题。synchronized发生异常会自动释放占有的锁，因此不会导致死锁<br>lock如果没有unlock释放锁，很可能死锁，所以最好放到finally中</li><li>lock可以响应中断，synchronized不行，会一直等待</li><li>是否获取锁。lock可以知道有没有获取锁，synchronized不行</li><li>lock可以提高多个线程读操作的效率</li></ol><p>总结</p><p>竞争资源激烈的情况下，推荐使用lock</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ol><li>保证可见性，防止主存与缓存数据的不一致。指示jvm，到主存中读取数据</li><li>防止JVM指令重排，保证多线程环境下也能正常运行</li><li>不支持原子性</li><li>写的时候直接刷新到主内存中，读的时候直接从主内存中读取，复制到工作内存</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>单一赋值，不包含i++之类的复合赋值</li><li>读多于写，结合内部锁减少内存开销</li><li>单例模式 — 双重检查（先判空再加锁在判空）</li></ul><h3 id="volatile为什么能保证可见和重排序"><a href="#volatile为什么能保证可见和重排序" class="headerlink" title="volatile为什么能保证可见和重排序"></a>volatile为什么能保证可见和重排序</h3><p><code>内存屏障</code>。其实就是JVM的一种指令，JMM的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些指令，实现了可见性和有序性<br>写屏障：告诉CPU在看到store指令，就必须把指令之前的所有数据都同步到主内存中<br>读屏障：在看到Load指令后，让工作内存和cpu高速缓存中的数据失效，重新回到主存中获取数据<br>细分四种屏障类型（了解）<br><img src="https://image.leidl.top//imgimage-20221123154502368.png" alt="image-20221123154502368"></p><h3 id="为什么volatile不保证原子性"><a href="#为什么volatile不保证原子性" class="headerlink" title="为什么volatile不保证原子性"></a>为什么volatile不保证原子性</h3><p>volatile的可见性保证线程每次在读的时候数据是最新的。但多线程环境下，计算赋值的操作屡次出现，若在计算期间，被volatile修饰的值修改完毕（其他线程），则当前线程的计算作废，所以操作可能会出现丢失问题，进而导致数据不一致</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>数据库、redis、zk</p><p>特点：同一时间，只有一个客户端可以获取锁，其他客户端等待</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>让每个线程都有自己的本地变量，从而避免线程安全问题<br>（如何才能不争抢，1.用锁控制（synchronized或lock），2.人手一份（Threadlocal））</p><ul><li>不解决线程间的共享数据问题</li><li>避免加锁，map仅自己线程访问</li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; messages = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        holder.get().messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; messages = holder.get().messages;</span><br><span class="line">        holder.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span> + holder.get().messages.size());</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocalTest.add(<span class="string">&quot;一枝花算不算浪漫&quot;</span>);</span><br><span class="line">        System.out.println(holder.get().messages);</span><br><span class="line">        ThreadLocalTest.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程在往ThreadLocal里放值的时候，都会往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。其中的value是一个弱引用<br>key是当前ThreadLocal，value是当前值</p><ul><li>强引用：new出来的对象。宁愿抛OOM，也不会被回收</li><li>软引用：被softreference修饰，在内存将要溢出的时候进行回收</li><li>弱引用：被weekreference修饰，只要发生垃圾回收，那么就会被回收</li><li>虚引用：被phantomreference修饰，用队列接收对象即将死亡的通知</li></ul><h4 id="实现场景"><a href="#实现场景" class="headerlink" title="实现场景"></a>实现场景</h4><p>数据库。spring，threadLocal的存储类型是一个map，key是datasource，value是connection（为了应对多数据源），用threadLocal保证统一线程获取的是一个connection对象，从而保证一次事务所有操作需要在统一数据库连接上</p><h4 id="ThreadLocal的内存泄露"><a href="#ThreadLocal的内存泄露" class="headerlink" title="ThreadLocal的内存泄露"></a>ThreadLocal的内存泄露</h4><p>详细文章：<a href="https://www.jianshu.com/p/dde92ec37bd1">https://www.jianshu.com/p/dde92ec37bd1</a></p><p><img src="https://image.leidl.top//imgThreadLocal.png" alt="ThreadLocal"></p><p>ThreadLocal中包含了ThreadLocalMap，然而ThreadLocalMap的对象是在Thread中的，如果Thread没有结束，则ThreadLocalMap一直不会释放，假如ThreadLocalMap中设置了很多值，而且没有手动设置remove()，则可能会造成内存泄露。</p><h4 id="为什么将map中的key设置为弱引用"><a href="#为什么将map中的key设置为弱引用" class="headerlink" title="为什么将map中的key设置为弱引用"></a>为什么将map中的key设置为弱引用</h4><p>假设如果存储的强引用，无法通过threadLocal==null来对threadLocal进行回收。<br>在业务代码中执行threadLocal==null操作，由于threadLocalMap的Entry强引用threadLocal，因此在gc的时候进行可达性分析，threadLocal依然可达，对threadLocal并不会进行垃圾回收，这样就无法通过threadLocal==null来对threadLocal进行回收，出现逻辑错误</p><p>如果为弱引用，在threadLocal生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。<br>在threadLocal的生命周期里（set,getEntry,remove）里，都会针对key为null的脏entry进行处理。但还可能出现内存泄漏，所以还需要手动remove</p><h4 id="为什么能实现线程隔离"><a href="#为什么能实现线程隔离" class="headerlink" title="为什么能实现线程隔离"></a>为什么能实现线程隔离</h4><p>在于其中的map，只初始化一次，分配一块内存地址</p><h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>申请完内存，用完没有及时的进行释放，自己又没法在用，系统也无法进行回收</p><h3 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h3><p>让线程按照既定的步骤去执行</p><p>可能会出现的问题：虚假唤醒，就是自己本来是wait状态，然后别人又进行了唤醒，那么他就会执行下面的逻辑，所以状态需要一直进行判断，所以判断状态需要放到while中</p><h3 id="线程间的定制化通信"><a href="#线程间的定制化通信" class="headerlink" title="线程间的定制化通信"></a>线程间的定制化通信</h3><p>线程按照顺序执行A执行完通知B执行完通知C，以此类推，执行10轮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DIY</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition1 = lock.newCondition();</span><br><span class="line">    Condition condition2 = lock.newCondition();</span><br><span class="line">    Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print3</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i+<span class="string">&quot;轮数:&quot;</span>+loop);</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知给B</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print6</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+i+<span class="string">&quot;轮数:&quot;</span>+loop);</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知给B</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print9</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+i+<span class="string">&quot;轮数:&quot;</span>+loop);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知给B</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DIY diy = <span class="keyword">new</span> DIY();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    diy.print3(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    diy.print6(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    diy.print9(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全的核心理念：要么只读，要么加锁</p><p>解决线程安全是进阶的重要能力</p><p>集合</p><p>CopyOnWriteArrayList代替ArrayList</p><ul><li>读操作没有锁，因为是数组直接替换，不需要修改，没有安全问题</li><li>写操作加了ReentrantLock，保证同步，避免多线程创建多个副本的问题</li></ul><p>CopyOnWriteArraySet代替ArraySet</p><p>ConcurrentHashMap代替HashMap</p><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>对于单链表，查询需要从头查到尾，效率低下。调表的意义在于可以跳着查，提高效率，与平衡树不同的是，平衡树添加和删除需要对全局进行调整，而跳表是局部的。这直接导致锁范围的不同，在高并发场景下，会有更好的性能</p><p>本质是维护多个链表，没上面一层都是下面的子集，如图找18的元素，可以进行跳跃式查找，效率得到明显的提升<br><img src="https://image.leidl.top/img/20210918114140.jpg" alt="20210918114140"></p><p>可以得出，跳表是一种利用空间换时间的算法。哈希不保证有序性，如果需要有序性，可以考虑跳表的实现实现ConcurrentSkipListMap</p><h3 id="AQS组件"><a href="#AQS组件" class="headerlink" title="AQS组件"></a>AQS组件</h3><p>wait() —&gt; CountDownLatch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;号线程执行了&quot;</span>);</span><br><span class="line">                <span class="comment">//每执行一个线程计数器-1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,i+<span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有变为0则等待</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;最后执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>notify() —&gt; Senaphore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//信号量设置为3，表示线程数不能超过此值，超过会等待</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建6个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占资源</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                    <span class="comment">//留有时间抢占资源</span></span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">3</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放，别的线程唤醒继续抢车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程锁的8种情况"><a href="#多线程锁的8种情况" class="headerlink" title="多线程锁的8种情况"></a>多线程锁的8种情况</h3><p>定义两个方法，都加synchronized，创建两个线程，先后调用方法1，2，线程中间睡1s</p><p>①标准调用，1—2</p><p>②在第一个方法中睡4s，整体会先睡4s，然后正常调用</p><p>③新建普通方法3替换2，不加synchronized，调用顺序3—1</p><p>④两个对象调用，先2后1，锁的是一个对象</p><p>⑤方法前加static，跟②相同</p><p>⑥方法前加static，用两个对象调用，跟②相同，类对象是一个</p><p>⑦方法1静态，2普通，先调用普通，在调用静态</p><p>⑧⑦的条件，两个对象调用，结果同⑦</p><p><strong>总结</strong></p><p>对于普通同步方法，锁的是当前实例对象</p><p>对于静态同步方法，锁的是类对象</p><p>同步方法块，锁的是括号中配置的对象</p><h3 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h3><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p>悲观锁：对任何操作都是悲观的，认为它访问的时候别人也会访问，所以在操作前会进行上锁，操作后解锁，安全，但效率低，只能一个一个进行操作。比如synchronized和lock都是悲观锁<br><img src="https://image.leidl.top/img/20210901111924.png" alt="image-20210901111923904"></p><p>乐观锁，对任何操作都是乐观的，认为访问的时候别人不会访问<br>每次操作会给定一个版本号，如果版本号不同则不允许操作<br>最常使用的是CAS自旋算法<br>适合读多写少的场景<br><img src="https://image.leidl.top/img/20210901112004.png" alt="image-20210901112004815"></p><p>八个案例说明锁的场景<br>完整的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendMail();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证线程的先后顺序</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问以下场景的输出是什么<br>Q1：直接运行以上程序<br>A：sendMail（1）、sendSms（2）<br>Q2：sendMail加入sleep3秒中<br>A：1、2（sleep不释放锁，锁的是所有同步方法）<br>Q3：向第二个thread中加入hello无锁方法<br>A：hello，1（不和你争）<br>Q4：有两个对象调用<br>A：2,1（不是一个对象，不争抢同一把锁）<br>Q5：同步方法变为static方法<br>A：1,2（类锁，无论几个对象锁的都是当前类）<br>Q6：在Q5的基础上，两个对象调用<br>A：1,2<br>Q7：1个静态，1个同步<br>A：2,1（静态与同步之间没有竞争关系）<br>Q8：在Q7基础上两个对象调用<br>A：2,1</p><p>字节码synchronized<br>同步代码块使用的是monitorenter和monitorexit指令控制的，有两个exit，一个用于正常退出，一个用于异常退出<br>普通同步方法会检查ACC_SYNCHRONIZED是否被设置，如果有当前线程会持有monitor锁，然后执行方法，最后完成后后释放<br>静态同步方法多了一个ACC_STATIC</p><h4 id="独占锁共享锁"><a href="#独占锁共享锁" class="headerlink" title="独占锁共享锁"></a>独占锁共享锁</h4><p>独占锁：只能被一个线程享有。synchronized和lock实现类就是独占锁，并发不行，性能较低<br><img src="https://image.leidl.top/img/20210901112224.png" alt="image-20210901112224415"></p><p>共享锁：可以被多个线程享有。如果一个线程加了共享锁，那么就不能加独占锁。ReentrantReadWriteLock就是共享锁<br><img src="https://image.leidl.top/img/20210901112357.png" alt="image-20210901112357119"></p><h4 id="独占锁和共享锁的体现"><a href="#独占锁和共享锁的体现" class="headerlink" title="独占锁和共享锁的体现"></a>独占锁和共享锁的体现</h4><p>互斥锁 ：独占锁的体现，具有唯一性和排他性。<br><img src="https://image.leidl.top/img/20210901112740.png" alt="image-20210901112740335"><br>读写锁：共享锁的体现。读写锁管理一组锁，一个是只读的锁，一个是写锁。<br>读锁：共享锁，会发生死锁，可以多个一起读</p><p>写锁：独占锁，会发生死锁，只能一个进行写<br>ReentrantReadWriteLock是读写锁，读读可以共享，提高性能，存在的问题，存在锁饥饿的问题，一直读的时候，程序没法写。读不可以写，写可以读。<br><img src="https://image.leidl.top/img/20210901112911.png" alt="image-20210901112911028"></p><h4 id="读写锁的降级"><a href="#读写锁的降级" class="headerlink" title="读写锁的降级"></a>读写锁的降级</h4><p>写入锁降低为读锁，目的提高数据的可见性</p><p>jdk8说明</p><p>1、获取写锁</p><p>2、获取读锁</p><p>3、释放写锁</p><p>4、释放读锁</p><p>此时读锁不能升级为写锁</p><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><p>表锁：对整张表上锁，对某条记录修改，整个表都不能访问，必须等其释放锁，不会有死锁</p><p>行锁：操作哪条记录就对哪条记录上锁，别人还可以访问别的记录，会有死锁</p><h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>公平锁：雨露均沾，每个线程都会分到，但不是绝对平均</p><p>非公平锁：没有顺序，不一定每个线程都会分到，分配不均<br>默认new出来的是非公平锁，非公平锁可能会导致线程饿死的情况，活都给别的线程分配了，分配不均，但执行效率高。而公平锁会做到雨露均沾，但不保证绝对平均，效率相对会低一点<br><img src="https://image.leidl.top/img/20210901113320.png" alt="image-20210901113319936"></p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>锁里面还能调锁，又叫递归锁。synchronized是隐式的，lock是显示的，都是可重入锁<br>应用场景：递归调用<br><img src="https://image.leidl.top/img/20210901113358.png" alt="image-20210901113357915"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mehtodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> <span class="comment">// Do some magic tings</span></span><br><span class="line"> mehtodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mehtodB</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> <span class="comment">// Do some magic tings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>线程在没有锁的时候不会被挂起，而是处于一个忙循环状态，类似等待的状态，这个又叫自旋<br><img src="https://image.leidl.top/img/20210901113736.png" alt="image-20210901113736015"></p><p>目的：减少被挂起的几率，线程的唤醒和挂起很耗费资源，但一致自旋也是耗性能，所以并不适合于时间长的并发情况<br>如下代码，CAS 操作如果失败就会一直循环获取当前 value 值然后重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.6又引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>互相等待对方去释放锁，没有外力干涉，就无法执行下去。A需要B持有的资源，但B不释放，B需要A持有的资源，但A不释放，都在等对方释放</p><p>产生原因</p><p>1、系统资源不足</p><p>2、进程推进不合适</p><p>3、资源分配不当</p><p>如何查看</p><p>jstack，jvm自带工具，jstack 进程号，查看是否死锁</p><p>Java案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个对象</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LockA 开始执行&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;持有锁A，试图获取B&quot;</span>);</span><br><span class="line">                <span class="comment">// 为了第二个线程也能启动？</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LockB 开始执行&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;持有锁B，试图获取A&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LockA 开始执行</span><br><span class="line">LockB 开始执行</span><br><span class="line">持有锁A，试图获取B</span><br><span class="line">持有锁B，试图获取A</span><br></pre></td></tr></table></figure><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>提升锁性能，减少获取和释放锁带来的消耗，提供4种状态无锁、偏向锁、轻量级锁和重量级锁<br>无锁：乐观锁</p><p>偏向锁：指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。第一次访问时id为空，jvm为其线程设置id</p><p>主要作用：当同一段同步代码被一个线程访问多次，那么便在后续访问时自动获得锁<br>Java15逐步废除偏向锁，维护成本变高</p><p>轻量级锁：当线程竞争变得比较激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待上一个线程释放锁。判断id是否一致若一致使用该对象，不一致升级为轻量级锁<br>根据上一次自旋的状态来确定，若上次成功，最下次自旋次数增加。失败则减少</p><p>重量级锁：也是互斥锁。如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>锁粗化：能不上锁就不上，范围能小就小</p><p>锁消除：指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除。<br>比如这个for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    stringBuffer.append(<span class="string">&quot;dali&quot;</span>);</span><br><span class="line">    stringBuffer.append(<span class="string">&quot;技术分享&quot;</span>);</span><br><span class="line">    stringBuffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知StringBuffer是一个线程安全类，但stringBuffer变量属于局部变量，存于栈中，栈为线程私有本来就是线程安全，而append方法是一个同步方法，只会白白浪费系统资源，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为锁消除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><p><img src="https://image.leidl.top//imgimage-20221118211931615.png" alt="image-20221118211931615"></p><h3 id="callable接口"><a href="#callable接口" class="headerlink" title="callable接口"></a>callable接口</h3><p>创建线程的方式</p><p>1、继承Thread类</p><p>2、实现Runnable接口</p><p>3、callable接口（有返回值的Runnable）</p><p>4、线程池</p><p>传统创建线程的方式，无法获取线程返回结果，为了支持该功能，增加了callable接口</p><p>与Runnable的区别</p><p>1、是否有返回值，callbable有</p><p>2、是否抛出异常，callable抛</p><p>3、实现方法名不同，callable实现call()，另一个是run()</p><p>如何利用callable创建线程</p><p>Thread没有提供callable的参数，那么就需要找到一个类，能够建立起runnable与callable的关系</p><p>Runnable有一个实现类，FutureTask，可以传递callable接口</p><p>FutureTask：在不影响主线程的情况下，单开一个线程，做其他事情，最后在进行汇总</p><p>创建一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(MyThread::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone()) &#123;</span><br><span class="line">            <span class="comment">//不完成，输出wait</span></span><br><span class="line">            System.out.println(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用get方法</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">        <span class="comment">//调用第二次的时候直接返回</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JUC辅助类"><a href="#JUC辅助类" class="headerlink" title="JUC辅助类"></a>JUC辅助类</h3><p>1、减少计数</p><p>CountDownLatch</p><p>基于AQS实现，在构建对象的时候传入的值会赋给AQS的关键变量state，-1操作是利用CAS将state-1，执行await方法，判断state是否为0，不为0则加入队列中，将该线程进行阻塞（头节点除外，会自旋等待，当state为0时，将剩余的在队列中阻塞的节点一并唤醒）。</p><p>await实际上让头节点一直在等待state为0时，释放等待的线程</p><p>设置一个计数器类，countDown()方法可以让初始值-1，允许一个线程或多个线程等待，直到这些线程完成他们的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;号线程执行了&quot;</span>);</span><br><span class="line">                <span class="comment">//每执行一个线程计数器-1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,i+<span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有变为0则等待</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;最后执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、循环栅栏</p><p>CyclicBarrier，当线程到达某状态后，暂停下来等待其他的线程，所有线程都到达之后才会继续执行，阻塞的是任务线程，主线程是不受影响的</p><p>线程到达等待数执行条件，相较于CountDownLatch来说它是可复用的。它没有使用AQS的state变量，借助ReentrantLock和condition等待唤醒，在构建该对象时，传入的值会赋给内部维护的count变量，也会赋值给parties变量（复用的关键），调用await会使count-1，利用ReentrantLock保护线程的安全性，如果count不为0，则添加进condition队列中，当count=0，将队列中的线程全部唤醒，并将parties的值重新赋值为count实现复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程等待数已达条件&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程创建完毕&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、信号量机制</p><p>Semaphore，信号量机制，到达某个临界值会处于等待状态，直到线程被释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//信号量设置为3，表示线程数不能超过此值，超过会等待</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建6个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占资源</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                    <span class="comment">//留有时间抢占资源</span></span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">3</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放，别的线程唤醒继续抢车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><img src="https://image.leidl.top/img/20210818170913.png" alt="image-20210818170912835"></p><p>当队列元素满之后就不能放了，就阻塞。如果元素为空那么就不能取了，就阻塞</p><p>为什么使用：不需要关系什么时候阻塞线程，什么时候唤醒线程。阻塞队列已经实现了</p><h3 id="分类及方法"><a href="#分类及方法" class="headerlink" title="分类及方法"></a>分类及方法</h3><p>BlockingDeque与BlockingQueue</p><p>ArrayBlockingQueue（常用）数组的队列</p><p>基于数组实现，内部维护了一个定长的数组，以便缓存队列中的数据对象，是一个常用的阻塞队列</p><p>LinkedBlockingQueue（常用）链表的队列</p><p>基于链表实现，大小默认值为int的最大值，是一个常用的阻塞队列</p><p>DealyQueue</p><p>使用优先级队列实现延迟无界阻塞队列，没有大小限制</p><p>PriorityBlockingQueue</p><p>支持优先级排序的无界阻塞队列</p><p>SynchronousQueue</p><p>单个元素的队列</p><p>LinkedTransferQueue</p><p>由链表组成的无界阻塞队列</p><p>LinkedBlockingDeque</p><p>由链表组成的双向阻塞队列</p><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p><img src="https://image.leidl.top/img/20210818172323.png" alt="image-20210818172323453"></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>维护者多个线程，等待管理和分配，可以保证线程的充分利用，还能防止过分调度。控制可运行的线程数量，将任务放在队列中，线程不够用了则任务等待。</p><h4 id="为什么需要线程池（主要特点）"><a href="#为什么需要线程池（主要特点）" class="headerlink" title="为什么需要线程池（主要特点）"></a>为什么需要线程池（主要特点）</h4><p>降低资源消耗：重复利用一定的线程，频繁创建线程会消耗资源，还会降低系统稳定性</p><p>提高响应速度：当任务到达时，不需要等待创建线程的时间</p><p>便于管理</p><h4 id="项目中用到了么"><a href="#项目中用到了么" class="headerlink" title="项目中用到了么"></a>项目中用到了么</h4><p>用到了，我负责的项目模块中有一个年度价值统计，需要创建统计模板定时发送信息。每个模板对应一个id，需要在hdfs中去找这个文件，遍历查找操作使用了线程池，因为hdfs遍历操作是一个费时任务，将此过程进行异步化，提高系统的吞吐量，使用ThreadPoolExcutor创建线程池，而不是使用executor（阿里手册不推荐，使用原生方法更能理解线程池运行规则，避免资源被耗尽的风险）</p><h4 id="相关架构"><a href="#相关架构" class="headerlink" title="相关架构"></a>相关架构</h4><p>在Java中使用Executor框架实现</p><h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池，有固定的线程数</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//创建一个线程</span></span><br><span class="line">ExecutorService executorService1 = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//可扩容线程</span></span><br><span class="line">ExecutorService executorService2 = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executorService2.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;处理业务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executorService2.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种创建线程池的方法底层都是new的ThreadPoolExecutor</p><p>ThreadPoolExecutor的七个参数介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>corePoolSize：核心/常驻线程数</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：活跃时间/存活时间</p><p>unit：时间单位</p><p>workQueue：阻塞队列</p><p>threadFactory：线程工厂，用于创建线程</p><p>handler：拒绝策略，没有能力处理</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://image.leidl.top/img/20210818180337.png" alt="image-20210818180336914"></p><p>执行execute方法的时候才会创建线程，核心线程满了之后，其余的线程会创建到阻塞队列中<br>阻塞队列满之后，会在最大线程数创建线程<br>如果都满了，则会执行<code>拒绝策略</code>。最大线程池中的线程会优于阻塞队列中的线程执行，俗称插队</p><p><img src="https://image.leidl.top/img/20210915161942.png" alt="image-20210915161942"></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>1、AbortPolicy（默认）：直接抛异常</p><p>2、CallerRunsPolicy：将任务回退到调用者，又称调用者模式</p><p>3、DiscardOldestPolicy：抛弃队列中等待最久的业务，把当前业务加入队列中</p><p>4、DiscardPolicy：不处理也不拒绝</p><p>在实际开发中，以上三种创建线程池的方式都不用，自定义线程池去实现。Java开发手册中说道</p><p><img src="https://image.leidl.top/img/20210818182326.png" alt="image-20210818182326249"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程池</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">2L</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AbstractQueuedSynchronizer（抽象的队列同步器），在类<code>java.util.concurrent.locks</code>包下面，它是一个框架，可以构造出大量的同步器比如ReentrantLock、Semaphore<br>主要用于解决锁分配给谁的问题（FIFO和state）<br>是什么：volatile+cas机制实现的锁模板，保证了代码的同步性和可见性，而aqs封装了线程阻塞等待挂起，解锁唤醒其他线程的逻辑，aqs子类只需根据状态变量，判断是否key获取锁，是否释放锁，使用LockSupport挂起，唤醒线程即可</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如果被请求的共享资源空闲，则当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。如果被请求资源被占用，则需要一套唤醒机制，AQS利用CLH实现，如果获取不到资源的线程则进入队列中</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请<br>求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><h4 id="两种资源共享方式"><a href="#两种资源共享方式" class="headerlink" title="两种资源共享方式"></a>两种资源共享方式</h4><p>独占（Exclusive）：只有一个线程可以执行如ReentrantLock</p><p>共享（Share）：多个线程可以同时执行</p><h3 id="Fork-Join分支合并框架"><a href="#Fork-Join分支合并框架" class="headerlink" title="Fork/Join分支合并框架"></a>Fork/Join分支合并框架</h3><p>将大任务拆分为多个子任务去执行，合并最后的计算结果，并输出</p><p>分割fork，合并join</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//执行规则，拆分差值不超过10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="comment">//结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="comment">//处理结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="comment">//创建有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写逻辑，拆分与合并</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断相加值</span></span><br><span class="line">        <span class="keyword">if</span> ((end - begin) &lt;= VALUE) &#123;</span><br><span class="line">            <span class="comment">//相加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进一步拆分,获取到中间值</span></span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">            MyTask left = <span class="keyword">new</span> MyTask(begin, mid);</span><br><span class="line">            MyTask right = <span class="keyword">new</span> MyTask(mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//拆分</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            result = left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建拆分对象</span></span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建合并池对象</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line">        <span class="comment">//获取合并的结果</span></span><br><span class="line">        Integer result = forkJoinTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5050</span><br></pre></td></tr></table></figure><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>Furture是Java5新增的接口，提供了一步并行计算的功能</p><p>需要用到Runnable接口，Callable接口，Future接口和具体实现类</p><h4 id="Runnable接口与Callable接口的比较"><a href="#Runnable接口与Callable接口的比较" class="headerlink" title="Runnable接口与Callable接口的比较"></a>Runnable接口与Callable接口的比较</h4><p>1.Runnable无返回值，不抛异常<br>2.Callable有返回值，抛异常</p><h4 id="FutureTask怎么来的"><a href="#FutureTask怎么来的" class="headerlink" title="FutureTask怎么来的"></a>FutureTask怎么来的</h4><p>需要具备三个能力<br>1.多线程 — runnable<br>2.有返回 — callable<br>3.有异步 — future</p><p><code>public FutureTask(Callable&lt;V&gt; callable) &#123;&#125;</code></p><p><img src="https://image.leidl.top//imgimage-20221115142128567.png" alt="image-20221115142128567"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FutureTask如何变为CompletableFuture"><a href="#FutureTask如何变为CompletableFuture" class="headerlink" title="FutureTask如何变为CompletableFuture"></a>FutureTask如何变为CompletableFuture</h4><p>FutureTask的缺点<br>1.get阻塞。只要调用了，就会去找当前furture线程，如果没有完成，则会阻塞其他线程的运行。所以一般放在程序后面，假如需要设置自己的时间，过时不候，如果到规定时间无法拿回结果，那么就会抛出超时异常<br>2.isDone轮询会耗费cpu资源，也不见得会返回结果<br>3.总结FutureTask对结果的获取不是很友好，所以出现了CompletableFuture可以用声明式的方式优雅的处理需求<br>4.CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方</p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>1.官方不建议直接使用new构造方法创建对象<br>2.run开头的无返回值（短的没有收获），supply开头没有返回值（长的才配拥有）<br>3.减少了阻塞和轮询<br>4.java8增加<br>5.可以发现并没有使用线程池，因为默认使用了ForkJoinPool线程池<br>6.用thenRun是当前指定线程池，并且会影响之后的。thenRunASync异步，只会影响当前线程池<br>7.指定的线程池可能用不上，会默认用快的（main）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有返回值</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//当xxx完成之后调用,t是返回值，u是异常</span></span><br><span class="line">completableFuture1.whenComplete((t,u)-&gt;&#123;</span><br><span class="line">    System.out.println(t+<span class="string">&quot;:&quot;</span>+u); </span><br><span class="line">&#125;);</span><br><span class="line">completableFuture1.get();</span><br><span class="line"><span class="comment">//无返回值</span></span><br><span class="line">CompletableFuture&lt;Void&gt; completableFuture2 = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">completableFuture2.get();</span><br></pre></td></tr></table></figure><h3 id="线程池的大小确定"><a href="#线程池的大小确定" class="headerlink" title="线程池的大小确定"></a>线程池的大小确定</h3><p>线程过多会导致增加上下文切换成本</p><blockquote><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。<br>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。<br>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少</p></blockquote><p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</p><p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p><p>有一个简单并且适用面比较广的公式：</p><p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<br>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。<br>如何判断是 CPU 密集任务还是 IO 密集任务？</p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>原子类，位于<code>java.util.concurrent.atomic</code>下，总共4类。基本类型，数组类型，引用类型，对象的属性修改类型</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>对线程对待机制（wait和notify）的优化与提升。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>compare and swap比较并交换<br>有3个操作数，内存数V，旧的预期值A，要修改的值B，当且仅当V==A，则将V修改为B，否则什么都不做或重来（自旋）</p><p>非阻塞原子性操作，由硬件保证，CAS是一条CPU的原子指令（由unsaef类提供的一种CAS方法）<br><code>执行指令时会发生什么？</code><br>会判断当前系统是否为多核系统，如果是就给总线加锁，实际上利用了CPU资源</p><h3 id="unsafe类"><a href="#unsafe类" class="headerlink" title="unsafe类"></a>unsafe类</h3><p>是CAS的核心类，由Java的native方法访问底层系统，该类可直接操作内存中的数据<br>CAS是一种原语（操作系统范畴，由若干条指令组成，用于完成一个功能），原语必须是连续的，一起成功或失败，也就是说CAS是一条CPU的原子指令，不会造成数据不一致的问题</p><h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><p>如果自旋时间过长会导致开销很大<br>ABA问题，尽管结果是成功的也不能保证过程就没有问题。<br>比如ab线程，a修改值v被挂起，此时b线程修改了v为v1，又改了回去v，这时候a拿到资源发现还是预期v，那么也会进行更新。解决方式：用版本号</p><p>热点点赞器 — LongAdder，用于替换AtomicLong，性能好，减少乐观锁重试次数</p><h3 id="LongAdder为什么这么快？"><a href="#LongAdder为什么这么快？" class="headerlink" title="LongAdder为什么这么快？"></a>LongAdder为什么这么快？</h3><p>空间换时间，降低冲突概率。<br>基本思路是<code>分散热点</code>，将值分散到cell数组中，不同线程会命中到数组的不同槽中，各个线程只能对自己那个槽的值进行CAS操作，热点被分散，冲突概率降低。获取结果值，只需将各个槽累计相加即可       </p><p><img src="https://image.leidl.top//imgimage-20221205182825036.png" alt="image-20221205182825036"></p>]]></content>
      
      
      <categories>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机性能指标展现-3</title>
      <link href="/post/96b5906.html"/>
      <url>/post/96b5906.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://leidl.top/post/7e6c6990">计算机性能指标展现-2</a></p><p>以上为上一篇链接。计算机指标1获取了Linux指标的一些信息，这篇文章是获取hdfs的数据，也是为了与大数据挂钩，实现思路也和第一篇差不多，举一反三么，学会这个思路，什么都可以获取，比如一些znone节点健康信息之类的，<strong>重要不是获取什么，而是怎么获取</strong>。</p><p><strong>gitee源码</strong>：<a href="https://gitee.com/leidl97/visual-display-linux">visual-display-linux</a></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>Java利用ssh连接Linux</li><li>将命令得出的字符信息进行处理</li><li>提供一个可视化模板</li><li>进行前后端联动，异步将数据传输到页面上</li></ol><p>重复的步骤我就不写了，可以看计算机指标1（点上方链接就可以）</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过Linux的命令去返回字符串</p><p>获取hdfs健康信息的命令是：<strong>dfs dfsadmin -report</strong></p><blockquote><p>这里需要注意的是，此命令耗时<strong>3秒</strong>左右，所以做工具类方法的时候需要在一个方法中处理，不然一个用3秒，多了就吃不消了。还有这个命令本身并不提供，这里说的是即使你/etc/profile下面配了也不行。如下图</p></blockquote><p><img src="https://pic4.zhimg.com/v2-fe55337a40c2cfc8dae8782bad3bafb7_b.png" alt="img"></p><p>原因简单的说一下吧，不想了解的跳过</p><blockquote><p>jsch方式通过SSH2连接的。而SSH直接执行远程命令和脚本，会使用Bash的non-interactive + non-login shell模式，它会创建一个shell，执行完脚本之后便退出，不再需要与用户交互。 non-interactive shell 执行它创建的脚本，默认情况下这个环境变量并没有设置。 no-login shell 他代表不会去执行/etc/profile文件，而会去用户的HOME目录检查.bashrc并加载。 那怎么解决？通过原因我们可以知道需要在当前用户下.bashrc文件末添加环境变量，也就是说如果当前你使用的是root用户，那么修改的就是/root/.bashrc这个文件。第二种方式就是运行的时候命令前加一句环境变量，如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/opt/hadoop-2.7.1/bin:/opt/hadoop-2.7.1/sbin;hdfs dfsadmin -report</span><br></pre></td></tr></table></figure><p>该命令的结果为下图，我想要的数据为红框中的信息</p><p><img src="https://pic2.zhimg.com/v2-c25342ecadc91ab7ef35660ab8bc8289_b.png" alt="img"></p><h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><p>字符串的subString方法，通过找到”(“的下标+1,”GB”的下标-1来获取。这提一下+1,-1的意思，不+1的话你获取到的就是”(“，而不是后面的内容。indexOf这个就是获取下标的方法，但只能获取到第一个返回的下标，那我要获取第二行红框的数据怎么办？通过indexOf(“\n”)来获取一行的下标，我要找第二行将这个x2就可以了，第三行x3。具体代码实现如下</p><p><img src="https://pic4.zhimg.com/v2-c13c725055a1c080cd30c39605079eeb_b.png" alt="img"></p><p><a href="https://leidl.top/post/970fcca5">计算机性能指标展现-4</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> spring </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机性能指标展现-4</title>
      <link href="/post/970fcca5.html"/>
      <url>/post/970fcca5.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://leidl.top/post/96b5906">计算机性能指标展现-3</a></p><p>看这篇文章建议看计算机指标3，见上方链接，项目只实现了单机版整合，想集群版整合有兴趣的自己配一下。</p><p><strong>gitee源码</strong>：<a href="https://gitee.com/leidl97/visual-display-linux">visual-display-linux</a></p><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h2><p>实现项目与redis的整合</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>在开启redis之后，数据的读写从数据库转到redis中。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>增加pom依赖</li><li>修改application.properties</li><li>编写PortUtil工具类</li><li>编写RedisConfig类</li><li>编写redis工具类</li><li>对业务层进行修改</li></ol><h3 id="1、增加pom依赖"><a href="#1、增加pom依赖" class="headerlink" title="1、增加pom依赖"></a>1、增加pom依赖</h3><p><img src="https://pic4.zhimg.com/v2-caa609bae78b58608060e9d105cad603_b.jpg" alt="img"></p><h3 id="2、修改application-properties"><a href="#2、修改application-properties" class="headerlink" title="2、修改application.properties"></a>2、修改application.properties</h3><p><img src="https://pic4.zhimg.com/v2-1fc046e4785bc05b05a63a4efab0cd2b_b.jpg" alt="img"></p><h3 id="3、编写PortUtil工具类"><a href="#3、编写PortUtil工具类" class="headerlink" title="3、编写PortUtil工具类"></a>3、编写PortUtil工具类</h3><p>作用：在运行项目的时候需要判断redis服务启动没有。启动走redis，没启动走数据库。</p><p><img src="https://pic4.zhimg.com/v2-4154d13c31e52a3d4e70469d9a74e3af_b.jpg" alt="img"></p><h3 id="4、编写RedisConfig类"><a href="#4、编写RedisConfig类" class="headerlink" title="4、编写RedisConfig类"></a>4、编写RedisConfig类</h3><p>作用：当添加Redis依赖后，SpringBoot会自动帮我们在容器中生成一个RedisTemplate和一个StringRedisTemplate，但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，在代码中会不可避免的需要类型转换，这样不够安全，也过于麻烦，而且RedisTemplate没有设置序列化方式，所以，需要配置Redis，一句话：防止乱码。</p><p><img src="https://pic1.zhimg.com/v2-04de86a049829ca8c3c7b4765f080efc_b.jpg" alt="img"></p><h3 id="5、编写redis工具类"><a href="#5、编写redis工具类" class="headerlink" title="5、编写redis工具类"></a>5、编写redis工具类</h3><p>作用：对redis进行操作，比如增删改一个对象，方法太多了，只写了常用的。</p><p>放个代表性的图，我比较喜欢将工具类写为静态的，这样方便调用。而需要的一个redis模板类，不能够直接进行@Resource注入,所以需要set注入。hasKey是其中的一个方法，其他方法也都大差不差的。</p><p><img src="https://pic1.zhimg.com/v2-9c06437765b83487d465862a86fe6c5c_b.jpg" alt="img"></p><h3 id="6、对业务层进行修改"><a href="#6、对业务层进行修改" class="headerlink" title="6、对业务层进行修改"></a>6、对业务层进行修改</h3><p>一般redis加在业务层。</p><p>create方法</p><p><img src="https://pic2.zhimg.com/v2-6787b2418d165260def0c313284cb52d_b.jpg" alt="img"></p><p>get方法</p><p><img src="https://pic3.zhimg.com/v2-0e7b33298be80235fa7cab4f50a3321e_b.jpg" alt="img"></p><p>可以利用redis可视化工具去查看运行情况，也可以通过在application配置文件中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>这句作用是打印程序所运行产生的sql语句</p><p>结果</p><p><img src="https://pic4.zhimg.com/v2-9012d391fd22e131e1c1db1bc6f9c73b_b.png" alt="img"></p><p>控制台</p><p><img src="https://pic1.zhimg.com/v2-468c0089df8b7ae59b8cfe6871c7bd24_b.jpg" alt="img"></p><p>redisClient</p><p><a href="https://leidl.top/post/e008fc33">计算机性能指标展现-5</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> spring </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机性能指标展现-2</title>
      <link href="/post/7e6c6990.html"/>
      <url>/post/7e6c6990.html</url>
      
        <content type="html"><![CDATA[<p>上次说到，利用spring boot+Echarts实现了大数据指标的可视化展现，详情可见上方链接，上次数据的读取只是在程序中进行读取，这次将它进行迭代，使用数据库进行数据的读写。dao层采取mybatis的方式进行。源码在我的gitee持续更新，需要的自取。</p><p><a href="https://gitee.com/leidl97/visual-display-linux">visual-display-linux</a></p><p>话不多说进入正题。</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ol><li>增加pom依赖</li><li>改application配置文件</li><li>增加mapper配置文件</li><li>创建entity（存放实体类），dao（进行数据操作），service（业务层）的包</li></ol><h3 id="1、增加pom依赖"><a href="#1、增加pom依赖" class="headerlink" title="1、增加pom依赖"></a>1、增加pom依赖</h3><p><img src="https://pic3.zhimg.com/v2-af4966e152dda1095b82c625b46e949e_b.png" alt="img"></p><h3 id="2、改application配置文件"><a href="#2、改application配置文件" class="headerlink" title="2、改application配置文件"></a>2、改application配置文件</h3><p><img src="https://pic3.zhimg.com/v2-82d060854132677bc9531583e7fcd9ca_b.png" alt="img"></p><p>被注释的那一行代表输出sql语句</p><h3 id="3、增加mapper配置文件"><a href="#3、增加mapper配置文件" class="headerlink" title="3、增加mapper配置文件"></a>3、增加mapper配置文件</h3><p>在这里说一下为什么使用mapper而不适用注解的方式，比如说下面这段代码</p><p>注解方式只适合简单sql语句，而mapper.xml是通用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Select(&quot;select * from user &quot;)</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-aedd4e050ef1df59c976ea2df7f77317_b.png" alt="img"></p><p>结构图</p><p><img src="https://pic4.zhimg.com/v2-8165082c32a36332cdb5a147f9360ba7_b.png" alt="img"></p><h3 id="4、创建entity（存放实体类），dao（进行数据操作），service（业务层）的包"><a href="#4、创建entity（存放实体类），dao（进行数据操作），service（业务层）的包" class="headerlink" title="4、创建entity（存放实体类），dao（进行数据操作），service（业务层）的包"></a>4、创建entity（存放实体类），dao（进行数据操作），service（业务层）的包</h3><p><img src="https://pic3.zhimg.com/v2-1cd2f1bd6be2ce3191eec7c494519d86_b.png" alt="img"></p><p>结构图</p><p>entity的类</p><p><img src="https://pic1.zhimg.com/v2-cbe59af646385d146cde9a551e91247c_b.png" alt="img"></p><p>dao下的类</p><p><img src="https://pic3.zhimg.com/v2-7ba122988cd804f6bab0b072335ebad2_b.png" alt="img"></p><p>service下的类</p><p><img src="https://pic1.zhimg.com/v2-e127581d4005def2ae73e5d9185a16cc_b.png" alt="img"></p><p>service.impl下的类</p><p><img src="https://pic1.zhimg.com/v2-31e0a695ac77132eba3079dc192adc84_b.png" alt="img"></p><p>红框外的表示与redis整合，先不看</p><p>controller下的类</p><p><img src="https://pic3.zhimg.com/v2-8cfd817d53f6c79bf01ef07ef765178a_b.png" alt="img"></p><p>一个返回页面，一个异步访问</p><h3 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a>结果截图</h3><p><img src="https://pic3.zhimg.com/v2-d6a40fccc2db706c69a0b348c42cba56_b.png" alt="img"></p><p><a href="https://leidl.top/post/96b5906">计算机性能指标展现-3</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> spring </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机性能指标展现-6</title>
      <link href="/post/7901ad89.html"/>
      <url>/post/7901ad89.html</url>
      
        <content type="html"><![CDATA[<p>之前想的不加功能了，之前已经实现了redis。因为前两天看了nginx的负载均衡，虽然也配过实例，但没有将我做过的项目进行整合，我想这也是一种成长过程，也是一个实操锻炼过程</p><h2 id="话不多说整活！！！"><a href="#话不多说整活！！！" class="headerlink" title="话不多说整活！！！"></a>话不多说整活！！！</h2><p>不只针对我的这个项目，你如果有spring boot项目也可以试试。方法都是一样的，最后效果是通过访问一个网址或者ip达到访问不同端口的目的。负载可以负载端口也可以负载IP，在于你怎么配置。先附一张实现效果图</p><p><img src="https://pic3.zhimg.com/v2-2fcc62f5c261da9ed0a9a856197e0936_b.gif" alt="img"></p><h2 id="首先就是打包"><a href="#首先就是打包" class="headerlink" title="首先就是打包"></a>首先就是打包</h2><p>将你的项目打成jar包</p><p>下面是关于idea如何打包的，会打包的自行跳过</p><p>eclipse就不贴了，都2020年了，还在用eclipse吗……这也没有鄙视的意思，觉得谁好用就用谁吧（doge保命）</p><ol><li>pom文件中添加打包插件</li><li>增加所打的包的方式，jar就写jar，war就写war</li><li>利用maven自带插件打包（建议先clean）</li></ol><h3 id="1、pom文件中添加打包插件"><a href="#1、pom文件中添加打包插件" class="headerlink" title="1、pom文件中添加打包插件"></a>1、pom文件中添加打包插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-63d2eef50875ae88ebc6a38cc8a083d7_b.png" alt="img"></p><p>不加这个插件的的后果，都是亲身试验过的坑啊</p><h3 id="2、增加所打的包的方式，jar就写jar，war就写war"><a href="#2、增加所打的包的方式，jar就写jar，war就写war" class="headerlink" title="2、增加所打的包的方式，jar就写jar，war就写war"></a>2、增加所打的包的方式，jar就写jar，war就写war</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、利用maven自带插件打包（建议先clean）"><a href="#3、利用maven自带插件打包（建议先clean）" class="headerlink" title="3、利用maven自带插件打包（建议先clean）"></a>3、利用maven自带插件打包（建议先clean）</h3><p><img src="https://pic2.zhimg.com/v2-e1338f2c1dcfab3dd0e59f2f12ef47c5_b.png" alt="img"></p><h3 id="4、jar包所在位置"><a href="#4、jar包所在位置" class="headerlink" title="4、jar包所在位置"></a>4、jar包所在位置</h3><p><img src="https://pic1.zhimg.com/v2-74c743dfa33981007a9e54f24b073d54_b.png" alt="img"></p><p>最后提一下，我用过idea自带的打包工具就是那个build，然后运行的时候报的信息一大堆看不懂的，当然项目最后启动不了，可能是我方式不对，但我还是极力的不推荐，一是麻烦，二是需要注意的地方太多，用我上面这种就可以了。</p><p><img src="https://pic1.zhimg.com/v2-a5bbe606c065fee804393926ef0327ec_b.png" alt="img"></p><p>这个是idea的自带打包方式</p><p><img src="https://pic3.zhimg.com/v2-1b9075aa8351a5d4aec8b8545f749a22_b.png" alt="img"></p><p>这个是自带打包方式出现的报错信息</p><p>——————————-打包完，下来说正事————————–</p><p>1、<strong>为了观察效果，可以控制器中设置一个方法返回各自的端口（就是我演示中的效果）</strong></p><p><img src="https://pic2.zhimg.com/v2-3039b3d7aca622ffea9c74b11d856121_b.png" alt="img"></p><p><img src="https://pic2.zhimg.com/v2-0b21cc540beb6a5a00ab5c2e52f5f01d_b.png" alt="img"></p><p>2、<strong>将项目打包，分别定义不同的端口8080，8081，8082</strong></p><p><img src="https://pic1.zhimg.com/v2-e11a401c524a423dd0bfb8eca2932144_b.png" alt="img"></p><p>3、<strong>将打好的包用名字进行区分，放入Linux中</strong></p><p><img src="https://pic2.zhimg.com/v2-cb7467819fa29b3457cde2226dfdee5d_b.png" alt="img"></p><p>4、<strong>进入nginx的conf目录下修改nginx.conf</strong></p><p><img src="https://pic4.zhimg.com/v2-36883bdd7045a3cf3cc2dece93fd8f1f_b.png" alt="img"></p><p>5、<strong>启动nginx.</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>6、<strong>依次启动jar包（也可以使用一键启动脚本，后面说）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxx（nohup表示后台运行）</span><br></pre></td></tr></table></figure><p>7、<strong>访问路径验证效果，一直刷新会观察到端口的变化</strong></p><p><a href="http://192.168.11.130/port">http://192.168.11.130/port</a></p><p>下面为一键启动脚本的代码，直接cv就可以用了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#@author dali</span></span><br><span class="line"><span class="comment">#统一启动3个jar包文件</span></span><br><span class="line"><span class="comment">#这里定义你的jar包名称</span></span><br><span class="line">APP_NAME1=computer8080.jar</span><br><span class="line">APP_NAME2=computer8081.jar</span><br><span class="line">APP_NAME3=computer8082.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查8080是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist1</span></span>()&#123;</span><br><span class="line">  pid1=`ps -ef|grep <span class="variable">$APP_NAME1</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid1&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查8081是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist2</span></span>()&#123;</span><br><span class="line">  pid2=`ps -ef|grep <span class="variable">$APP_NAME2</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid2&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查8082是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist3</span></span>()&#123;</span><br><span class="line">  pid3=`ps -ef|grep <span class="variable">$APP_NAME3</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid3&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动方法</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">  is_exist1</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME1&#125;</span> is already running. pid=<span class="variable">$&#123;pid1&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nohup java -jar <span class="variable">$APP_NAME1</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  is_exist2</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME2&#125;</span> is already running. pid=<span class="variable">$&#123;pid2&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nohup java -jar <span class="variable">$APP_NAME2</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  is_exist3</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME3&#125;</span> is already running. pid=<span class="variable">$&#123;pid3&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nohup java -jar <span class="variable">$APP_NAME3</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止方法</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">  is_exist1</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME1&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  is_exist2</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid2</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME2&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  is_exist3</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid3</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME3&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出运行状态</span></span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">  is_exist1</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME1&#125;</span> is running. Pid is <span class="variable">$&#123;pid1&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME1&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  is_exist2</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME2&#125;</span> is running. Pid is <span class="variable">$&#123;pid2&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME2&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  is_exist3</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME3&#125;</span> is running. Pid is <span class="variable">$&#123;pid3&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;APP_NAME3&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>)</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> spring </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机性能指标展现-5</title>
      <link href="/post/e008fc33.html"/>
      <url>/post/e008fc33.html</url>
      
        <content type="html"><![CDATA[<p>其实对于功能来说在3的时候已经都做完了，这个就是让他做了一个登录页面，加个导航栏，让他看的不那么枯燥，其实我也不知道登录的意义，我们导师要求的。就当复习一遍吧，先附加一个整体效果</p><p><img src="https://pic2.zhimg.com/v2-a30a3b1661186ba7bbfb0c34e1b5b989_b.gif" alt="img"></p><p>觉得还不错的可以去gitee获取一下：<a href="https://gitee.com/leidl97/visual-display-linux">visual-display-linux</a></p><p>这也没什么可讲的，加了一个vue，目的就是前端数据方便展现，jq也可以，但写起来不爽，也不美观，vue的优点就是绑定对象很好用，尤其是双向绑定，还兼容jq，也就是可以一起用。前端html，css那些的就是网上找模板，然后改改改，我不是专门搞前端的，但每次从网上搞一个模板总要改半天，也算是半个前端了吧。不想搞前端的直接用就行了，我都调好了。</p><p>看负载均衡的看这里↓↓↓</p><p><a href="https://leidl.top/post/7901ad89">计算机性能指标展现-6</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> spring </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机性能指标展现</title>
      <link href="/post/7db2942d.html"/>
      <url>/post/7db2942d.html</url>
      
        <content type="html"><![CDATA[<p>此项目是迭代产生的，本人精力水平有限一共更新了五篇，期间有任何疑问欢迎大家评论或者私我。这一篇文章讲了基本的实现，后面的文章增加了数据库、hdfs、redis、nginx、页面布局。写过的文章我也会持续更新，让文章更细，代码功能更加丰富，<strong>此项目满足了用spring boot框架最基本的增删改查功能，并将这些数据进行可视化展现</strong>，如果正好有此需求的人，那么这篇文章一定不容错过。</p><p>话不多说，<strong>先来最终效果</strong>！！！</p><p><img src="https://pic2.zhimg.com/v2-a30a3b1661186ba7bbfb0c34e1b5b989_b.gif" alt="img"></p><h2 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h2><p><img src="https://pic3.zhimg.com/v2-72fc1ee61241c8b8b58684412b04478e_b.png" alt="img"></p><h2 id="集群部署架构图"><a href="#集群部署架构图" class="headerlink" title="集群部署架构图"></a>集群部署架构图</h2><p><img src="https://pic2.zhimg.com/v2-e0662908fe9ce03c2431b4695378d665_b.png" alt="img"></p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><p><img src="https://pic3.zhimg.com/v2-fd46e90b8f27dbc8c18300c0e15c33ee_b.png" alt="img"></p><h2 id="负载均衡实现效果"><a href="#负载均衡实现效果" class="headerlink" title="负载均衡实现效果"></a>负载均衡实现效果</h2><p><img src="https://pic3.zhimg.com/v2-2fcc62f5c261da9ed0a9a856197e0936_b.gif" alt="img"></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p><strong>计算Linux虚拟机指标</strong>包括内存使用率，cpu使用率，实时网速。<strong>获取hdfs的健康信息</strong>，包括配置容量，现有容量，DFS余量，非DFS使用量。并进行<strong>可视化展示</strong></p><h2 id="涉及技"><a href="#涉及技" class="headerlink" title="涉及技"></a>涉及技</h2><p>【必用】spring boot + Echarts + thymeleaf+【选用】Redis+Vue+Bootstrap</p><h2 id="怎么去看"><a href="#怎么去看" class="headerlink" title="怎么去看"></a>怎么去看</h2><p>这个项目就是将平时数据库去到的数据去做可视化展现，至于加redis，登录页，导航页都是花里胡哨的，所以只想学核心基本的看1-3，想深入美观的看4-5。我这个每个模块都是可以拆分的，取你所需就可以了。只要其中有涉及到你想看的，那就值得一看。</p><h2 id="收获什么"><a href="#收获什么" class="headerlink" title="收获什么"></a>收获什么</h2><p>加深对spring boot的理解，学会如何<strong>从</strong>Echarts<strong>官方案例变为自己的并加以应用</strong>，学会<strong>前后端联动</strong>，熟悉控制器与<strong>异步传输</strong>的使用，简单进行Linux和shell文件的了解。以及对缓存基本的应用，麻雀虽小，相信能收获颇多。</p><h2 id="本篇实现思路"><a href="#本篇实现思路" class="headerlink" title="本篇实现思路"></a>本篇实现思路</h2><p>利用Java去读取Linux中的文件，读出其中的信息，并将获得的字符串加以计算，通过控制层传给前端，利用前端进行展示。</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://gitee.com/leidl97/visual-display-linux">visual-display-linux</a></p><h2 id="本篇实现效果"><a href="#本篇实现效果" class="headerlink" title="本篇实现效果"></a>本篇实现效果</h2><p><img src="https://pic1.zhimg.com/v2-bf55eade2b508c6a26ac2bb20eb76ad4_b.gif" alt="img"></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>Java利用ssh连接Linux</li><li>数据准备</li><li>提供一个可视化模板</li><li>进行前后端联动，异步将数据传输到页面上</li></ol><h3 id="1、Java利用ssh连接Linux"><a href="#1、Java利用ssh连接Linux" class="headerlink" title="1、Java利用ssh连接Linux"></a>1、Java利用ssh连接Linux</h3><p><img src="https://pic4.zhimg.com/v2-5c8fb1bb910af2f8712c451b5c9147af_b.png" alt="img"></p><h4 id="2、数据准备"><a href="#2、数据准备" class="headerlink" title="2、数据准备"></a>2、数据准备</h4><p><strong>(1)CPU使用率获取</strong></p><p>command：top -b -n 1 | head -3</p><p><img src="https://pic3.zhimg.com/v2-c11288cbae5a3c2fd89bffb335d3f8a2_b.png" alt="img"></p><blockquote><p>第三行为cpu状态： 依次对应： us:user  用户空间占用cpu的百分比 sy:system 内核空间占用cpu的百分比 ni:niced 改变过优先级的进程占用cpu的百分比 <strong>id:空闲cpu百分比</strong> wa:IO wait IO等待占用cpu的百分比 hi:Hardware IRQ 硬中断 占用cpu的百分比 si:software 软中断 占用cpu的百分比 st:被hypervisor偷去的时间</p></blockquote><p>计算方式：100-cpu空闲百分比</p><p><img src="https://pic3.zhimg.com/v2-ec5ea483d95f4b815ec06af75e06f672_b.png" alt="img"></p><p><strong>（2）内存使用率获取</strong></p><p>command<strong>：</strong>cat /proc/meminfo</p><p><img src="https://pic4.zhimg.com/v2-c1739c305492653138ca56c5a9330757_b.png" alt="img"></p><p>红框代表含义：总内存，空闲内存</p><p>计算方式：（总内存-空闲内存）/总内存</p><p><img src="https://pic4.zhimg.com/v2-546bb5e22580c8dee729d37c1c84e5cb_b.png" alt="img"></p><p><strong>（3）实时网速获取</strong></p><p>command：cat /proc/net/dev(记录了不同网络接口（interface）上的各种包的记录)</p><p>最左边的表示接口的名字，Receive表示收包（下载量），Transmit表示发送包（上传量）</p><p><img src="https://pic1.zhimg.com/v2-b6b968d09ad5d462c3564856ef2d9f00_b.png" alt="img"></p><p>需要一个脚本文件（<strong>获取实时网速</strong>和实时上传率，我只做了第一个，可以自己扩展一下）</p><p>简单介绍以下脚本含义：sed将:替换为空格全局匹配, awk读第二个,grep 按什么匹配，echo代表输出什么，剩下的有点语言底子的都应该可以看懂，我也就不说了。</p><p><img src="https://pic3.zhimg.com/v2-fac039522f62c91bea33381140428b8a_b.png" alt="img"></p><p>计算方式：根据前后一秒网络下载量所产生的差值作为数据</p><p><img src="https://pic3.zhimg.com/v2-3742631f98dad600d729f8e3bf8c1cc6_b.png" alt="img"></p><h4 id="3、可视化模板"><a href="#3、可视化模板" class="headerlink" title="3、可视化模板"></a>3、可视化模板</h4><p>我们需要一个可视化前端模板，我找了一个官方案例，效果如下</p><p><a href="https://echarts.apache.org/examples/zh/editor.html?c=gauge-car-dark">https://echarts.apache.org/examples/zh/editor.html?c=gauge-car-dark</a></p><p><img src="https://pic2.zhimg.com/v2-8c658431a6086b02fb213483ce3a1011_b.png" alt="img"></p><h4 id="4、进行前后端数据交互"><a href="#4、进行前后端数据交互" class="headerlink" title="4、进行前后端数据交互"></a>4、进行前后端数据交互</h4><p>前端部分</p><p><img src="https://pic1.zhimg.com/v2-deaf4cfe2f75fbc259c1ce8cdccfb9a4_b.png" alt="img"></p><p>后端部分</p><p><img src="https://pic1.zhimg.com/v2-fd2b597c96546b37a1ae572c14867cec_b.png" alt="img"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>对学习了spring boot或者Echarts想要一个练手项目的时候，那么这个项目就适合你。我为什么没有直接利用Java去实现本机（windows）一些性能指标的监控呢，比如下图。因为Java并不能直接获取本机的一些数据，应该是操作系统层面的权限问题吧，这些都是我踩过的坑，我也只获取到了jvm层面，代码就不附了，感兴趣的网上或者私我都可以。</p><p><a href="https://leidl.top/post/7e6c6990">计算机性能指标展现2</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> spring </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习之路</title>
      <link href="/post/539343bf.html"/>
      <url>/post/539343bf.html</url>
      
        <content type="html"><![CDATA[<p><strong>满满的都是干货。第一次创作，不喜勿喷~本文中不适合资深人士阅读，创作此文章只供学习交流，欢迎大家在评论区批评和指正。其中链接中的文章也会持续更新。大家觉得不错的话点个赞吧，鼓励我持续更新下去。不忘初心，砥砺向前(๑•̀ㅂ•́) ✧</strong></p><p>下面这篇文章聊了聊我对大数据学习的一些感想，和一些学习方法。有兴趣的可以去看看</p><p><a href="https://leidl.top/post/3d24dcf9">https://leidl.top/post/3d24dcf9</a></p><p>这篇文章我想聊聊<strong>我是怎么学的</strong>，<strong>奔的什么目的去学的？</strong></p><p>大家都知道，学习要讲究一个目的，<strong>我为什么要学这个东西</strong>。通俗点说就是你得会学。不然你是学不明白的。就比如大数据中一个hadoop就够你学了，知识点很杂很散，我应该怎么找到适合自己的学习方法？应该学到什么程度才可以？如何更加有效率的学习？笔者自认为学的还可以，这里并不是代表我学了多少东西，学了多深的东西，而是我<strong>在有限的时间内收获了我想要的</strong>。打个比方经历过高考的人老师曾经肯定对你说过这样一句话“先做会的，不会的直接放过”这句话放在现在也很受用吧，学习的时间是有限的，最充裕的时候就是大学四年，但是我相信大部分人大学四年也没有谁像高中一样学下来的，哪怕高中的1/3都没有。如果你参加工作了，那么你更能感受到时间是非常宝贵的。不断学习是多么重要。所以<strong>如何有效的学习</strong>是非常有必要的。这方面笔者也一直在探索方法。</p><p>而我这篇文章的学习目的就是通过学一堆大数据组件去干项目。当然也不是学了这些就代表我有干项目的技术了。而是说你有一个门槛了，可以去学项目了，到时候项目中不会的再去研究学习，<strong>在项目中学知识，成长的可以更快</strong>。我也用这种模式是受益过的，也一直推崇这个学习方法。</p><p>不多比比了，直接开搞。首先学习大数据的话是需要一点<strong>Java底子</strong>的。比如hadoop就是Java写的，所以没有Java底子有很多东西是理解不了的。所以笔者建议没有基础的先去补基础。到什么程度呢，学完JavaSE吧，也就是学到servlet那块。在这也推荐一下学习Java的网站吧</p><p><a href="https://how2j.cn/?p=85216">How2J 的 Java教程</a></p><p>我曾受益于此网站，觉得不错就推荐给大家。优点就是没广告，除了实战项目外都不要钱。笔者属于花钱党，上篇文章也说了，我对学习和版权这块不吝啬。好不好，你们说了算。<strong>适合小白学习</strong>。比较深的一些东西，像他后面那些框架讲解，中间件技术之类的也只是讲个皮毛，学不到什么东西。这网站建议大家看基础或者实战项目。对于小白来说足够了，也不用花钱。学到基础就可以了，回到主题，学这些只是让学习大数据更加顺滑。</p><p>首先，学大数据就一定离不开<strong>Linux</strong>，哈哈哈，梅开二度，没有Linux底子的建议去补Linux。到什么程度呢？起码基本命令你得知道。在这我就不推荐具体的网站了，主要是我没遇到过良心网站如果学的话我推荐去<a href="https://www.bilibili.com/">b站</a>看视频学习，一搜一大把，播放量高的和最新发布结合一下去找一个就行。</p><p>有了Java基础和Linux底子后就可以开始大数据的学习了。<strong>大数据是什么？我为什么要学？</strong>干过Java就明白了，让你处理MySQL中的数据你写个程序就能搞定。那么我的数据有100个T呢。别说程序卡死。光存都有点费劲。像Google每日点击访问量那也是一个级别，怎么处理这么多的数据呢？这就是大数据出现的原因。为什么要学？两个理由：第一，必然趋势，稍微大点的公司都会涉及大数据，你不会怎么行，等淘汰吧。第二，钱挣得多，相同条件下，比Java高。别的没用的话我也就不说了，我还是喜欢实在的，能让人一下子听懂的。如果还想了解的就自己去搜搜吧。</p><h2 id="整体学习路线"><a href="#整体学习路线" class="headerlink" title="整体学习路线"></a>整体学习路线</h2><ul><li>【必修】</li><li>安装VMware</li><li>使用伴侣（连接虚拟机的）</li><li>基础环境与常用软件搭建</li><li>zookeeper</li><li>hadoop</li><li>Hbase</li><li>Hive</li><li>【选修】</li><li>oozie</li><li>spark</li><li>sentry</li><li>更新中…</li></ul><h2 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h2><p>第一件事情<strong>安装VMware</strong>。有这软件的就不说了，没有的评论，私我都可以。最好装一个pro版的设置虚拟网卡配置会有用。</p><p>选择发行版：只是单纯的学习那么首选<strong>centos7</strong>。镜像自己搞，或者问我要。我也只是百度网盘链接，没会员的还是自己找个吧。</p><p>虚拟机搭建：大部分人都是8G内存或者16G。<strong>推荐部署3台（将来集群搭建）</strong>看自己电脑内存分配。</p><p><a href="https://leidl.top/post/f8239d66">VMware安装centos系统的教程</a></p><p>推荐<strong>最小安装</strong>，黑框框敲就行了，这也是Linux的魅力。</p><h2 id="使用伴侣"><a href="#使用伴侣" class="headerlink" title="使用伴侣"></a>使用伴侣</h2><p>在安装完三台虚拟机后,需要使用伴侣。这里推荐Xshell（需破解）,本人用的FinalShell（免费）</p><ul><li>使用伴侣原因：用自带的不好编辑，不能复制粘贴（最小安装）。将来也不可能直接去操作服务器，都是采用远程连接的方式。</li><li>使用说明：安装完客户端后采用SSH连接就可以了，以FinalShell举例。别的也类似。</li></ul><p><img src="https://pic1.zhimg.com/v2-3841f7f1df05449230d45b8804c0aadc_b.png" alt="img"></p><p>填入红框信息</p><h2 id="基础环境与常用软件搭建"><a href="#基础环境与常用软件搭建" class="headerlink" title="基础环境与常用软件搭建"></a>基础环境与常用软件搭建</h2><p>这时候会遇到一个问题，<strong>刚安装的虚拟机网卡是关闭的</strong>，导致没有主机IP，需要重启网卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>查看<strong>ens33</strong>网卡的ip地址，连接即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -a</span><br></pre></td></tr></table></figure><p>至于Linux的一些基本环境配置与部署请看这篇文章</p><p><a href="https://leidl.top/post/164eee11">Linux虚拟机基础环境配置</a></p><p>还有一些零碎的组件，比如说SSH免密操作，JDK，MySQL，tomcat。需要的直接看链接</p><p><a href="https://leidl.top/post/96131cab">SSH免密操作</a></p><p><a href="https://leidl.top/post/3d20c1d7">Linux下JDK与tomcat的安装</a></p><p>[Linux下MySQL5.7的tar方式安装](<a href="https://leidl.top/post/fe1f88a1">https://leidl.top/post/fe1f88a1</a></p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>简称ZK，字面意思是动物园管理。而Hadoop各大组件，比如Hive是蜜蜂，Hbase是鲸鱼等，就是管理Hadoop组件的。为什么要学它，Hadoop组件那么多，总有人去管，去协调它们，它的作用就是<strong>进行分布式协调。</strong></p><p><img src="https://pic4.zhimg.com/v2-90b7ea3301b4e28ed6cd1ed904c2509b_b.png" alt="img"></p><p><a href="https://leidl.top/post/5ac88c70">ZK完全分布式安装</a></p><p><a href="https://leidl.top/post/721d4875">ZK的学习笔记</a></p><h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><p><img src="https://pic3.zhimg.com/v2-6b80401eb86aab30c32edf107774c8a6_b.png" alt="img"></p><p>看技术的直接看笔记，这里聊一聊hadoop的题外话</p><p>首先是创始人</p><p><img src="https://pic1.zhimg.com/v2-ead3b0c97643928fa6b649860223e3d0_b.png" alt="img"></p><p>Doug Cutting</p><p><strong>这个人干过什么？</strong></p><ul><li>Lucene是他做的，Lucene是Java写的，目标是为各种中小型应用软件加入全文检索功能，好用且开源 2001年被apache收录</li><li>04年基于GFS（Google file system），实现了分布式文件系统，命名为NDFS（N代表Nutch，在Lucene基础上写的，功能更强）</li><li>04年Google发表论文MapReduce，用于大规模计算</li><li><strong>06年yahoo招安Doug Cutting，对NDFS和MapReduce进行了升级改造，并重新命名为hadoop</strong></li><li>在Yahoo的工作期间，Cutting先后发明了Hive，Pig，HBase等 </li><li>06年Google又发论文BigTable，Doug Cutting引入了BigTable，并命名为HBase</li><li>08年hadoop成为apache的顶级项目</li></ul><p><strong>为什么叫hadoop？</strong></p><p>这个名字不是一个缩写，而是一个虚构的名字。Doug Cutting解释hadoop的得名 ：“这个名字是我孩子给一个棕黄色的大象玩具命名的。我的命名标准就是简短，容易发音和拼写，没有太多的意义，并且不会被用于别处。小孩子恰恰是这方面的高手。</p><p><strong>为什么学hadoop？</strong></p><p>就跟你要盖房子需要打地基一样，你说你学习大数据Kafka我没学过这个不打紧，但是你要是hadoop都不学，那你真的研究大数据也就没什么意思了。那就跟你出去吹牛逼说我Spring框架用的多6，最后你对人家说我连JavaSE都没学过，那谁信你学过Java。前面说这么多可见hadoop在大数据中的地位至关重要，hadoop是大数据技术的<strong>基础</strong>，对hadoop基础知识的掌握的扎实程度，会决定在大数据技术道路上走多远。</p><p><a href="https://leidl.top/post/8f488ef0">hadoop学习笔记</a></p><p><a href="https://leidl.top/post/34e57ffd">HDFS全分布式安装</a></p><p>—8.3—</p><p>好久时间没更了，我去更隔壁Java专栏的spring boot一个小项目了，<strong>其中包括对hdfs健康信息展现</strong>，也就是50070展示的那些数据，感兴趣的可以看下</p><p><a href="https://leidl.top/post/7db2942d">计算机性能指标展现</a></p><h2 id="接下来说Hbase"><a href="#接下来说Hbase" class="headerlink" title="接下来说Hbase"></a>接下来说<strong>Hbase</strong></h2><p><img src="https://pic1.zhimg.com/v2-30b33b174d893847334966240692846c_b.png" alt="img"></p><p>看嘛子，我就是存东西的</p><p>看图，一个大鲸鱼，鲸鱼突出一个字，那就是大，可以将鲸鱼看作一个数据库，肚子里大量的海水看作海量的数据这样的话就很形象了。学习MySQL的都知道，它就是一个数据库，Hbase也一样，只不过<strong>Hbase存的是海量的数据</strong>。</p><p><a href="https://leidl.top/post/730d8d6c">Hbase的学习笔记</a></p><p><a href="https://leidl.top/post/730d8d6c">Hbase的学习笔记</a></p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a><strong>Hive</strong></h2><p><img src="https://pic2.zhimg.com/v2-c78de3e952ac8c76fb91fc1dd623ff51_b.png" alt="img"></p><p>这个小黄蜂是什么？它就是构建在Hadoop hdfs上的<strong>数据仓库</strong>，有人可能会说了，数据仓库是什么，与刚才Hbase什么关系，Hbase不也是基于HDFS的吗，学懵了。。。怎么说呢，数据仓库 实际上还是一个数据库，严格来说又不是一个数据库。<strong>说人话就是数据库为了响应时间读写都要干但是对于大量的读是支持不足的，而数据仓库是为了吞吐量，重点在于查询</strong></p><p><strong>限制</strong></p><p>Hive目前不支持更新操作。另外，由于hive在hadoop上运行批量操作，它需要花费很长的时间，通常是几分钟到几个小时才可以获取到查询的结果。Hive必须提供预先定义好的schema将文件和目录映射到列，并且Hive与ACID不兼容。</p><p>HBase查询是通过特定的语言来编写的，学完Hbase的都体会到了，语言是真的难用，这种语言需要重新学习。Hive就是类SQL，学过MySQL的都很熟悉，都可以进行编写。</p><p><strong>适用场景</strong></p><p>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。</p><p>Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。</p><p><img src="https://pic3.zhimg.com/v2-3b87208274ed4377c9e93dbc9e435bda_b.png" alt="img"></p><p>还是不大懂的看笔记吧</p><p><a href="https://leidl.top/post/f31a5a5b">Hive学习笔记</a></p><p><a href="https://leidl.top/post/5bf55f4">Hive安装部署</a></p><p>———8.4———–</p><p>下面这些就是量力而行了，因为本人也不是了解的特别透彻，就提一嘴吧，笔记比较少，这些或许对你们比较重要那就网上在看看，资料还是挺多的</p><h2 id="oozie"><a href="#oozie" class="headerlink" title="oozie"></a>oozie</h2><p>看一眼官方声明吧</p><p><img src="https://pic3.zhimg.com/v2-1462be9335842e5d3c7c67466f5555f6_b.png" alt="img"></p><p>不要问我为什么是中文的，这是我翻译出来的</p><p>oozie（翻译过来就是训象人）<strong>谁是大象</strong>，hadoop是大象，可以拉上去看看图，就是负责管理Hadoop的，<strong>管理什么？</strong>管理hadoop作业，进行作业协调。<strong>他本质上就是一个作业协调工具。</strong>不知道装上有什么用，虽然我装了，也就敲了几个命令。我就不写了</p><p><a href="https://leidl.top/post/ecd67acc">oozie学习笔记</a></p><h2 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h2><p>学过MapReduce都知道，它是基于文件的数据读取的IO开销非常大，而且也慢，而spark<strong>基于内存的计算</strong>比MR快100倍（官网说的）推荐学习spark的学下scala语言，因为spark就是scala写的。</p><p><a href="https://leidl.top/post/4fa8e0c4">spark学习笔记</a></p><p><a href="https://leidl.top/post/fb77661f">spark的安装</a></p><h2 id="sentry"><a href="#sentry" class="headerlink" title="sentry"></a>sentry</h2><p>sentry分两个，当时我学的时候学了半天docker的…我真T了。咱主要还是说hadoop的sentry</p><p>Sentry 是Cloudera公司发布的一个Hadoop开源组件，它提供细粒度基于角色的安全控制</p><p>。。。我也不想写这块了，没用到过，我们公司要求稍微看了下，过了过了。</p><p>下次更docker</p><p>————————– 9/3 ———————————————————</p><p>写到最后：好些日子没更了。主要是重心偏移了，公司也用的不多。但我以后还会向这边靠拢，也算打了点基础吧，暂时不更了，如果我接触到这块我还会继续更新。我会在其他方面继续更新文章，持续更新各种干货</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZK的学习笔记</title>
      <link href="/post/721d4875.html"/>
      <url>/post/721d4875.html</url>
      
        <content type="html"><![CDATA[<p>前言：当初学习的时候看的这篇文章，借鉴别人去学习的</p><p><a href="https://www.zhihu.com/question/65852003/answer/656091418">能否用通俗的讲法解释一下什么是Zookeeper？</a></p><h2 id="本文大纲"><a href="#本文大纲" class="headerlink" title="本文大纲"></a>本文大纲</h2><ul><li>什么是ZK</li><li>ZK能够干什么</li><li>zookeeper的数据结构</li><li>ZK的选举</li></ul><h2 id="什么是zookeeper？"><a href="#什么是zookeeper？" class="headerlink" title="什么是zookeeper？"></a><strong>什么是zookeeper？</strong></h2><p>1：Zookeeper是Apache Hadoop的子组件之一</p><p>2：ZooKeeper主要服务于<strong>分布式系统</strong>。统一配置管理、统一命名服务、分布式锁、集群管理</p><h2 id="zookeeper能够干什么"><a href="#zookeeper能够干什么" class="headerlink" title="zookeeper能够干什么"></a><strong>zookeeper能够干什么</strong></h2><p>ZooKeeper 是一个典型的<strong>分布式数据一致性解决方案</strong>，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><h2 id="zookeeper的数据结构"><a href="#zookeeper的数据结构" class="headerlink" title="zookeeper的数据结构"></a><strong>zookeeper的数据结构</strong></h2><p>可以看做是一颗<strong>树</strong>，每个节点叫做<strong>ZNode</strong>。每一个节点可以通过路径来标识，结构图如下：</p><p><img src="https://pic4.zhimg.com/v2-2ec1ce95134a8ed7dada87e599a7d29b_b.png" alt="img"></p><p>ZNode分为两种类型</p><p><strong>短暂/临时</strong>(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>会自动删除</strong></p><p><strong>持久</strong>(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>不会删除</strong></p><h2 id="zookeeper如何做到统一配置管理、统一命名服务、分布式锁、集群管理"><a href="#zookeeper如何做到统一配置管理、统一命名服务、分布式锁、集群管理" class="headerlink" title="zookeeper如何做到统一配置管理、统一命名服务、分布式锁、集群管理"></a><strong>zookeeper如何做到统一配置管理、统一命名服务、分布式锁、集群管理</strong></h2><p><strong>1：统一配置管理</strong></p><p>假设我们现在有三个系统A、B、C，他们有三份配置，分别是ASystem.yml、BSystem.yml、CSystem.yml，这三份配置非常类似，很多的配置项几乎都一样。此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息很可能就要重启系统。于是，我们希望把ASystem.yml、BSystem.yml、CSystem.yml相同的配置项抽取出来成一份公用的配置common.yml，并且即便common.yml改了，也不需要系统A、B、C重启。</p><p><img src="https://pic4.zhimg.com/v2-3c73bb17c9243fa7d7a16b520618c457_b.png" alt="img"></p><p><strong>做法</strong>：我们可以将common.yml这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，<strong>及时</strong>响应</p><p><strong>2：统一命名服务</strong></p><p>比如说，现在我有一个域名<a href="http://www.xxx.com，但我这个域名下有多台机器：">www.xxx.com，但我这个域名下有多台机器：</a></p><p>192.168.1.1</p><p>192.168.1.2</p><p>192.168.1.3</p><p>192.168.1.4</p><p>别人访问<a href="http://www.xxx.com即可访问到我的机器,而不是通过ip去访问/">www.xxx.com即可访问到我的机器，而不是通过IP去访问</a></p><p><img src="https://pic4.zhimg.com/v2-759957b63cab1df24644d253d5703313_b.png" alt="img"></p><p><strong>3:分布式锁</strong></p><p>系统A、B、C都去访问/locks节点</p><p><img src="https://pic1.zhimg.com/v2-a0cb76eaa046800f7d5a57d497ac380c_b.png" alt="img"></p><p>访问的时候会创建带顺序号的临时/短暂(EPHEMERAL_SEQUENTIAL)节点，比如，系统A创建了id_000000节点，系统B创建了id_000002节点，系统C创建了id_000001节点。</p><p><img src="https://pic4.zhimg.com/v2-c90ea224d9796e8849d7e23b66269327_b.png" alt="img"></p><p>接着，拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，判断自己创建的是不是最小的那个节点</p><p>如果是，则拿到锁。</p><p>释放锁：执行完操作后，把创建的节点给删掉</p><p>如果不是，则监听比自己要小1的节点变化</p><p>原理：</p><p>系统A拿到/locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁</p><p>系统B拿到/locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态</p><p>系统C拿到/locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态……等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁….</p><p>系统B如上</p><p><strong>4：集群管理</strong></p><p>以我们三个系统A、B、C为例，在ZooKeeper中创建临时节点即可</p><p><img src="https://pic2.zhimg.com/v2-be3f8e6352e8d1c7657d65a1d9e740f9_b.png" alt="img"></p><p>只要系统A挂了，那/groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)</p><p>除了能够感知节点的上下线变化，ZooKeeper还可以实现动态选举Master的功能。(如果集群是主从架构模式下)</p><p>原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)就好了。</p><p>Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让新的最小编号作为Master，这样就可以实现动态选举的功能了。</p><h2 id="ZK选举"><a href="#ZK选举" class="headerlink" title="ZK选举"></a>ZK选举</h2><p><strong>1：集群至少由三个节点组成</strong></p><p>虽然说两个也可以，如果其中一个节点挂了，zookeeper就不能提供对外服务，失去了集群的意义。</p><p><strong>2：节点并非越多越好</strong></p><p>节点越多，使用的资源越多。</p><p>节点越多，ZooKeeper节点间花费的通讯成本越高，节点间互连的Socket也越多。影响ZooKeeper集群事务处理。</p><p>节点越多，造成脑裂的可能性越大。</p><p><strong>3：集群规模为奇数</strong></p><p>3台和4台都是只可以挂一台，因为过半性</p><p>解释3的一半为1.5以上最小整数为2，所以只能挂一台；4的一半为2以上最小整数为3，也是只能挂一台。</p><p><img src="https://pic2.zhimg.com/v2-fb5ff71f1102ed1c7af3e6e011a87f59_b.png" alt="img"></p><p><strong>4：集群角色</strong></p><p><strong>Leader</strong></p><p>在一个zookeeper集群中<strong>只能存在一个leader</strong>，集群中事务请求的唯一调度者和处理者，leader根据事务ID保证事务处理的顺序性</p><p>如果一个集群中存在多个leader，这个现象称为脑裂，大集群裂变为小集群，会导致数据不同步，数据混乱。</p><p><strong>Follower</strong></p><p>只能处理非事务请求，如果收到事务请求转发给leader；参与leader选举；参与事务处理投票</p><p><strong>observer</strong></p><p>与follower相似，可以处理非事务请求；将事务请求转发给Leader服务器。但是它不会参与leader的选举，不会参与投票。</p><p><strong>如何成为观察者</strong>：在zoo.cfg中添加如下属性：peerType=observer</p><p><strong>作用</strong>：用于不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p><p><strong>5：leader选举机制</strong></p><p><strong>1、选举投票必须在同一轮次中进行</strong></p><p>如果Follower服务选举轮次不同，不会采纳投票。</p><p><strong>2、数据最新的节点优先成为Leader</strong></p><p>数据的新旧使用事务ID判定，事务ID越大认为节点数据约接近Leader的数据，自然应该成为Leader。</p><p><strong>3、比较myid，id值大的优先成为Leader</strong></p><p>如果每个参与竞选节点事务ID一样，再使用myid做比较。myid是节点在集群中唯一的id，myid文件中配置。</p><p><strong>6：过半原则</strong></p><p><strong>Leader选举投票；事务提议投票；这些投票依赖过半原则。</strong></p><ul><li><strong>事务提议投票</strong></li><li>假设有3个节点组成ZooKeeper集群，客户端请求添加一个节点。Leader接到该事务请求后给所有Follower发起「创建节点」的提议投票。如果Leader收到了超过集群一半数量的反馈，继续给所有Follower发起commit。此时Leader认为集群过半了，就算自己挂了集群也是安全可靠的。</li><li><strong>Leader选举投票</strong></li><li>假设有3个节点组成ZooKeeper集群，这时Leader挂了，需要投票选举Leader。当相同投票结果过半后Leader选出。</li><li><strong>集群可用节点</strong></li><li>ZooKeeper集群中每个节点有自己的角色，对于集群可用性来说必须满足过半原则。这个过半是指Leader角色 + Follower角色可用数大于集群中Leader角色 + Follower角色总数。</li><li>假设有5个节点组成ZooKeeper集群，一个Leader、两个Follower、两个Observer。<strong>当挂掉两个Follower或挂掉一个Leader和一个Follower时集群将不可用。因为Observer角色不参与任何形式的投票。</strong></li></ul><p><strong>7：场景实战</strong></p><p><strong>1：leader挂了选举过程</strong></p><p>假设有3节点组成的集群，分别是server.1（Follower）、server.2（Leader）、server.3（Follower）。此时server.2不可用了。集群会产生以下变化：</p><p><strong>状态变更</strong></p><p>所有Follower节点变更自身状态为LOOKING。投票内容就是自己节点的事务ID和myid。我们以(事务ID,myid)表示。</p><p>假设server.1的事务id是10，变更的自身投票就是（10, 1）；server.3的事务id是8，变更的自身投票就是（8, 3）。</p><p><strong>投票机制</strong></p><p>将变更的投票发给集群中所有的Follower节点。</p><p>server.1将（10, 1）发给集群中所有Follower，包括它自己。server.3也一样，将（8, 3）发给所有Follower。</p><p>所以server.1将收到（10, 1）和（8, 3）两个投票，server.3将收到（8, 3）和（10, 1）两个投票。</p><p>投票PK</p><p>比较规则：先比较事务id（Zxid），如果事务id相同则比较myid；超过一半节点才能成为leader。</p><p>对于server.1来说收到（10, 1）和（8, 3）两个投票，与自己变更的投票比较后没有一个比自身投票（10, 1）要大的，所以server.1维持自身投票不变。</p><p>对于server.3来说收到（10, 1）和（8, 3）两个投票，与自身变更的投票比较后认为server.1发来的投票要比自身的投票大，所以server.3会变更自身投票并将变更后的投票发给集群中所有Follower。</p><p><strong>统计投票</strong></p><p>server.1接收到来自server.1的（10, 1）投票和来自server.3的（8, 3）投票。</p><p>server.3同样接收到来自server.1的（10, 1）投票和来自server.3的（8, 3）投票。</p><p>此时server.1和server.3接收桶里的数据是这样的：</p><p><img src="https://pic3.zhimg.com/v2-d6d8420322e2b2a16bf4dc8eb0ab94ae_b.png" alt="img"></p><p>server.3经过PK后认为server.1的选票比自己要大，所以变更了自己的投票并重新发起投票。</p><p>server.1收到了来自server.3的（10, 1）投票;server.3收到了来自sever.3的（10, 1）投票。</p><p>此时server.1和server.3接收桶里的数据变成了这样：</p><p><img src="https://pic3.zhimg.com/v2-dbee7ade5b5061d8889d0451cd64db4a_b.png" alt="img"></p><p>基于ZooKeeper过半原则：桶内投票选举server.1作为Leader<strong>出现2次</strong>，满足了过半 2 &gt; 3/2 即 2&gt;1。</p><p>最后sever.1节点晋升为Leader，server.3变更为Follower。</p><p><strong>接收桶</strong></p><p>节点接收的投票存储在一个接收桶里，每个Follower的投票结果在桶内<strong>只记录一次</strong>。ZooKeeper源码中接收桶<strong>用Map实现</strong>。</p><p>下面代码片段是ZooKeeper定义的接收桶，以及向桶内写入数据。Map.Key是Long类型，用来存储投票来源节点的myid，Vote则是对应节点的投票信息。节点收到投票后会更新这个接收桶，也就是说桶里存储了所有Follower节点的投票并且<strong>仅存最后一次的投票结果</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line">recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br></pre></td></tr></table></figure><p><strong>2：集群扩容选举</strong></p><p>假设目前有3个节点组成集群，分别是server.1（Follower）、server.2（Leader）、server.3（Follower），假设集群中节点事务ID相同。集群中新增server.4和server.5两个节点，首先修改server.4和server.5的zoo.cfg配置并启动。</p><p><strong>选举机制</strong></p><p><img src="https://pic3.zhimg.com/v2-b9c919261be7dc81c1b6f71303410f16_b.png" alt="img"></p><p><strong>脑裂现象的出现</strong></p><p>修改server.2zoo.cfg配置文件，增加server.4和server.5的配置并停止server.2服务。停止server.2后，Leader不存在了，集群中所有Follower会发起投票。当server.1和server.3发起投票时并不会将投票发给server.4和server.5，因为在server.1和server.3的集群配置中不包含server.4和server.5节点。相反，server.4和server.5会把选票发给集群中所有节点。也就是说对于server.1和server.3他们认为集群中只有3个节点。对于server.4和server.5他们认为集群中有5个节点。</p><p>根据过半原则，server.1和server.3很快会选出一个新Leader，我们这里假设server.3晋级成为了新Leader。但是我们没有启动server.2的情况下，因为投票不满足过半原则，server.4和server.5会一直做投票选举Leader的动作。截止到现在集群中节点状态是这样的：</p><p><img src="https://pic4.zhimg.com/v2-29bbc51fe2a6e14301a9f50f99f6fc4b_b.png" alt="img"></p><p><strong>在启动leader后意想不到的事情发生了，出现两个Leader：</strong></p><p><img src="https://pic4.zhimg.com/v2-50dec238f540b886883b5208da3bd47b_b.png" alt="img"></p><p><strong>如何避免</strong></p><p>ZooKeeper集群扩容时，如果<strong>Leader节点最后启动</strong>就可以避免这类问题发生。</p><p>因为在Leader节点重启前，所有的Follower节点zoo.cfg配置已经是相同的，他们基于同一个集群配置两两互联，做投票选举。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习笔记</title>
      <link href="/post/f31a5a5b.html"/>
      <url>/post/f31a5a5b.html</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>基本知识</li><li>基本指令</li><li>元数据</li><li>数据类型</li><li>架构</li><li>数据组织</li><li>内部表与外部表</li></ul><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p><strong>为什么不用Hadoop进行开发</strong></p><ol><li>存在语言门槛，开发需要会Java语言</li><li>需要了解底层原理</li><li>开发调试不方便</li></ol><p><strong>为什么使用Hive</strong></p><blockquote><p>hive终究还是mapreduce的框架，直接学习mapreduce所面临的问题 1.人员学习成本太高 2.项目周期要求短 3.MR实现复杂查询开发难度较大 Hive的优势 1.接口更友好，使用HQL。就是类SQL语言法，学过MySQL就能进行开发 2.学习成本低，避免写MapReduce 3.扩展性好，自由扩展集群规模，支持用户自定义函数</p></blockquote><p><strong>hive概述</strong></p><ol><li>是一个基于Hadoop的数据仓库工具。</li><li>底层将sql语句转换为mapreduce来进行</li><li><strong>离线分析工具</strong>，延迟比较高，不适合实时查询，比如进行日志分析</li></ol><p><img src="https://pic4.zhimg.com/v2-ccf0e1c262d05af06da729f7d88f747b_b.png" alt="img"></p><p><strong>OLTP和OLAP</strong></p><p>怎么突然蹦出来个这，这两个是什么</p><p>OLTP（Online Transaction Processing）联机事务处理系统。涵盖了日常操作，如购物，库存，制造，工资，注册，记账。处理系统就代表mysql，oracle等关系型数据库。</p><p>OLAP（Online Analytical Processing）联机分析处理系统。比如Hive，Hbase等</p><p><img src="https://pic1.zhimg.com/v2-d2840a44d149eb744f6e3d302e008160_b.png" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-8fa5fd48e6c4e3032879fb0751d2cc40_b.png" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-48186ce723c345ac9475b7061b02d078_b.png" alt="img"></p><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><p>1：展示所有数据库</p><p><img src="https://pic3.zhimg.com/v2-d31deebab3002456622a5828b72a29aa_b.png" alt="img"></p><p>show databases；</p><p>2：创建park数据库</p><p><img src="https://pic3.zhimg.com/v2-a31aba87a9ae3adf3c0d69954fce60f2_b.png" alt="img"></p><p>create database park；</p><p>3：进入park数据库</p><p><img src="https://pic2.zhimg.com/v2-60ece51abeeaee6b2f79d4267acb9731_b.png" alt="img"></p><p>4：显示所有表</p><p><img src="https://pic3.zhimg.com/v2-1842dcb7a49d9d9082980bf2baa366b2_b.png" alt="img"></p><p>5：创建表</p><p>说明：</p><p>（1）hive里，表示字符串用的是<strong>string</strong>，不用char和varchar</p><p>（2）所创建的表，也是HDFS里的一个目录节点</p><p><img src="https://pic1.zhimg.com/v2-d954352a0b6ba4f183bcad0ffa402038_b.png" alt="img"></p><p>6：增加一条信息</p><p>说明：</p><p>（1）HDFS不支持数据的修改和删除，因此已经插入的数据<strong>不能够再进行任何的改动</strong></p><p>（2）在Hadoop2.0版本后支持了数据追加。实际上，<strong>insert into 语句执行的是追加操作</strong></p><p>（3）hive支持查询，行级别的插入。不支持行级别的删除和修改</p><p>（4）hive的操作实际是执行一个job任务，<strong>调用的是Hadoop的MR</strong></p><p>（5）插入完数据之后，发现HDFS stu目录节点下多了一个文件，文件里存了插入的数据，因此，<strong>hive存储的数据，是通过HDFS的文件来存储的。</strong></p><p><img src="https://pic3.zhimg.com/v2-62a5fa75cd67e612c1083096e9d69dc2_b.png" alt="img"></p><p>7：查询信息</p><p><img src="https://pic2.zhimg.com/v2-48ad70a4ca268113a6c6e3edcc4c150d_b.png" alt="img"></p><p>8：删除表</p><p><img src="https://pic2.zhimg.com/v2-6c09112770e17ad9aad5204dfa2826dd_b.png" alt="img"></p><p>9：通过加载文件数据到对应的表里</p><p>说明：</p><p>在执行完这个指令之后，发现hdfs stu目录下多了一个1.txt文件。由此可见，<strong>hive的工作原理实际上就是在管理hdfs上的文件</strong>，把文件里数据抽象成二维表结构，然后提供hql语句供程序员查询文件数据</p><p><img src="https://pic1.zhimg.com/v2-bfc9254c1acd06a2e03c43d2df0d7f68_b.png" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-acc0e01b26bd70c533af2ef4f4716273_b.png" alt="img"></p><h2 id="元数据概述"><a href="#元数据概述" class="headerlink" title="元数据概述"></a>元数据<strong>概述</strong></h2><ol><li>hive用表的形式来管理hdfs上的文件数据。表名，表里有哪些字段，字段类型，哪张表存在那个数据下等这些表的信息，称之为hive的元数据信息。</li><li>hive默认使用derby数据库作为存储引擎，也就是说元数据信息不存在hdfs上，而是存在这里</li><li>hive安装完后，通常需要换掉元数据库，目前hive除了支持自带的derby外，只支持mysql元数据库</li><li>元数据库的默认字符集为ISO8859-1</li></ol><p><strong>derby存在的问题（为什么要替换掉元数据库？）</strong></p><ol><li>derby是一种文件型的数据库，进入会检查当前目录下是否有metastore_db文件夹（存数据库数据）。有直接用，没有就创建，换目录，元数据就找不到了</li><li>derby为单用户数据库，无法支持多用户同时操作，导致在数据量大连接多的情况下产生大量连接积压</li></ol><p><strong>替换元数据</strong></p><p>1.进入conf目录下，编辑新的配置文件，名字为：hive-site.xml,增加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop01:3306/hive?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.输入hive观察权限是否足够</strong></p><p><img src="https://pic1.zhimg.com/v2-a27b5d36af2f850df3c88003d2b7f5c4_b.png" alt="img"></p><p>如果出现如图错误，表示当前操作mysql的用户权限不够</p><p><strong>3.若权限不够，则进入mysql为当前用户分配权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行：grant all privileges on *.* to &#x27;root&#x27;@&#x27;hadoop01&#x27; identified by &#x27;root&#x27; with grant option;</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/v2-785f94c0d5c7459484bcccc8fbb2dc5d_b.png" alt="img"></p><p>通过root向该用户赋予某个权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行：grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-13981adbff0bac167f23b18ee469dd97_b.png" alt="img"></p><p>通过root向该用户赋予全部权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行：flush privileges;</span><br></pre></td></tr></table></figure><p>将当前user和privilige表中的用bai户信息/权限设du置从mysql库(MySQL数据库的内置库)中提取到内存里。用户数据和权限修改后，希望在不重启mysql的情况下直接生效，执行这个命令。</p><p><strong>4.进入数据库执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database hive character set latin1;</span><br></pre></td></tr></table></figure><p>latin1就是ISO-8859-1的别名，因为元数据的默认字符集为这</p><p><strong>5.再次执行hive，看到如图输出信息，则成功</strong></p><p><img src="https://pic3.zhimg.com/v2-4a9a7691007a5f8b6674dfff70f8f85a_b.png" alt="img"></p><p><strong>6.可以通过DBS 、TBLS、COLUMNS_V2、SDS这几张表来查看元数据信息</strong></p><p><img src="https://pic4.zhimg.com/v2-a84f70af169af7cd7a0b885d33783147_b.png" alt="img"></p><p><img src="https://pic2.zhimg.com/v2-04ffdbf155e395da1d181d5318993791_b.png" alt="img"></p><p>​    DBS 存放的数据库的元数据信息；TBLS存放的tables表信息；COLUMNS表存放的是列字段信息；SDS表存放的HDFS里的位置信息</p><h2 id="刚提到了string，那么来说下数据类型"><a href="#刚提到了string，那么来说下数据类型" class="headerlink" title="刚提到了string，那么来说下数据类型"></a>刚提到了string，那么来说下数据类型</h2><p><img src="https://pic3.zhimg.com/v2-a1b754b81d25c3e32ab41c7a6cadd89e_b.png" alt="img"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h2><p><img src="https://pic4.zhimg.com/v2-5790301ad363e86d4e1214292e01f133_b.png" alt="img"></p><p><strong>从上图可以看出Hive内部架构由四部分构成</strong></p><blockquote><p>1.<strong>用户接口</strong>（最上面一层CLI,JDBC/ODBC(Open Database Connectivity，开放数据库互连),Webui） CLI，Shell终端命令行，采用交互形式使用hive命令行与hive进行交互（学习，调试，生产最常用） 2.<strong>跨语言服务</strong>（thrift server提供了一种能力，让用户通过不同的语言去操纵hive） thrift是Facebook开发的一个软件框架，可以用来进行可扩展和跨语言的开发，hive继承了该服务，能让不同的编程语言调用hive的接口 3.<strong>底层的driver</strong>，驱动器的driver，编译器compiler，优化器optimizer，执行器executeor driver组件完成HQL查询语句从词法分析，编译，优化，以及生成逻辑执行计划的生成。生成的逻辑执行计划存储在HDFS中，并随后由mapreduce调用执行 4.<strong>元数据存储系统</strong>，RDBMS MYSQL Hive的元数据包括：表的名字，列，属性（内部表，外部表），数据所在的目录 metastore默认自带derby数据库。数据存储目录不固定，数据库跟着hive走，极度不方便管理 hive和metastore通过MySQL服务交互</p></blockquote><p><strong>执行流程</strong></p><p>HiveQL通过命令行或者客户端进行提交，经过compiler编译器，运用metastore中的元数据进行类型检测和语法分析，生成一个逻辑方案，然后通过优化处理，产生一个MR任务</p><h2 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h2><blockquote><p><strong>1.hive的存储结构包括数据库，表，分区和表数据等。前三个对应HDFS上的目录。表数据对应HDFS目录下的文件</strong>  <strong>2.hive的所有数据都存储在HDFS中，没有专门的存储格式，因为Hive是读模式。</strong>  <strong>3.创建表的时候只需要告诉hive数据中的列分隔符和行分隔符，hive就可以解析数据</strong> hive的默认列分隔符：crtl+a hive的默认行分隔符：换符行\n  <strong>4.hive包含以下数据模型</strong> database：在 HDFS 中表现为${hive.metastore.warehouse.dir}目录下一个文件夹 table:在 HDFS 中表现所属 database 目录下一个文件夹 external table:与 table 类似，不过其数据存放位置可以指定任意 HDFS 目录路径 partition:在 HDFS 中表现为 table 目录下的子目录 bucket:在 HDFS 中表现为同一个表目录或者分区目录下根据某个字段的值进行hash散列之后的多个文件 view:与传统数据库类似，只读，基于基本表创建</p></blockquote><h2 id="内部表和外部表"><a href="#内部表和外部表" class="headerlink" title="内部表和外部表"></a>内部表和外部表</h2><blockquote><p>在hive中的表就是内部表，在内部表之上建立的表叫外部表  <strong>区别</strong> 删除内部表，<strong>删除表元数据和数据</strong> 删除外部表，<strong>删除元数据，不删除数据</strong>  <strong>使用选择</strong> 所有的数据处理都在hive中进行，那么倾向于内部表 和其他工具要针对相同的数据集做处理，外部表更合适 hive仅仅只是对存储在HDFS上的数据提供了一种新的抽象。而不是管理HDFS上的数据 所以不管创建内部表还是外部表，都可以对hive表的数据存储目录中的数据进行增删操作  <strong>分区表和分桶表的区别</strong> 分区和分桶都是细化数据管理，但是分区表是手动添加区分，由于 Hive 是读模式，所 以对添加进分区的数据不做模式校验，分桶表中的数据是按照某些分桶字段进行 hash 散列 形成的多个文件，所以数据的准确性也高很多</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop学习笔记</title>
      <link href="/post/8f488ef0.html"/>
      <url>/post/8f488ef0.html</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>基础知识</li><li>HDFS</li><li>NameNode</li><li>DataNode</li><li>SecondaryNameNode</li><li>HDFS读写文件</li><li>MapReduce</li><li>Yarn</li><li>Shell操作</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>是什么？</strong></p><p>以下来自官网</p><blockquote><p>The Apache™ Hadoop® project develops open-source software for reliable, scalable, distributed computing. The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage. Rather than rely on hardware to deliver high-availability, the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.</p></blockquote><p>总结为一句话就是<strong>存储</strong>海量数据和<strong>分析</strong>海量数据的工具。</p><ul><li>hadoop的框架最核心的设计就是：<strong>HDFS</strong>和<strong>MapReduce</strong>。</li><li>HDFS为海量的数据提供了<strong>存储</strong>，则MapReduce为海量的数据提供了<strong>计算</strong></li><li>HDFS为一个分布式的，有冗余备份的，可以动态扩展的用来存储大规模数据的大硬盘。</li><li>MapReduce为一个计算引擎，按照MapReduce的规则编写Map计算/Reduce计算的程序，可以完成计算任务。</li></ul><p><strong>能做什么？</strong></p><ul><li>大数据存储</li><li>分布式存储日志处理</li><li>擅长日志分析ETL:数据抽取到oracle、mysql、DB2、mongdb及主流数据库</li><li>机器学习: 比如Apache Mahout项目</li><li>搜索引擎:Hadoop + lucene实现</li><li>数据挖掘：目前比较流行的广告推荐，个性化广告推荐</li></ul><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>用图解的方式理解</p><p><img src="https://pic4.zhimg.com/v2-f73dd5712d42920b6f8c9339e2a0e39f_b.png" alt="img"></p><p>HDFS是干什么的</p><p><img src="https://pic1.zhimg.com/v2-8fe7136c4d56a0225ad5440c430a9798_b.png" alt="img"></p><p>HDFS处理文件的思路</p><p><img src="https://pic2.zhimg.com/v2-479005721d78ec61801854c596d4c4f1_b.png" alt="img"></p><p><img src="https://pic3.zhimg.com/v2-356944bc8fbc8303d1a278ed3b12620e_b.png" alt="img"></p><p>HDFS架构</p><p><img src="https://pic3.zhimg.com/v2-cce5b4499fe45ceb7cb102aa9c8065ee_b.png" alt="img"></p><p>HDFS读取过程</p><p><img src="https://pic2.zhimg.com/v2-6b4c7c4299bd2b306d171b9f42a9ccd5_b.png" alt="img"></p><p>HDFS写入过程</p><p> <strong>HDFS的实现思想</strong></p><ol><li>通过分布式集群来存储文件</li><li>文件存储到集群中是切分为block去存的</li><li>文件的block存放在若干个datanode节点上</li><li>hdfs中的文件与真实的block之间有映射关系，由namenode管理</li><li>每个block集群中存储有多个副本，防止一台挂掉后数据丢失，提高数据可靠性，同时访问一个资源，资源多了，吞吐量也就大了，提高了访问吞吐量</li></ol><h2 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h2><blockquote><p>如同一个<strong>管理者</strong>，负责文件<strong>在哪些机器上存的，如何存的</strong>。 在 HDFS 里， Name node 保存了整个文件系统信息，包括文件和文件夹的结构。HDFS 也是把文件和文件夹表示为 inode, 每个 inode 有自己的所有者，权限，创建和修改时间等等。 HDFS 可以存很大的文件，所以每个文件都被分成一些 data block，存在不同机器上, name node 就负责记录一个文件有哪些 data block，以及这些 data block 分别存放在哪些机器上。 Name nodes 还负责管理文件系统常用操作，比如创建一个文件，重命名一个文件，创建一个文件夹，重命名一个文件夹等。</p></blockquote><p><strong>技术细节</strong></p><ol><li>在Hadoop1.0中，NameNode存在单点故障问题</li><li>NameNode维护HDFS中的元数据信息：</li><li>文件和Block之间关系的信息</li><li>Block数量信息</li><li>Block和DataNode之间的关系信息</li><li>元数据格式参照：FileName replicas       block-Ids id2host。例如：       /test/a.log,3,{b1,b2},[{b1:[h0,h1,h3]},{b2:[h0,h2,h4]}]</li><li>NameNode通过RPC心跳机制监测DataNode</li><li>每一条元数据大概是<strong>150B</strong>大小</li><li>元数据信息存储在内存以及文件中，内存中为实时信息，这样做的目的是为了快速查询</li><li>元数据信息会持久化到NameNode节点的硬盘上，持久化目录的路径是由core-site.xml的dfs.tmp.dir属性来决定的。此参数如果不配置，默认是放在/tmp</li><li>存储元数据的目录：dfs/name/current</li><li>持久化的文件包括：</li><li>fsimage：元数据镜像文件。存储某NameNode元数据信息，并不是实时同步内存中的数据。</li><li>edits：操作日志文件,记录了NameNode所要执行的操作</li><li>当有写请求时，NameNode会首先写该操作先写到磁盘上的edits文件中，当edits文件写成功后才会修改内存，并向客户端返回成功信号，而此时fsimage中的数据并没有发生改动。所以，fsimage中的数据并不是实时的数据，而是在达到条件时再进行更新，更新过程需要SecondaryNameNode参与</li><li>无论是Hadoop1.0还是2.0，当HDFS启动,NameNode会做一次edits和fsimage合并的操作。这样做的目的是确保fsimage里的元数据更新。</li><li>可以通过指令手动合并：hadoop dfsadmin      -rollEdits</li><li>当HDFS启动的时候，NameNode会将fsimage中的元数据信息加载到内存中</li><li>当HDFS启动时，每个DataNode会向NameNode汇报自身的存储的信息，比如存储了哪些文件块，块大小，块id等。NameNode收到这些信息之后，会做汇总和检测，检测数据是否完整，复本数量是否达到要求，如果检测出现问题，HDFS会进入安全模式，在安全模式做数据或副本的复制，直到修复完成后，安全模式自动退出。</li><li>如果HDFS处于安全模式，只能对外读服务，不能写服务。</li></ol><h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><blockquote><p>存储 data block 的机器叫做 Data nodes.  在读写过程中，Data nodes 负责直接把用户读取的文件 block 传给 client，也负责直接接收用户写的文件。</p></blockquote><p><strong>当我们读取一个文件时</strong></p><blockquote><p>HDFS client 联系 Name nodes，获取文件的 data blocks 组成、以及每个 data block 所在的机器以及具体存放位置 HDFS client 联系 Data nodes, 进行具体的读写操作； 在读写一个文件时，当我们从 Name nodes 得知应该向哪些 Data nodes 读写之后，我们就直接和 Data node 打交道，不再通过 Name nodes.</p></blockquote><p><strong>技术细节</strong></p><ol><li>在HDFS中，数据是存放在DataNode上面的，并且是以Block的形式存储的</li><li>存储Block的目录：dfs/data/current/BP-1998993700-192.168.150.137-1537051327964/current/finalized/subdir0/subdir0</li><li>DataNode节点会不断向NameNode节点发送心跳报告</li><li>在HDFS启动的时候，每个DataNode将当前存储的数据块信息告知NameNode节点</li><li>DataNode通过向NameNode主动发送心跳保持与其联系，默认是每隔3秒发送一次心跳信息</li><li>心跳信息包含这个节点的状态以及数据块信息</li><li>如果10分钟都没收到dn的心跳，则认为其已经lost，那么NameNode会copy这个DataNode上的Block到其他DataNode上</li><li>在HDFS中，DataNode上存储的复本Replication是多复本策略。默认是三个</li><li>如果是伪分布式模式，副本只能配置1个，因为如果副本数量&gt;1，会导致HDFS一致处于安全模式而不能退出</li></ol><h2 id="SecondaryNameNode"><a href="#SecondaryNameNode" class="headerlink" title="SecondaryNameNode"></a>SecondaryNameNode</h2><ol><li>SecondaryNameNode并不是NameNode的热备份，而是协助者帮助NameNode进行元数据的合并，</li><li>合并过程可能会造成极端情况下的数据丢失，此时可以从SecondaryNameNode中恢复部分数据，但是无法恢复全部</li><li>SecondaryNameNode是Hadoop1.0机制。<strong>Hadoop2.0已经弃用</strong>。如果是Hadoop2.0的伪分布式，还是会看到SecondaryNameNode进程；如果是Hadoop2.0的完全分布式，SecondaryNameNode已经舍弃</li><li>合并时机：</li><li>根据配置文件设置的时间间隔：fs.checkpoint.period  默认3600秒</li><li>根据配置文件设置的edits log大小 fs.checkpoint.size 默认64MB</li><li>当HDFS启动时候,也会触发合并</li><li>合并过程：</li><li>达到条件后SecondaryNameNode会将nn中的fsimage和edits文件通过网络拷贝过来</li><li>同时NameNode中会创建一个新的edits.new文件，新的读写请求会写入到这个edits.new中</li><li>在SecondaryNameNode中，会将拷贝过来的fsimage和edits加载到内存中，将数据进行合并，然后将合并后的数据写到一个新的文件fsimage.ckpt中</li><li>最后SecondaryNameNode将合并完成的fsimage.ckpt文件拷贝回NameNode中替换之前的fsimage，同时NameNode再将edtis.new重命名为edits</li></ol><p><img src="https://pic2.zhimg.com/v2-8c378195c3777a0d5e72abe2d304acd5_b.png" alt="img"></p><h2 id="HDFS读写文件"><a href="#HDFS读写文件" class="headerlink" title="HDFS读写文件"></a>HDFS读写文件</h2><p><strong>HDFS写文件</strong></p><p>假如上传一个200M的文件，从<strong>client</strong>上传到NameNode</p><p>1：client向namenode发起一个申请。先看文件是否重名。再看是否有权限，如果namenode同意，进行2</p><p><img src="https://pic4.zhimg.com/v2-def385fd8598b98c0bc1c82c92945c0f_b.png" alt="img"></p><p>2：将文件切块。先进行划线，此时文件还是一块，开输出流。请求上传第一个block块（0-128M）</p><p><img src="https://pic2.zhimg.com/v2-768062b996a2e850aa74bd34b1dada71_b.png" alt="img"></p><p>3：namenode返回三个datanode，表示采用三个节点存储数据。DN1为client最近的，DN2,3是DN1选出来的。两个问题怎么就最近？DN1怎么选？</p><p><img src="https://pic3.zhimg.com/v2-99711124982df3058f3da39947a3a066_b.png" alt="img"></p><p>4：client向datanode1请求建立通道，DN1向DN2，DN2向DN3</p><p><img src="https://pic2.zhimg.com/v2-94035e678ad2b7003e91fc8095f98e21_b.png" alt="img"></p><p>串联通道，不是并联（为什么？）</p><p><img src="https://pic3.zhimg.com/v2-8b87177b88c9424c0414618327da39da_b.png" alt="img"></p><p>5：应答成功后，开始传数据。不是等1完了在给2传，有个队列，第一块（128M）的发完，发第二块</p><p><img src="https://pic2.zhimg.com/v2-85de8bb07d3904df781a6fba423a0d1d_b.png" alt="img"></p><blockquote><p>HDFS存储数据的最小单位是块 如果建立通道的过程中失败，抛出异常 如果传输数据的时候失败，上传失败 如果后两失败，传输还可以进行，他会去找DN7,8</p></blockquote><p><img src="https://pic1.zhimg.com/v2-d0db4e4c7a32d70f7ab87543d1b50908_b.png" alt="img"></p><p>附个总图</p><p><img src="https://pic2.zhimg.com/v2-628b6e372d3df288982be14c39d4fe11_b.png" alt="img"></p><p><strong>HDFS读文件</strong></p><p>相较于写文件来说，由于少了副本的选择所以相对于简单一点</p><p>1：client向NameNode申请下载文件，还是看文件是否存在，然后看权限，有的话响应</p><p><img src="https://pic3.zhimg.com/v2-e35c312674c3851926144256a06b3c46_b.png" alt="img"></p><p>2：开一个输入流，请求下载第一个block（0-128M）NameNode返回三个（个数取决于副本数量）DN，表示采用这三个节点的数据</p><p>3：client只会和第一个DN建立通道，应答成功后传输，DN2,3为备胎，三个有一个成功都能下载，都不成功下载失败，最后NameNode告诉client数据传输完毕。</p><p><img src="https://pic1.zhimg.com/v2-95875b894c55819f80935dd24eaa60f0_b.png" alt="img"></p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>由于它实操比较繁琐，做计算这块基本不直接用了，像spark之类的就帮他做了。这块的实操比较少，像它的worldcount，API操作我就不写了，想了解的话自行了解一下吧</p><p><strong>什么是MapReduce</strong></p><p>综合来看，MapReduce就是你有很多各种各样的蔬菜水果面包（Input），有很多厨师，不同的厨师分到了不同的蔬菜水果面包，自己主动去拿过来（Split），拿到手上以后切碎（Map），切碎以后给到不同的烤箱里，冷藏机里（Shuffle），冷藏机往往需要主动去拿，拿到这些东西存放好以后会根据不同的顾客需求拿不同的素材拼装成最终的结果，这就是Reduce，产生结果以后会放到顾客那边等待付费（Ticket），这个过程是Finalize。</p><p>所以MapReduce是六大过程，简单来说：<strong>Input, Split, Map, Shuffle, Reduce, Finalize</strong>。</p><p><img src="https://pic4.zhimg.com/v2-5f2c9c749cf7a5d04b857790d11a7723_b.png" alt="img"></p><p>MR框架对于程序猿的最大意义在于，不需要掌握分布式计算编程，不需要考虑分布式编程里可能存在的种种难题，比如任务调度和分配、文件逻辑切块、位置追溯、工作。这样，<strong>程序员能够把大部分精力放在核心业务层面上，大大简化了分布式程序的开发和调试周期。</strong></p><p><strong>想了解Map的shuffle和Reduce的shuffle看过来，不然直接跳</strong></p><p><strong>Map的shuffle</strong></p><blockquote><p> Map端会处理输入数据并产生中间结果，这个中间结果会写到本地磁盘，而不是HDFS。每个Map的输出会先写到内存缓冲区中，当写入的数据达到设定的阈值时，系统将会启动一个线程将缓冲区的数据写到磁盘，这个过程叫做spill。（溢出，理解为内存溢出的部分写到磁盘的过程） 　在spill写入之前，会先进行二次排序，首先根据数据所属的partition（分割）进行排序，然后每个partition中的数据再按key来排序。partition的目是将记录划分到不同的Reducer上去，以期望能够达到负载均衡，以后的Reducer就会根据partition来读取自己对应的数据。接着运行combiner(如果设置了的话)，combiner（整合）的本质也是一个Reducer，其目的是对将要写入到磁盘上的文件先进行一次处理，这样，写入到磁盘的数据量就会减少。最后将数据写到本地磁盘产生spill文件(spill文件保存在{mapred.local.dir}指定的目录中，Map任务结束后就会被删除)。 　最后，每个Map任务可能产生多个spill文件，在每个Map任务完成前，会通过多路归并算法将这些spill文件归并成一个文件。至此，Map的shuffle过程就结束了。</p></blockquote><p><strong>Reduce的shuffle</strong></p><blockquote><p>主要包括三个阶段，copy、sort(merge)和reduce。 　首先要将Map端产生的输出文件拷贝到Reduce端，但每个Reducer如何知道自己应该处理哪些数据呢？因为Map端进行partition的时候，实际上就相当于指定了每个Reducer要处理的数据(partition就对应了Reducer)，所以Reducer在拷贝数据的时候只需拷贝与自己对应的partition中的数据即可。每个Reducer会处理一个或者多个partition，但需要先将自己对应的partition中的数据从每个Map的输出结果中拷贝过来。 　接下来就是sort阶段，也成为merge阶段，因为这个阶段的主要工作是执行了归并排序。从Map端拷贝到Reduce端的数据都是有序的，所以很适合归并排序。最终在Reduce端生成一个较大的文件作为Reduce的输入。 　最后就是Reduce过程了，在这个过程中产生了最终的输出结果，并将其写到HDFS上。</p></blockquote><p><img src="https://pic4.zhimg.com/v2-1f3508e426bebaef5f8810ed50241d1f_b.png" alt="img"></p><p> 参考文章：《Hadoop权威指南》</p><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p><strong>什么是yarn？</strong></p><p>在古老的 Hadoop1.0 中，MapReduce 的 JobTracker 负责了太多的工作，包括资源调度，管理众多的 TaskTracker 等工作。这自然是不合理的，于是 Hadoop 在 1.0 到 2.0 的升级过程中，便将 JobTracker 的资源调度工作独立了出来，而这一改动，直接让 Hadoop 成为大数据中最稳固的那一块基石。<strong>而这个独立出来的资源管理框架，就是 Yarn</strong> 。</p><p><strong>为什么用yarn？</strong></p><p>防止集群累垮</p><p><strong>三个主要组件</strong></p><blockquote><p>ResourceManager；ApplicationMaster；NodeManager <strong>ResourceManager</strong> 整个系统有且只有一个 RM ，来负责资源的调度。它也包含了两个主要的组件：定时调用器(Scheduler)以及应用管理器(ApplicationManager)。 **定时调度器(Scheduler)**：从本质上来说，定时调度器就是一种策略，或者说一种算法。当 Client 提交一个任务的时候，它会根据所需要的资源以及当前集群的资源状况进行分配。注意，它只负责向应用程序分配资源，并不做监控以及应用程序的状态跟踪。 **应用管理器(ApplicationManager)**：应用管理器就是负责管理 Client 用户提交的应用。定时调度器（Scheduler）不对用户提交的程序监控，监控应用的工作正是由应用管理器（ApplicationManager）完成的。 主要作用如下： 1：处理客户端请求 2：监控NOdeManage 3：启动或监控ApplicationMaster  <strong>NodeManager</strong> NodeManager 是 ResourceManager 在每台机器的上代理，负责容器的管理，并监控他们的资源使用情况（cpu，内存，磁盘及网络等），以及向 ResourceManager/Scheduler 提供这些资源使用报告。 <strong>ApplicationMaster</strong> 每当 Client 提交一个 Application 时候，就会新建一个 ApplicationMaster 。由这个 ApplicationMaster 去与 ResourceManager 申请容器资源，获得资源后会将要运行的程序发送到容器上启动，然后进行分布式计算。 为什么是把运行程序发送到容器上去运行？因为海量数据移动成本太大，既然大数据难以移动，那我就把容易移动的应用程序发布到各个节点进行计算，这就是大数据分布式计算的思路</p></blockquote><p><strong>Yarn执行流程</strong></p><p><img src="https://pic3.zhimg.com/v2-18f3e00584af54c48c7355a600672756_b.png" alt="img"></p><ol><li>客户端向yarn提交作业，首先找 RM 分配资源；</li><li>RM 接收到作业以后，会与对应的 NM 建立通信；</li><li>RM 要求 NM 创建一个 Container 来运行 ApplicationMaster 实例；</li><li>ApplicationMaster 会向 RM 注册并申请所需资源，这样 Client 就可以通过 RM 获知作业运行情况；</li><li>RM 分配给 ApplicationMaster 所需资源，ApplicationMaster 在对应的 NM 上启动 Container；</li><li>Container 启动后开始执行任务，ApplicationMaster 监控各个任务的执行情况并反馈给 RM；</li></ol><p>其中 ApplicationMaster 是可插拔的，可以替换为不同的应用程序。</p><h2 id="Shell操作"><a href="#Shell操作" class="headerlink" title="Shell操作"></a>Shell操作</h2><p><strong>什么是shell？</strong></p><blockquote><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p></blockquote><p><strong>shell脚本</strong></p><blockquote><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 业界所说的 shell 通常都是指 shell 脚本，但是shell 和 shell script 是两个不同的概念。</p></blockquote><p><strong>HDFS命令分类</strong></p><p>可以分为3类</p><p><strong>本地—&gt;HDFS（比如上传）</strong></p><p><strong>HDFS—&gt;本地（比如下载）</strong></p><p><strong>HDFS—-&gt;HDFS（自己跟自己玩）</strong></p><p>本地—&gt;HDFS（比如上传）</p><blockquote><p>put copyFromLocal(相当于put) moveFromLocal（剪切） appendTofile（追加比如将2.txt的内容追加到1.txt） HDFS—&gt;本地（比如下载） get getmerge copyToLocal HDFS—-&gt;HDFS cp mv chown chgrp（更改所属群组） chmod mkdir du df cat rm</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oozie学习笔记</title>
      <link href="/post/ecd67acc.html"/>
      <url>/post/ecd67acc.html</url>
      
        <content type="html"><![CDATA[<p>本节笔记比较少，上方链接已说明原因</p><h2 id="为什么要有oozie"><a href="#为什么要有oozie" class="headerlink" title="为什么要有oozie"></a>为什么要有oozie</h2><blockquote><p>说的通俗一点比如说厨房的流程很多。炒饭-&gt;装饭-&gt;送饭。如果按照时间规定什么时候作什么事情，那么遇到一个突发情况 比如说客人增多，就会出现供不应求的情况，就乱套了。如果能有一个人去监督帮我去监控，通知，控制好这个流程 情况就得以解决。 oozie就类似监督人，一个完整的数据分析系统通常是由大量的任务单元组成的，shell脚本，Java程序 MR程序，hive脚本等等，各个单元之前存在前后依赖关系。为了很好的组织这样复杂的执行计划，需要一个工作流调度系统来调节执行。</p></blockquote><p>简单的工作流调度：Liunx的crontab来定义</p><blockquote><p>Linux crontab是用来定期执行程序的命令。 当安装完成操作系统之后，默认便会启动此任务调度命令。 crond 命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p></blockquote><p>复杂的工作流调度：Oozie、Azakaban等</p><h2 id="为什么要使用oozie"><a href="#为什么要使用oozie" class="headerlink" title="为什么要使用oozie"></a>为什么要使用oozie</h2><p>为了管理不同类型的作业在Hadoop系统中的处理</p><p>用户同时保存着整个工作流程，此外也有特定的工作频率</p><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><blockquote><p>workflow：工作流，由我们处理的每个工作组成，进行需求的流式处理，执行分支多节点或合并多分点为一个分支。 coordinator：协调器，可以理解为工作流的协调器，可以将多个工作流协调成一个工作流来处理。定时触发Workflow bundle：将一堆coordinator进行汇总处理。绑定多个Coordinator 总结：workflow是对要进行的顺序化工作的抽象，coordinator是对要进行的顺序化的workflow的抽象，bundle是对一堆coordiantor的抽象。层级关系层层包裹。如图</p></blockquote><p><img src="https://pic3.zhimg.com/v2-ab7c10f5098ef363643844941ff3697e_b.png" alt="img"></p><h2 id="oozie的特点"><a href="#oozie的特点" class="headerlink" title="oozie的特点"></a>oozie的特点</h2><p>1.客户端API以及命令行界面可以用来启动，控制和监视Java应用程序作业</p><p>2.使用其web服务的API可以从任何位置控制作业</p><p>3.有规定执行这些计划定期来运行作业</p><p>4.有规定作业完成后可发送电子邮件通知</p><p><img src="https://pic2.zhimg.com/v2-07da72552b4a976e88479cb3b445609d_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark学习笔记</title>
      <link href="/post/4fa8e0c4.html"/>
      <url>/post/4fa8e0c4.html</url>
      
        <content type="html"><![CDATA[<p>大纲</p><ul><li>基本知识</li><li>架构</li><li>RDD</li></ul><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p><strong>什么是spark</strong></p><p>UC Berkeley AMP Lab开发的一种计算框架，分布式资源工作交由集群管理软件（Mesos，YARN）（Mesos 类似于yarn的一个资源调度框架）</p><p><strong>特点</strong></p><p><strong>先进架构</strong></p><ol><li>spark采用scala语言编写，底层采用了actor model的akka作为通讯框架（spark2之后使用netty改写）</li><li>基于DAG图（有向无环图）的执行引擎，减少多次计算之间中间结果写到HDFS的开销</li><li>建立在统一抽象的RDD（分布式内存抽象）之上，使得它可以以基本一致的方式应对不同的大数据处理场景</li></ol><p><strong>高效</strong></p><ol><li>提供cache机制来支持需要反复迭代的计算或者多次数据共享，减少数据读取的IO开销</li><li>与Hadoop的mapreduce相比，spark<strong>基于内存的计算</strong>比MR快100倍</li></ol><p><strong>易用</strong></p><ol><li>spark提供的广泛数据集操作类型（20+种），不像Hadoop只支持map和reduce两种操作</li><li>spark支持Java，python和scala API,支持交互性的python和Scala的shell</li></ol><p><strong>提供整体解决方案</strong></p><ol><li>以其RDD模型的强大表现能力。逐渐形成了一套自己的生态圈，提供了full-stack的解决方案</li><li>主要包括spark内存中的批处理，spark sql交互式查询，spark streaming流式计算，Graphx和MLlib提供的常用图计算和机器学习算法</li></ol><p><strong>与Hadoop无缝连接</strong></p><ol><li>spark可以使用YARN作为他的集群管理器</li><li>读取HDFS，Hbase等一切Hadoop的数据</li></ol><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://pic4.zhimg.com/v2-8c5e655415a702a73ef5f1cb22ca8cbb_b.png" alt="img"></p><p>1.spark提供了多种高级工具：spark sql即席查询（Ad-hoc query用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表）,spark streaming应用于流式计算，MLlib机器学习，GraphX图形处理</p><p>2.spark基于自带的standlone集群管理器单独运行，也可以部署在Mesos和YARN等集群管理器上进行</p><p>3.spark可以访问存储在HDFS,Hbase，Cassandra，Amazon S3，本地文件系统等等上的数据，spark支持文本文件，序列文件，以及任何Hadoop的InputFormat</p><p><strong>spark核心概念</strong></p><p>spark提供多层分解的概念，spark组件将用户的应用程序分解为内部执行任务并提供执行容器，资源管理器为spark组件提供资源管理和调度</p><p><strong>spark的核心组件包括RDD，Scheduler，Storage，shuffle四部分</strong></p><p>1.RDD是spark中最精髓的部分，spark将所有数据抽象成PDD</p><p>2.Scheduler是spark的调度机制，分为DAGScheduler和TaskScheduler</p><p>3.storage模块主要管理缓存后的RDD，shuffle中间结果数据和broadcast数据</p><p>4.shuffle分为Hash和sort两种方式，两种方式的shuffle中间数据都写本磁盘</p><h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><p><strong>Spark的核心是RDD，那么RDD是什么</strong></p><p>Resilent Distributed Datasets弹性分布式数据集，是spark底层的分布式存储的数据结构，可以说是spark的核心，spark API的所有操作都是基于RDD的，数据不只存储在一台机器上，而是分布在多台机器上，实现数据计算的并行化，弹性辨明数据丢失时，可以进行重建。在spark1.5版本之后新增了数据结构Spark-DataFrame，仿造的R和python的类SQL结构-DataFrame，底层为RDD，能够让数据从业人员更好的操作RDD</p><p> 在Spark的设计思想中，为了减少网络磁盘及磁盘I/O开销，需要设计出一种新的容错方式，于是才诞生了新的数据结构RDD。RDD是一种只读的数据块，可以从外部数据转换而来，你可以对RDD进行函数操作包括 Transformation 和 Action</p><p><img src="https://pic4.zhimg.com/v2-157975285289803b6219b2c6f19325ff_b.png" alt="img"></p><p><strong>RDD的特点</strong></p><ol><li>它是集群节点上不可变的，已分区的集合对象</li><li>通过并行转换的方式来创建</li><li>失败自动创建</li><li>可以控制存储级别（内存，磁盘）来进行重用</li><li>必须是可序列化的</li><li>是静态类型的（只读）</li></ol><p><strong>RDD的创建方式主要有两种</strong></p><ol><li>并行化一个已经存在驱动程序中的集合如set，list</li><li>读取外部存储系统上的一个数据集，比如HDFS,Hive，Hbase或者提供了HadoopInputFormat的数据源，也可以从本地读取txt，scv等数据集</li></ol><p><img src="https://pic4.zhimg.com/v2-87f9ac394d8c7c8d40252b12657f9107_b.png" alt="img"></p><p>Transformation 操作不是马上提交 Spark 集群执行的,Spark 在遇到 Transformation 操作时只会记录需要这样的操作,并不会去执行,需要等到有 Action 操作的时候才会真正启动计算过程进行计算.针对每个 Action,Spark 会生成一个 Job, 从数据的创建开始,经过 Transformation, 结尾是 Action 操作.这些操作对应形成一个有向无环图(DAG),形成 DAG 的先决条件是最后的函数操作是一个Action</p><p><strong>窄依赖跟宽依赖的区别是是否发生 shuffle(洗牌) 操作</strong></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase的学习笔记</title>
      <link href="/post/730d8d6c.html"/>
      <url>/post/730d8d6c.html</url>
      
        <content type="html"><![CDATA[<p>我这个看3y的文章整理的，大家也可以看原作</p><p><a href="https://zhuanlan.zhihu.com/p/145551967">我终于看懂了HBase，太不容易了… - 知乎 (zhihu.com)</a></p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>基本知识</li><li>基础指令</li><li>架构</li><li><strong>HRegionServer</strong></li><li>Hlog</li><li>Hmaster</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>为什么HBase能存储海量的数据？</strong></p><p>因为它在HDFS的基础之上构建的，HDFS是分布式文件系统<strong>。</strong>HBase的数据其实也是存储在HDFS上的。</p><p><strong>已经有HDFS了，为什么还要用Hbase？</strong></p><blockquote><p>HDFS是可以存储海量的数据的，它就是为海量数据而生的。它也有明显的缺点：不支持随机修改，查询效率低，对小文件支持不友好。 HDFS是文件系统，而HBase是数据库，其实也没可比性。「<strong>HBase当做是MySQL，把HDFS当做是硬盘</strong>。HBase只是一个NoSQL数据库，把数据存在HDFS上」。 <strong>总结</strong>：HBase在HDFS之上提供了<strong>高并发的随机写和支持实时查询</strong>，这是HDFS不具备的。</p></blockquote><p><strong>列式存储</strong></p><p>Hbase不同于MySQL就是列式存储，MySQL是行式存储，比如下图</p><p><img src="https://pic3.zhimg.com/v2-fb03359f98f8998f5a180827b2ccb152_b.png" alt="img"></p><p>列式存储为下图</p><p><img src="https://pic3.zhimg.com/v2-98f1021c2bf503b46f3d5ca386e2855a_b.png" alt="img"></p><p><strong>为什么用列式存储</strong></p><p>从上图可以看出，存相同的数据，列式存储空间能够充分利用</p><p>在HBase里边，定位一行数据会有一个唯一的值，这个叫做<strong>行键</strong>(RowKey)。</p><p>在HBase里边，先有列族，后有列。</p><p><strong>什么是列族</strong>？可以简单理解为：列的属性类别</p><p><strong>什么是列修饰符</strong>？先有列族后有列，在列族下用列修饰符来标识一列。</p><p><img src="https://pic2.zhimg.com/v2-837ed8ff4fedf44d2e6e40568f44f4c1_b.png" alt="img"></p><p>样例</p><p><img src="https://pic2.zhimg.com/v2-6a65b264503b8401a1258665b3a59e25_b.png" alt="img"></p><p>放入具体的值</p><p><img src="https://pic4.zhimg.com/v2-be99f1396149839d956c14cd28046ed3_b.png" alt="img"></p><p>这个跟上面一样</p><p>HBase表的每一行中，列的组成都是<strong>灵活的</strong>，行与行之间的列<strong>不需要相同</strong>。如图下：</p><p><img src="https://pic3.zhimg.com/v2-f362308908ee8e05c30606c4c2c5b442_b.png" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-c5bf0b416099be5db456f9a9f881cfcf_b.png" alt="img"></p><p><strong>一个列族下可以任意添加列，不受任何限制</strong></p><p>数据写到HBase的时候都会被记录一个时间戳，这个时间戳被我们当做一个版本。比如说，我们修改或者删除某一条的时候，本质上是往里边新增一条数据，记录的版本加一了而已。</p><p>比如</p><p><img src="https://pic3.zhimg.com/v2-42a3d0307754a0889f55ef10f536a2ae_b.png" alt="img"></p><p>现在要把这条记录的值改为40，实际上就是多添加一条记录，在读的时候按照时间戳读最新的记录。在外界「看起来」就是把这条记录改了。</p><p><img src="https://pic1.zhimg.com/v2-9df7e0f4d61086bcfc22cd4eea7d0488_b.png" alt="img"></p><p>HBase本质上其实就是<strong>Key-Value</strong>的数据库</p><p><img src="https://pic2.zhimg.com/v2-7e659658d2b67878daae0b2dee8063b1_b.png" alt="img"></p><p>Key由RowKey(行键)+ColumnFamily（列族）+Column Qualifier（列修饰符）+TimeStamp（时间戳–版本）+KeyType（类型）组成，而Value就是实际上的值。</p><p>如果我们要准确定位一条数据，那就得（RowKey+Column+时间戳）。</p><p>如果要删除一条数据怎么做？实际上也是增加一条记录，只不过我们在KeyType里边设置为“Delete”就可以了。</p><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><p><img src="https://pic3.zhimg.com/v2-0f7cee97cfae9e11f232ae122989720e_b.png" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-5fb7d1b69a68a4115a1bb57db0ab2bab_b.png" alt="img"></p><p>主要是上面的都需要知道，指令最好<strong>手敲</strong>，下面的了解即可</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://pic4.zhimg.com/v2-f256667f08b5c45e12e7f45ac95b1ddf_b.png" alt="img"></p><blockquote><p>1、Client客户端，它提供了访问HBase的接口，并且维护了对应的cache来加速HBase的访问。 2、Zookeeper存储HBase的元数据（meta表），无论是读还是写数据，都是去Zookeeper里边拿到meta元数据<strong>告诉给客户端去哪台机器读写数据</strong> 3、HRegionServer它是处理客户端的读写请求，负责与HDFS底层交互，是真正干活的节点。</p></blockquote><p><strong>总结大致的流程</strong>就是：client请求到Zookeeper，然后Zookeeper返回HRegionServer地址给client，client得到Zookeeper返回的地址去请求HRegionServer，HRegionServer读写数据后返回给client。</p><p><img src="https://pic4.zhimg.com/v2-381652c9d71dbd348f75340f56dd582f_b.png" alt="img"></p><p>总结</p><blockquote><p>1：HBase是一个NoSQL数据库，一般我们用它来存储海量的数据（因为它基于HDFS分布式文件系统上构建的） 2：HBase的一行记录由一个RowKey和一个或多个的列以及它的值所组成。先有列族后有列，列可以随意添加。 3：HBase的增删改记录都有「版本」，默认以时间戳的方式实现。 4：RowKey的设计如果没有特殊的业务性，最好设计为散列的，这样避免热点数据分布在同一个HRegionServer中。 5：HBase的读写都经过Zookeeper去拉取meta数据，定位到对应的HRegion，然后找到HRegionServer</p></blockquote><h2 id="HRegionServer"><a href="#HRegionServer" class="headerlink" title="HRegionServer"></a><strong>HRegionServer</strong></h2><p><img src="https://pic1.zhimg.com/v2-d4940b2e141e2b9f273f02997a1ea408_b.png" alt="img"></p><p>HRegionServer内部</p><p><strong>HBase一张表的数据会分到多台机器上的</strong>。那HBase是怎么切割一张表的数据的呢？用的就是<strong>RowKey</strong>来切分，其实就是表的横向切割。</p><p><img src="https://pic2.zhimg.com/v2-be3f839bda7b9dbde28fb0a11f1344d9_b.png" alt="img"></p><p>说白了就是一个HRegion上，存储HBase表的一部分数据。</p><p><img src="https://pic4.zhimg.com/v2-1601725983686d49219667007f17652b_b.png" alt="img"></p><p><strong>图中的Store</strong>：一个列族的数据是存储在一起的，所以一个列族的数据是存储在一个Store里边的。HBase是基于列族存储的（毕竟物理存储，一个列族是存储到同一个Store里的）</p><p><img src="https://pic2.zhimg.com/v2-01f8863757cd1d9ff96b132f6475401d_b.png" alt="img"></p><p><strong>Store里边有啥</strong>？有Mem Store、Store File、HFile，我们再来看看里边都代表啥含义。</p><p><img src="https://pic1.zhimg.com/v2-f3eaa0f2adb94288de835c4e54342ce4_b.png" alt="img"></p><p>HBase在写数据的时候，会先写到<strong>Mem Store</strong>，当MemStore超过一定阈值，就会将内存中的数据刷写到硬盘上，形成<strong>StoreFile</strong>，而StoreFile底层是以<strong>HFile</strong>的格式保存，HFile是HBase中KeyValue数据的存储格式。</p><h2 id="Hlog"><a href="#Hlog" class="headerlink" title="Hlog"></a>Hlog</h2><p><img src="https://pic3.zhimg.com/v2-d74a081bf2c1f50d908787e7009f7632_b.png" alt="img"></p><blockquote><p>我们写数据的时候是先写到内存的，为了防止机器宕机，内存的数据没刷到磁盘中就挂了。我们在写Mem store的时候还会写一份HLog。 这个HLog是顺序写到磁盘的，所以速度还是挺快的 HRegionServer是真正干活的机器（用于与hdfs交互），我们HBase表用RowKey来横向切分表 HRegion里边会有多个Store，每个Store其实就是一个列族的数据（所以我们可以说HBase是基于列族存储的） Store里边有Men Store和StoreFile(HFile)，其实就是先走一层内存，然后再刷到磁盘的结构</p></blockquote><h2 id="Hmaster"><a href="#Hmaster" class="headerlink" title="Hmaster"></a>Hmaster</h2><p><img src="https://pic1.zhimg.com/v2-598ded78551680b52a9e7510013ee0fc_b.png" alt="img"></p><blockquote><p>HMaster会处理 HRegion 的分配或转移。如果我们HRegion的数据量太大的话，HMaster会对拆分后的Region<strong>重新分配RegionServer</strong>。（如果发现失效的HRegion，也会将失效的HRegion分配到正常的HRegionServer中） <strong>HMaster会处理元数据的变更和监控RegionServer的状态。</strong> <strong>RowKey的设计</strong> RowKey是<strong>唯一的</strong>，毕竟它是行键，有了它我们才可以唯一标识一条数据的。 在HBase里边提供了三种的查询方式： 全局扫描 根据一个RowKey进行查询 根据RowKey过滤的范围查询 <strong>根据一个RowKey进行查询</strong> RowKey是会按<strong>字典序排序</strong>的，我们HBase表会用RowKey来横向切分表。 无论是读和写我们都是用RowKey去定位到HRegion，然后找到HRegionServer。这里有一个很关键的问题：<strong>那怎么知道这个RowKey是在这个HRegion上的</strong>？ HRegion上有两个很重要的属性：<strong>start-key</strong>和<strong>end-key</strong>。 我们在定位HRegionServer的时候，实际上就是定位我们这个RowKey在不在这个HRegion的start-key和end-key范围之内，如果在，说明我们就找到了。  这个时候会带来一个问题：由于我们的RowKey是以字典序排序的，如果我们对RowKey没有做任何处理，那就有可能存在<strong>热点数据</strong>的问题。</p></blockquote><p>例如现在我们的RowKey如下：</p><p><img src="https://pic1.zhimg.com/v2-847808c1a6518daf4e7586d34d39af48_b.png" alt="img"></p><blockquote><p>Java3yxxx开头的RowKey很多，而其他的RowKey很少。如果我们有多个HRegion的话，那么存储Java3yxxx的HRegion的数据量是最大的，而分配给其他的HRegion数量是很少的。  关键是我们的查询也几乎都是以java3yxxx的数据去查，这会导致某部分数据会集中在某台HRegionServer上存储以及查询，而其他的HRegionServer却很空闲。  <strong>对RowKey散列</strong>就好了，那分配到HRegion的时候就比较均匀，少了热点的问题。 <strong>生成RowKey时,尽量进行加盐或者哈希的处理,这样很大程度上可以缓解数据热点问题.</strong> <strong>根据RowKey范围查询</strong> 以上是针对通过<strong>RowKey单个查询</strong>的业务的，如果我们是根据<strong>RowKey范围查询</strong>的，那没必要上面那样做。 HBase将RowKey设计为字典序排序，如果不做限制，那很可能类似的RowKey存储在同一个HRegion中。那我正好有这个场景上的业务，那我查询的时候不是快多了吗？<strong>在同一个HRegion就可以拿到我想要的数据了。</strong> 举个例子：我们会间隔几秒就采集直播间热度，将这份数据写到HBase中，然后业务方经常要把主播的一段时间内的热度给查询出来。 我设计好的RowKey，将该主播的一段时间内的热度都写到<strong>同一个HRegion上</strong>，拉取的时候只要访问一个HRegionServer就可以得到全部我想要的数据了，那查询的速度就快很多。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下JDK与tomcat的安装</title>
      <link href="/post/3d20c1d7.html"/>
      <url>/post/3d20c1d7.html</url>
      
        <content type="html"><![CDATA[<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>1、去官网下载tar.gz包</p><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.htmlwww.oracle.com">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.htmlwww.oracle.com</a></p><p><img src="https://pic1.zhimg.com/v2-595266ac1dcf6bcdd2d8312f40b51a00_b.png" alt="img"></p><p>2、上传jdk压缩包到/usr/local路径下</p><p>3、解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-8u91-linux-x64.tar.gz </span><br></pre></td></tr></table></figure><p>4、改名（不是必须步骤）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk1.8.0_91 jdk1.8</span><br></pre></td></tr></table></figure><p>5、<strong>修改环境变量</strong></p><p>vi /etc//profile</p><p>在文件尾部添加如下信息（shift+g快速定位尾部）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>注意第一行是jdk文件实际路径</p><p>6、<strong>刷新环境变量配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>7、输入java验证</p><p>-———————————————————————————————-</p><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>1、从官网下载安装包</p><p>Tomcat 8 Software Downloadstomcat.apache.org</p><p><img src="https://pic2.zhimg.com/v2-19d1741c726fe8323389983c9563c201_b.png" alt="img"></p><p>2、上传解压到/usr/local下</p><p>3、配置环境变量（jdk是前提）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment">#tomcat</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=/usr/<span class="built_in">local</span>/tomcat-8.5.57</span><br><span class="line"> </span><br><span class="line"><span class="comment">#jdk</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>4、配置tomcat的catalina.sh文件，进入tomcat的bin目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi catalina.sh</span><br><span class="line">:/OS specific support(搜索这个然后在这行下面添加以下配置)</span><br><span class="line">CATALINA_HOME=/usr/<span class="built_in">local</span>/tomcat-8.5.57</span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-67fc249c71a13ab27648a04d4015a74b_b.png" alt="img"></p><p>5、安装tomcat服务（就不用每次去bin目录下启动了）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/tomcat-8.5.57/bin/catalina.sh /etc/init.d/tomcat</span><br></pre></td></tr></table></figure><p>6、启停tomcat服务</p><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure><p>停止</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/v2-3ee29fe5d93b7318404f33a97dd0fd41_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Linux </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟机基础环境配置</title>
      <link href="/post/164eee11.html"/>
      <url>/post/164eee11.html</url>
      
        <content type="html"><![CDATA[<p>首先来说需要配置哪些东西</p><ul><li>网络配置</li><li>防火墙设置</li><li>yum源的替换（centos不用）</li></ul><h2 id="一、网络配置（静态网卡配置）"><a href="#一、网络配置（静态网卡配置）" class="headerlink" title="一、网络配置（静态网卡配置）"></a>一、网络配置（静态网卡配置）</h2><p><strong>1、设置网卡开机自启（需要有root权限）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br></pre></td></tr></table></figure><p><strong>2、修改文件内容：</strong></p><p>按下键盘的”i”，进入到了编辑模式，通过方向键移动到该行，将内容修改：</p><p>ONBOOT=no ==&gt; ONBOOT=yes</p><p>按键盘Esc键，退出编辑模式。输入”<strong>:wq</strong>“，保存退出。不想保存，输入q!，来强制退出。</p><p><strong>3、重启网络服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p><strong>4、静态网络配置</strong></p><p>各个配置的意义：</p><ul><li>DEVICE：设置网络接口的名称</li><li>ONBOOT：设置网络接口是否在Linux系统启动时激活</li><li>BOOTPROTO：设置网络接口的配置方式，值为static时表示使用静态ip地址，为dhcp时表示通过dhcp的方式动态获取ip地址</li><li>IPADDR：设置网络接口的ip地址</li><li>NETMASK：设置网络接口的子网掩码</li><li>GATEWAY：设置网络接口的默认网关地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=7ae29e6c-58b2-40d3-8755-769f1e1a1ad3</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.11.132（与虚拟机一致）</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.11.2</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-3d3a824f35b63ef9aef380384c4cefb7_b.png" alt="img"></p><p>进行VMware网络配置</p><p><img src="https://pic1.zhimg.com/v2-b8bd2bee4466ea69e448b2265cbd669c_b.png" alt="img"></p><p>点击VM8网卡，配置子网IP，子网IP同本机IP前三位</p><p><img src="https://pic1.zhimg.com/v2-c33a809668b5a39a492a88dbb1dd333c_b.png" alt="img"></p><p>进行NAT设置，对网关IP进行设置，前三位同为本机IP前三位</p><h2 id="二、防火墙设置（7版本以上）"><a href="#二、防火墙设置（7版本以上）" class="headerlink" title="二、防火墙设置（7版本以上）"></a>二、防火墙设置（7版本以上）</h2><p>查看防火墙状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p><strong>临时关闭防火墙命令。重启电脑后，防火墙自动起来。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p><strong>永久关闭防火墙命令。重启后，防火墙不会自动启动。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>打开防火墙命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure><h2 id="三、yum源替换（替换为centos的）"><a href="#三、yum源替换（替换为centos的）" class="headerlink" title="三、yum源替换（替换为centos的）"></a>三、yum源替换（替换为centos的）</h2><p><strong>1：查看原有yum包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep yum</span><br></pre></td></tr></table></figure><p><strong>2：卸载原有yum包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep yum|xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure><p><strong>3：ping一下，确定能上网</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>4，创建下载路径,下载centos7.5 yum包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/pkg</span><br></pre></td></tr></table></figure><p><strong>5、找到自己所需的版本下载。</strong></p><p>centos7的yum源码地址：<a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/">http://mirrors.163.com/centos/7/os/x86_64/Packages/</a></p><p>下载以下三个包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-3.4.3-167.el7.centos.noarch.rpm</span><br><span class="line">yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">yum-plugin-fastestmirror-1.1.31-53.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>6、通过文件传输工具上传到/tmp/pkg目录下</strong></p><p><strong>7：为避免依赖问题，一次性安装下载的三个软件包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/pkg</span><br><span class="line">rpm -ivh yum-*</span><br></pre></td></tr></table></figure><p><strong>8，新建.repo配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>下面为该文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#CentOS-Base.repo</span><br><span class="line">#</span><br><span class="line"># The mirror system uses the connecting IP address of the client and the</span><br><span class="line"># update status of each mirror to pick mirrors that are updated to and</span><br><span class="line"># geographically close to the client. You should use this for CentOS updates</span><br><span class="line"># unless you are manually picking other mirrors.</span><br><span class="line">#</span><br><span class="line"># If the mirrorlist= does not work for you, as a fall back you can try the</span><br><span class="line"># remarked out baseurl= line instead.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$7 - Base - 163.com</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=os</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"> </span><br><span class="line">#released updates</span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$7 - Updates - 163.com</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=updates</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"> </span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$7 - Extras - 163.com</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=extras</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"> </span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$7 - Plus - 163.com</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/centosplus/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p><strong>9、清除缓存</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><p><strong>10：并将服务器上的软件包信息缓存到本地,以提高搜索安装软件的速度</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware安装CentOS系统</title>
      <link href="/post/f8239d66.html"/>
      <url>/post/f8239d66.html</url>
      
        <content type="html"><![CDATA[<p>如何去创建一台空白的虚拟机</p><p><strong>注：以下出现的截图可能不是centos的，但是道理相同，不知道怎么选的，采取默认设置就可以了。</strong></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>1、通过键盘Ctrl+N来调出新建虚拟机的窗口。</p><p>2、如果是新安装的Vmware，那么第一次创建虚拟机时，默认选择的是”典型”，由于咱们都是高级人员，所以选择”自定义”安装的方式，可以通过键盘的Alt+C快速选择到”自定义”。</p><p><img src="https://pic4.zhimg.com/v2-d1fc3540e0a521e0880b9557a247e28f_b.png" alt="img"></p><p>3、显示的Workstation 12.0是由于当前的VMware的主版本号为12。保持默认即可。</p><p><img src="https://pic3.zhimg.com/v2-8496d62526418be770c0596da5695fc2_b.png" alt="img"></p><p>4、选择”稍后安装”</p><p><img src="https://pic2.zhimg.com/v2-4a9cf7190df999523cc9cf8d403fbef5_b.png" alt="img"></p><p>5、选择”Linux”、”CentOS 64位”，选择自己镜像文件的系统</p><p><img src="https://pic4.zhimg.com/v2-9494aa869c655b03b97727f7f1525157_b.png" alt="img"></p><p>6、先修改”虚拟机名称”，在修改路径。</p><p><img src="https://pic3.zhimg.com/v2-9e6538a106f99fd0571d0a3e6b5cce6e_b.png" alt="img"></p><p>7、其实单个多个都可以，不会对后续有影响</p><p><img src="https://pic2.zhimg.com/v2-e3c84cabc3538ec99268f689a2544f35_b.png" alt="img"></p><p>8、剩下的，直接下一步到完成。</p><p><img src="https://pic4.zhimg.com/v2-dfe1ab4b0d1cd8801170fb1a09213273_b.png" alt="img"></p><p>安装CentOS系统：</p><p>1、放入CentOS系统的iso镜像文件。</p><p><img src="https://pic4.zhimg.com/v2-706fc1f4ee8229903282ad620536b327_b.png" alt="img"></p><p>2、选择镜像文件。</p><p><img src="https://pic4.zhimg.com/v2-b11e07f354b05a28372e7b143cd6d4b3_b.png" alt="img"></p><p>3、选择第一个进入，等待系统加载</p><p><img src="https://pic3.zhimg.com/v2-2761835f550996b5a7ba0a8ed1bc9b8e_b.png" alt="img"></p><p>4、需要重启物理机，在BIOS中开启CPU虚拟化</p><p><img src="https://pic3.zhimg.com/v2-c2bbde4460b6a48ab3b1161292d67c9e_b.png" alt="img"></p><p>​    如果出现其他的提示，无需理会。</p><p>5、语言英文中文随意，英文好一点的选英文。</p><p><img src="https://pic4.zhimg.com/v2-46d9ed56d6a9664a79e972275c56b637_b.png" alt="img"></p><p>6、时间如果选择中文就不用改默认上海</p><p><img src="https://pic2.zhimg.com/v2-8c4f0c0e1981fd6d42a549ac730227ad_b.png" alt="img"></p><p>7、分区的创建（自定义，使用默认都可以，下面为自定义）</p><p><img src="https://pic1.zhimg.com/v2-f8f418200b3d342b3096bd5376e7e914_b.png" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-c56b915ced571201821b1e52144275d7_b.png" alt="img"></p><p>8、安装什么样的操作系统</p><p><img src="https://pic2.zhimg.com/v2-10eab0ad6507747fa68b0c0c5584bcd5_b.png" alt="img"></p><ul><li>第一个表示要安装一个桌面系统</li><li>第二个表示要安装一个最小化系统</li><li>第三个表示要安装一个最小化系统</li><li>第四个表示要安装一个基本服务系统</li><li>第五个表示要安装一个数据库服务器</li><li>第六个表示要安装web服务器</li><li>第七个表示要安装一个虚拟机主机</li><li>第八个表示安装一个软件开发工作站。</li></ul><p>9、设置root密码</p><p><img src="https://pic2.zhimg.com/v2-27f96c62daae3d664be1fa98bc71beb1_b.png" alt="img"></p><p>10、等待完成后重启</p><p><img src="https://pic2.zhimg.com/v2-27f96c62daae3d664be1fa98bc71beb1_b.png" alt="img"></p><p>对大数据整体学习有兴趣的欢迎看我的文章</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH免密操作</title>
      <link href="/post/96131cab.html"/>
      <url>/post/96131cab.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要配置免密登录"><a href="#为什么要配置免密登录" class="headerlink" title="为什么要配置免密登录"></a>为什么要配置免密登录</h2><p><strong>可以在配置完第一台虚拟机后，直接将文件传输给其余两台虚拟机，提高开发效率</strong></p><h2 id="三步配置"><a href="#三步配置" class="headerlink" title="三步配置"></a>三步配置</h2><p>1、配置主机名</p><p><strong>执行：vim</strong> <strong>/etc/hosts</strong></p><p>编辑主机名</p><p>注意：主机名里不能有下滑线，或者特殊字符 #$，不然会找不到主机导致无法启动</p><p>这种方式更改主机名需要重启才能永久生效，因为主机名属于内核参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.131 hadoop01</span><br><span class="line">192.168.11.132 hadoop02</span><br><span class="line">192.168.11.133 hadoop03</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/v2-fb6e0a5770b1a2249fd07d0f7749436e_b.png" alt="img"></p><p>2、在主机节点（hadoop01）执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>然后三次回车</p><p><img src="https://pic1.zhimg.com/v2-03204f44595ab301b02ebe3f76949100_b.png" alt="img"></p><p>生成节点的公钥和私钥，生成的文件会自动放在/root/.ssh目录下</p><p><img src="https://pic4.zhimg.com/v2-2660e35079fd73816bc628cb12c3129b_b.png" alt="img"></p><p>3、然后把公钥发往3台远程机器1 2 3</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@hadoop01</span><br><span class="line">ssh-copy-id root@hadoop02</span><br><span class="line">ssh-copy-id root@hadoop03</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下MySQL5.7的tar方式安装</title>
      <link href="/post/fe1f88a1.html"/>
      <url>/post/fe1f88a1.html</url>
      
        <content type="html"><![CDATA[<p><strong>适合人群</strong></p><ol><li>刚好不能使用wget和yum命令的</li><li>需要用tar安装的</li><li>root进行操作</li></ol><p><strong>前言</strong></p><blockquote><p>我的Linux安装的是<strong>RedHat7.4</strong>发行版本，其实我还是在推荐刚开始学习Linux的时候装centos，Redhat在使用的过程中会遇到许多问题，让你去注册它的账号才能去使用一些命令，总之是特别麻烦。那么我为什么装RedHat呢？没办法工作需要，MySQL安装方式也可以使用yum源傻瓜式安装，不过我建议初学者还是使用tar包安装方式比较好。方便理解其中的过程。之后遇到什么问题，找起来也会更加容易。我这篇文章安装MySQL全程<strong>不需要yum命令</strong>（当时还没进行换源操作）。</p></blockquote><p><strong>安装前提</strong></p><ol><li>使用root用户操作。 </li><li>关闭防火墙（上传MySQL的tar包）</li><li>修改网络配置（如果不用xShell，finalShell之类的工具可以不配，黑框框也非常不方便，而且实际过程中也不会允许你直接操作虚拟机，所以现在不配，以后也要配）</li></ol><p><strong>安装步骤如下</strong></p><h2 id="1-检查服务器是否已安装MySQL，如已安装则将其卸载"><a href="#1-检查服务器是否已安装MySQL，如已安装则将其卸载" class="headerlink" title="1.检查服务器是否已安装MySQL，如已安装则将其卸载:"></a>1.检查服务器是否已安装MySQL，如已安装则将其卸载:</h2><p>rpm -qa|grep mysql （-q表示使用询问模式，当遇到任何问题时，rpm指令会先询问用户。-a表示查询所有套件。）[新机无mysql]</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">whereis mysql</span><br><span class="line">rm -rf /usr/lib64/mysql/</span><br><span class="line">rm -rf /usr/share/mysql/</span><br><span class="line">find / -name mysql</span><br><span class="line">rm -rf /etc/selinux/targeted/active/modules/100/mysql</span><br><span class="line">rm -rf /var/tmp/dracut.6oP6zK/initramfs/usr/lib64/mysql</span><br></pre></td></tr></table></figure><h2 id="2-检查服务器是否已安装Mariadb，如已安装则将其卸载"><a href="#2-检查服务器是否已安装Mariadb，如已安装则将其卸载" class="headerlink" title="2.检查服务器是否已安装Mariadb，如已安装则将其卸载:"></a>2.检查服务器是否已安装Mariadb，如已安装则将其卸载:</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br><span class="line">rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64</span><br><span class="line">rpm -e --nodeps xxx(文件名) //卸载 （-e表示删除指定的套件）</span><br><span class="line">rm -rf (路径）删除（-r表示迭代，-f表示不询问，强制删除）</span><br></pre></td></tr></table></figure><h2 id="3-上传MySQL包，并解压"><a href="#3-上传MySQL包，并解压" class="headerlink" title="3.上传MySQL包，并解压"></a>3.上传MySQL包，并解压</h2><p>上传可以通过XFtp或者FinalShell之类的软件完成，也可以yum的也可以使用yum -y install lrzsz，就可以直接拖了。我是用的第一种方式。</p><p>MySQL包怎么获得</p><p>（1）wget <a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz%EF%BC%88%E6%B2%A1%E6%9C%89%E6%8D%A2%E6%BA%90%E7%9A%84%E8%AF%9Dwget%E4%B9%9F%E6%98%AF%E4%B8%8D%E8%83%BD%E7%94%A8%E7%9A%84%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%9C%A8%E7%BD%91%E4%B8%8A%E4%B8%8B%E4%B8%AA%E5%90%A7%EF%BC%89">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz（没有换源的话wget也是不能用的，自己在网上下个吧）</a></p><p>（2）链接：<a href="https://pan.baidu.com/s/1hhUYQA6BvCMkhHB6Rt2Vbw">https://pan.baidu.com/s/1hhUYQA6BvCMkhHB6Rt2Vbw</a> 提取码：wsuk</p><p>解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz （-z表示通过gzip指令处理备份文件。</span><br><span class="line">       -v表示显示指令执行过程。</span><br><span class="line">       -x表示从备份文件中还原文件。</span><br><span class="line">                                                       -f表示指定备份文件。）</span><br></pre></td></tr></table></figure><h2 id="4-建议改名"><a href="#4-建议改名" class="headerlink" title="4.建议改名"></a>4.建议改名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql-5.7.22-linux-glibc2.12-x86_64 mysql</span><br></pre></td></tr></table></figure><h2 id="5-移动（不是硬性的，不移动也不影响结果）"><a href="#5-移动（不是硬性的，不移动也不影响结果）" class="headerlink" title="5.移动（不是硬性的，不移动也不影响结果）"></a>5.移动（不是硬性的，不移动也不影响结果）</h2><p>想清楚为什么linux安装程序 都要放到/usr/local目录下：点击下方链接</p><p>为什么linux安装程序 都要放到/usr/local目录下blog.csdn.net<img src="https://pic1.zhimg.com/v2-2a5027b5bff83f50a189c6146b4f7548_ipico.jpg" alt="图标"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><h2 id="6-添加MySQL组和用户"><a href="#6-添加MySQL组和用户" class="headerlink" title="6.添加MySQL组和用户"></a>6.添加MySQL组和用户</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql （-r表示建立系统账号，-g表示指定所属群组）</span><br></pre></td></tr></table></figure><h2 id="7-创建mysql数据目录，回到根目录"><a href="#7-创建mysql数据目录，回到根目录" class="headerlink" title="7.创建mysql数据目录，回到根目录"></a>7.创建mysql数据目录，回到根目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">mkdir -p data （-p表示如果没有才创建）</span><br><span class="line"><span class="built_in">cd</span> data/</span><br><span class="line">mkdir -p mysql </span><br></pre></td></tr></table></figure><h2 id="8-授权"><a href="#8-授权" class="headerlink" title="8.授权"></a>8.授权</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown mysql:mysql -R /data/mysql</span><br></pre></td></tr></table></figure><h2 id="9-修改配置文件"><a href="#9-修改配置文件" class="headerlink" title="9.修改配置文件"></a>9.修改配置文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p>删除原来内容粘贴以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">port=3306</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">log-error=/data/mysql/mysql.err</span><br><span class="line">pid-file=/data/mysql/mysql.pid</span><br><span class="line">#character config</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line">symbolic-links=0</span><br></pre></td></tr></table></figure><p>完成之后按esc键+：wq退出</p><h2 id="10-初始化MySQL"><a href="#10-初始化MySQL" class="headerlink" title="10.初始化MySQL"></a>10.初始化MySQL</h2><p>进入mysql的bin目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin/</span><br></pre></td></tr></table></figure><p>进行初始化（完了没提示属于正常现象）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld --defaults-file=/etc/my.cnf --basedir=/usr/<span class="built_in">local</span>/mysql/ --datadir=/data/mysql/ --user=mysql --initialize</span><br></pre></td></tr></table></figure><p>查看初始化密码（记得保存密码）<strong>MySQL5.7之后默认密码不再是空</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /data/mysql/mysql.err</span><br></pre></td></tr></table></figure><h2 id="11-启动MySQL服务"><a href="#11-启动MySQL服务" class="headerlink" title="11.启动MySQL服务"></a>11.启动MySQL服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><p>登录MySQL</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p><strong>建议更改密码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD = PASSWORD(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NEVER;（保证密码永不过期）</span><br><span class="line">flush privileges;（MySQL用户数据和权限有修改后，希望在<span class="string">&quot;不重启MySQL服务&quot;</span>的情况下直接生效，那么就需要执行这个命令。）</span><br></pre></td></tr></table></figure><p>如果报错信息如下</p><p><strong>A.service mysql启动失败 提示unit not found 解决办法</strong></p><p>查看是否有mysql服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/init.d/ | grep mysql</span><br></pre></td></tr></table></figure><p>如果上面没有继续执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name mysql.server</span><br></pre></td></tr></table></figure><p>将找到的路径复制到 /etc/init.d/mysql路径中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server  /etc/init.d/mysql</span><br></pre></td></tr></table></figure><p>然后重启mysql服务</p><p><strong>B.mysql command not found</strong></p><ol><li>增加软连接：ln -s /usr/local/mysql/bin/mysql /usr/bin</li><li>找到mysql/bin的位置，正常情况下是 /usr/local/mysql/bin在最后添加：export PATH=$PATH:/usr/local/mysql/bin 保存退出。</li></ol><p> 使修改生效：source /etc/profile</p><h2 id="12-额外—MySQL开机自启"><a href="#12-额外—MySQL开机自启" class="headerlink" title="12.额外—MySQL开机自启"></a>12.额外—MySQL开机自启</h2><p>如果不想每次开机都去启动MySQL服务，那么就设置吧</p><ol><li>cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql 将服务文件拷贝到init.d下，并重命名为mysql</li><li>确保 /etc/init.d/ 目录下有mysql.server</li><li><strong>赋予可执行权限 chmod +x /etc/init.d/mysql</strong> </li><li><strong>添加服务 chkconfig –add mysql</strong> </li><li><strong>显示服务列表 chkconfig –list 如果看到mysql的服务，并且3,4,5都是on的话则成功如果是off，则键入chkconfig –level 345 mysql on</strong></li><li>reboot重启电脑</li><li>netstat -na | grep 3306，如果看到有监听说明服务启动了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Linux </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS全分布式安装</title>
      <link href="/post/34e57ffd.html"/>
      <url>/post/34e57ffd.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ol><li>关闭防火墙</li><li>修改主机名</li><li>配置/etc/hosts文件</li><li>配置免密登录</li><li>安装JDK</li><li>安装zookeeper（集群式安装）</li><li>解压Hadoop</li><li>selinux关闭掉，这是linux系统的一个安全机制，进入文件中将SELINUX设置为disabled</li></ol><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>1：进入hadoop安装子目录etc/hadoop/下</p><p>2：修改hadoop-env.sh文件。source hadoop-env.sh使其生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/home/ldl/software/hadoop-2.7.1/etc/hadoop</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/v2-0df9e4ebba59b98ea72225963d347e0e_b.png" alt="img"></p><p><strong>3：配置core-site.xml；hdfs-site.xml；mapred-site.xml；yarn-site.xml四个xml文件</strong></p><p>core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定hdfs的nameservice，，为整个集群起一个--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定Hadoop数据临时存放目录--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/ldl/software/hadoop-2.7.1/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定zookeeper的存放地址--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:2181,hadoop02:2181,hadoop03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>hdfs-site.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--执行hdfs的nameservice为ns，注意要和core-site.xml中的名称保持一致--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--ns集群下有两个namenode，分别为nn1, nn2--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--nn1的RPC通信--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--nn1的http通信--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--指定namenode的元数据在JournalNode上存放的位置，这样，namenode2可以从journalnode集群里的指定位置上获取信息，达到热备效果--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://hadoop01:8485;hadoop02:8485;hadoop03:8485/ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/ldl/software/hadoop-2.7.1/tmp/journal<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 开启NameNode故障时自动切换 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置失败自动切换实现方式 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置隔离机制 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>sshfence<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用隔离机制时需要ssh免登陆 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置namenode存放元数据的目录，可以不配置，如果不配置则默认放到hadoop.tmp.dir下--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/ldl/software/hadoop-2.7.1/tmp/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置datanode存放元数据的目录，可以不配置，如果不配置则默认放到hadoop.tmp.dir下--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/ldl/software/hadoop-2.7.1/tmp/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置复本数量--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置用户的操作权限，false表示关闭权限验证，任何用户都可以操作--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>mapred-site.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>yarn-site.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置yarn的高可用--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定两个resourcemaneger的名称--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1,rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置rm1的主机--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置rm2的主机--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--开启yarn恢复机制--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.recovery.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--执行rm恢复机制实现类--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.store.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置zookeeper的地址--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:2181,hadoop02:2181,hadoop03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--执行yarn集群的别名--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns-yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 指定nodemanager启动时加载server的方式为shuffle server --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 指定resourcemanager地址 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>7：编辑slaves(可以决定哪些服务器是数据节点也就是DataNode)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br></pre></td></tr></table></figure><p><strong>8：拷贝到其他节点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/ldl/software/hadoop-2.7.1/ hadoop02:/home/ldl/software/</span><br><span class="line">scp -r /home/ldl/software/hadoop-2.7.1/ hadoop03:/home/ldl/software/</span><br></pre></td></tr></table></figure><p><strong>9：配置环境变量</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p><strong>10：三台虚拟机启动zookeeper</strong></p><p>输入./zkServer.sh status查询状态显示“follower”或者“leader”正常</p><p><img src="https://pic1.zhimg.com/v2-097aae00b3d97917c0e14089f2a9e8fc_b.png" alt="img"></p><p><strong>11：三台虚拟机启动JournalNode</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure><p><strong>JournalNode的作用</strong>：使三台虚拟进行相互通信，如果没有该进程那么将不能进行namenode格式化</p><p><strong>12：在第一台节点上（主机上）格式化NameNode</strong>：hdfs namenode -format/hadoop namenode -format</p><p><strong>说明</strong></p><blockquote><p>hadoop namenode -format跟hdfs namenode -format是一个东西，<strong>作用完全相同</strong>。 在hadoop1.x的时候，只有hadoop namenode -format一种方式，到了hadoop2.x之后，引入了新的hdfs namenode -format，作用完全相同，为了兼容老版本，原来的命令仍然可以使用。</p></blockquote><p><strong>13：启动HDFS</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh/start-all.sh</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>start-all.sh包括start-dfs.sh和start-yarn.sh</p><p><img src="https://pic3.zhimg.com/v2-6761436398e28acf38d27cbacd8ac7be_b.png" alt="img"></p><p>启动之后如果要<strong>设置主备</strong>，格式化备用机的NameNode：hdfs namenode -bootstrapStandby</p><p>然后在启动备用机的NameNode：hadoop-daemon.sh start namenode（基于前一个命令）</p><p>启动RM的命令： yarn-daemon.sh start resourcemanager</p><p><strong>14、测试是否成功</strong></p><p>访问路径：<a href="http://ip:50070/">http://ip:50070/</a></p><p>出现页面：主机为alive状态，其他两台为standby状态则为成功</p><p><img src="https://pic3.zhimg.com/v2-a44e884db5f3a3a6a735c98170dc51d6_b.png" alt="img"></p><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p><img src="https://pic3.zhimg.com/v2-d474e390749739de1c1608a654e2ee06_b.png" alt="img"></p><blockquote><p>原因： 从日志上看是因为 datanode的clusterID 和 namenode的clusterID 不匹配  根本原因： 其实，是因为第一次格式化namenode后，启动了hadoop集群，生成了clusterID=CID-96ed3103-6cea-49ef-9c3a-b2c056de269c（这是第一次格式化后生成的clusterID）。后来又因某种原因，重新格式化了namenode，又重新生成了另一个新的clusterID=CID-2b6d3a1f-659d-4029-887d-1a20b9a2ecc4。导致，后来重新启动hadoop集群的时候，其他节点还是用第一次生成的clusterID，导致，找不到新的集群的clusterID，报了一个找不到指定目录的异常。 3、根据配置的路径，找到其他的datanode节点下的VERSION文件 例如，我的VERSION文件在以下的目录中： /opt/module/hadoop-2.7.2/data/tmp/dfs/data/current 下 然后将其他datanode节点中的clusterID都修改为最后一次格式化后生成的clusterID</p></blockquote><p><img src="https://pic4.zhimg.com/v2-37a7f6b47c0b9bc884674bcafcd65b27_b.png" alt="img"></p><blockquote><p>解决方案：检查网络状态，重启hadoop 实在解决不掉的问题就重新格式化namenode 。如果想重新格式化，那么需要先删除每台机器上的${hadoop.tmp.dir}指定路径下的所有内容，然后再格式化：最好也把logs目录下的内容也清空，因为日志内容已经是前一个废弃集群的日志信息了，留着也无用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase集群安装</title>
      <link href="/post/fe57b0e4.html"/>
      <url>/post/fe57b0e4.html</url>
      
        <content type="html"><![CDATA[<p><strong>安装前准备：zookeeper+JDK+Hadoop</strong></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p><strong>1：上传并解压</strong></p><p><strong>2：修改conf/hbase.env.sh</strong></p><p>增加JAVA_HOME：export JAVA_HOME=/usr/local/jdk1.8</p><p>增加Zookeeper和Hbase的协调模式，hbase默认使用自带的zookeeper，如果需要使用外部zookeeper，需要先关闭：export HBASE_MANAGES_ZK=false</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8</span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>3：配置hbase-site.xml，配置开启完全分布式模式</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:2181,hadoop02:2181,hadoop03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-4ec2c7ae7564964cedb86111cec9a0b3_b.png" alt="img"></p><blockquote><p>hbase.rootdir: 这个参数是用来设置RegionServer 的共享目录，用来存放HBase数据。特别需要注意的是里面的 HDFS 地址是要跟 Hadoop 的 core-site.xml 里面的 fs.defaultFS 的 HDFS 的 IP 地址或者域名、端口<strong>必须一致。</strong></p></blockquote><p>4：<strong>配置region服务器</strong></p><p>修改conf/regionservers文件,每个主机名独占一行，hbase启动或关闭时会按照该配置顺序启动或关闭主机中的hbase:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-fa462c8aa0fbaa6cbcf1d7a41c3e00b0_b.png" alt="img"></p><p><strong>5：远程复制拷贝到其他节点上</strong></p><p><strong>6：启动Zookeeper服务，进入bin</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure><p><strong>7：启动Hadoop</strong> </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p><strong>8：启动Hbase（别用start-hbase启动）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase-daemon.sh start thrift</span><br><span class="line">hbase-daemon.sh start master</span><br><span class="line">hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure><p><strong>9：查看各节点的java进程是否正确，或者通过浏览器访问<a href="http://xxxxx:60010来访问web界面，通过web界面管理hbase">http://xxxxx:60010来访问web界面，通过web界面管理hbase</a></strong></p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><p><strong>1：集群时间同步</strong></p><p>查看本机是否安装了ntpdate服务，安装时间同步软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntpdate</span><br><span class="line">yum install -y ntp</span><br></pre></td></tr></table></figure><p>同步时间</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate time.nist.gov</span><br></pre></td></tr></table></figure><p><strong>2：启动要依次启动不能使用start.hbase.sh</strong></p><p>附加Hbase启停命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase-daemon.sh start thrift</span><br><span class="line">hbase-daemon.sh start master</span><br><span class="line">hbase-daemon.sh start regionserver</span><br><span class="line">hbase-daemon.sh stop thrift</span><br><span class="line">hbase-daemon.sh stop master</span><br><span class="line">hbase-daemon.sh stop regionserver</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive安装部署</title>
      <link href="/post/5bf55f4.html"/>
      <url>/post/5bf55f4.html</url>
      
        <content type="html"><![CDATA[<p>跟我一路装下来的，基本的我就省略了，装Hive不难，直入主题</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p><strong>1：启动zookeeper</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><p><strong>2：启动Hadoop（包括hdfs和yarn）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p><strong>3：解压hive安装包</strong></p><p><strong>4：改名（非必须）</strong></p><p><strong>5：配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile </span><br><span class="line">在文件末端加</span><br><span class="line">export HIVE_HOME=/home/ldl/software/hive-1.2.1</span><br><span class="line">export PATH=$PATH:$HIVE_HOME/bin</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/v2-e3eecfda3a3a838a85844e38be472c3e_b.png" alt="img"></p><p><strong>6：启动hive</strong></p><p>hive</p><p><img src="https://pic4.zhimg.com/v2-b39c2f36ee5620f096fd8f1c0d9f29f3_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZK完全分布式安装</title>
      <link href="/post/5ac88c70.html"/>
      <url>/post/5ac88c70.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p><strong>关闭防火墙，配置ssh免密登录</strong></p><p><a href="https://zookeeper.apache.org/releases.html">Apache ZooKeeper</a></p><p>可以通过官网下载，自己有也可以。我用的是3.4.7</p><p><strong>1:上传zookeeper安装包</strong></p><p><strong>2:解压zookeeper安装包</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf zookeeper-3.4.7.tar.gz </span><br></pre></td></tr></table></figure><p><strong>3:建议改名</strong></p><p><strong>4:进入conf目录</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.7/conf/</span><br></pre></td></tr></table></figure><p><strong>5:将zoo_sample.cfg复制一份zoo.cfg</strong></p><p>因为Zookeeper在启动的时候会<strong>自动寻找zoo.cfg</strong>，根据其中的配置来启动存储数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p><strong>6:更改zoo.cfg 的配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi zoo.cfg </span><br></pre></td></tr></table></figure><p>在文件末端按如下配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/ldl/software/zookeeper-3.4.7/data</span><br><span class="line">dataLogDir=/home/ldl/software/zookeeper-3.4.7/<span class="built_in">log</span></span><br><span class="line">server.1=192.168.11.131:2888:3888</span><br><span class="line">server.2=192.168.11.132:2888:3888</span><br><span class="line">server.3=192.168.11.133:2888:3888</span><br></pre></td></tr></table></figure><p>最后关闭保存:wq!</p><p><img src="https://pic3.zhimg.com/v2-25c48067b2ea37220b93ba5c49c8f896_b.png" alt="img"></p><p>1:编号要求是<strong>数字</strong>并且<strong>不能重复</strong></p><p>2:原子广播端口号和选举端口号只要<strong>不和当前已经使用的端口号冲突</strong>即可</p><p><strong>7:创建目录data，log</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p data</span><br><span class="line">mkdir -p <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><strong>8:创建myid文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /home/ldl/software/zookeeper-3.4.7/data/myid </span><br></pre></td></tr></table></figure><p><strong>9:将zookeeper-3.4.7传到其余两台虚拟机中</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/ldl/software/zookeeper-3.4.7 hadoop02:/home/ldl/software/</span><br><span class="line">scp -r /home/ldl/software/zookeeper-3.4.7 hadoop03:/home/ldl/software/</span><br></pre></td></tr></table></figure><p><strong>10:更改其余两台虚拟机的myid</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /home/ldl/software/zookeeper-3.4.7/data/myid </span><br></pre></td></tr></table></figure><p><strong>11:进入目录，启动服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ldl/software/zookeeper-3.4.7/bin/</span><br><span class="line">./zkServer.sh start</span><br><span class="line">./zkServer.sh start-foreground 附带信息（可以看报错信息）</span><br></pre></td></tr></table></figure><p>可能出现的问题及解决方案</p><p><img src="https://pic1.zhimg.com/v2-0654447011aed72fcbca8d21d1918924_b.png" alt="img"></p><p>解决方案：找到myid所在的目录，删除version-2文件夹，在重新启动zookeeper</p><p>如果遇到的问题这不对那不对的，找了很多方法都解决不了，那叫换个版本的安装包吧，或者评论私我问我要。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark的安装</title>
      <link href="/post/fb77661f.html"/>
      <url>/post/fb77661f.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ol><li>启动zookeeper集群</li><li>启动Hadoop集群</li><li>上传并解压spark2.2.0（版本2以上使用jdk1.8以上）</li><li>在spark创建logs文件夹，pids文件夹</li><li>在hdfs上创建目录hadoop fs -mkdir -p hdfs://ns/spark/eventlog</li></ol><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>1.配置环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/home/ldl/software/spark-2.2.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br><span class="line">使其生效<span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>2.修改spark.env.sh配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8</span><br><span class="line"><span class="comment">#export SCALA_HOME=/e3base/scala</span></span><br><span class="line"><span class="comment">#export SCALA_LIBRARY_PATH=$&#123;SPARK_LIBRARY_PATH&#125;</span></span><br><span class="line"><span class="comment">#export IN_HOME=/e3base</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/ldl/software/hadoop-2.7.1</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/home/ldl/software/hadoop-2.7.1/etc/hadoop/</span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/home/ldl/software/hive-1.2.1</span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/home/ldl/software/spark-2.2.0</span><br><span class="line"><span class="built_in">export</span> SPARK_CONF_DIR=/home/ldl/software/spark-2.2.0/conf</span><br><span class="line"><span class="built_in">export</span> SPARK_LIBRARY_PATH=/home/ldl/software/spark-2.2.0/lib</span><br><span class="line"><span class="comment">#export SPARK_WORKER_DIR=/home/hadoop/work/spark</span></span><br><span class="line"><span class="built_in">export</span> SPARK_LOG_DIR=/home/ldl/software/spark-2.2.0/logs</span><br><span class="line"><span class="built_in">export</span> SPARK_PID_DIR=/home/ldl/software/spark-2.2.0/pids</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=17001</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_WEBUI_PORT=17002</span><br><span class="line"><span class="built_in">export</span> SPARK_DAEMON_JAVA_OPTS=<span class="string">&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=hadoop01:2181,hadoop02:2181,hadoop03:2181 -Dspark.deploy.zookeeper.dir=/spark&quot;</span></span><br><span class="line"><span class="comment">#export SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=17003 -Dspark.history.retainedApplications=100 -Dspark.history.fs.logDirectory=hdfs://ns/spark/eventlog&quot;</span></span><br></pre></td></tr></table></figure><p>3.修改spark-defaults.conf配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spark.master spark://hadoop01:2181</span><br><span class="line">spark.eventLog.enabled <span class="literal">true</span></span><br><span class="line">spark.eventLog.dir hdfs://ns/spark/eventlog</span><br><span class="line">spark.local.dir /home/ldl/software/spark-2.2.0/tmp</span><br><span class="line">spark.sql.shuffle.partitions 250</span><br><span class="line">spark.default.parallelism 10</span><br><span class="line">spark.driver.memory 1g</span><br><span class="line">spark.executor.memory 1g</span><br><span class="line">spark.ui.port 17004</span><br><span class="line">spark.yarn.historyServer.address http://172.21.3.67:17003</span><br><span class="line">spark.history.ui.port 17003</span><br></pre></td></tr></table></figure><p>4.修改slave配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br></pre></td></tr></table></figure><p>5.拷贝hive.site.xml</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/ldl/software/hive-1.2.1/conf/hive-site.xml /home/ldl/software/spark-2.2.0/conf/</span><br></pre></td></tr></table></figure><p>6.将sprk文件夹拷贝到三台节点上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/ldl/software/spark-2.2.0/ hadoop02:/home/ldl/software/</span><br><span class="line">scp -r /home/ldl/software/spark-2.2.0/ hadoop02:/home/ldl/software/</span><br></pre></td></tr></table></figure><p>7.spark启动</p><p>到spark/sbin目录下启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-20872ed580df154a77047a68c8f36ed3_b.png" alt="img"></p><p>停止</p><p><a href="http://stop-all.sh/">stop-all.sh</a></p><p><img src="https://pic3.zhimg.com/v2-8050116877e5f5604fe3292f81ee7a4a_b.png" alt="img"></p><p>单独命令（进入目录下执行+./）</p><p><strong>启停master进程</strong></p><p>start-master.sh</p><p>stop-master.sh</p><p><strong>启停worker进程</strong></p><p>start-slave.sh </p><p>stop-slave.sh</p><p><strong>启停spark jobhistory服务</strong></p><p>start-history-server.sh</p><p>stop-history-server.sh</p><p><strong>启停spark thriftserver服务</strong></p><p>start-thriftserver.sh</p><p>stop-thriftserver.sh</p><p>master进程截图</p><p><img src="https://pic3.zhimg.com/v2-e52cf986d7904a2ec397ca8c140d85ae_b.png" alt="img"></p><p>成功截图</p><p><img src="https://pic2.zhimg.com/v2-29db1949630490b8df66508569fc7839_b.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计规范</title>
      <link href="/post/bd69ba8b.html"/>
      <url>/post/bd69ba8b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该MySQL规范于网上搜集，包括一些阿里和业界的一些规范，并对一些规范稍作说明，仅用作学习和查阅使用<br>以下所有规范会按照<span class='p red'>【强制】</span>、<span class='p green'>【建议】</span>两个级别进行标注，遵守优先级从高到低</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><span class='p red'>【强制】</span>库的名称格式：库的名称必须控制在32个字符以内，业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀</li><li><span class='p red'>【强制】</span>创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4</li><li><span class='p red'>【强制】</span>所有数据库对象名称必须使用小写字母并用下划线分割</li></ol><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><ol><li><span class='p red'>【强制】</span>表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写</li><li><span class='p red'>【强制】</span>表名要求模块名强相关，需见名知意，命名需要与业务、产品线等相关联，如师资系统采用”sz”作为前缀，渠道系统采用”qd”作为前缀等</li><li><span class='p red'>【强制】</span>表名不使用复数名词</li><li><span class='p red'>【强制】</span>小数类型为 decimal，禁止使用 float 和 double</li><li><span class='p red'>【强制】</span>对于超过100W行的大表进行alter table，必须慎重，并在业务低峰期执行<br/><code>说明</code>alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响</li><li><span class='p red'>【强制】</span>表必备三字段：id, create_time, update_time<br/><code>说明</code>其中 id 必为主键，类型为bigint unsigned、单表时自增、步长为1 create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li><li><span class='p red'>【强制】</span>创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB<br/><code>说明</code>Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎而这是其他大多数存储引擎不具备的</li><li><span class='p red'>【强制】</span>建表必须有comment</li><li><span class='p green'>【建议】</span>主键为id，类型为int或bigint，且为auto_increment<br/><code>说明</code>如果不设置主键或主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降，在不适用分布式系统的时候使用主键自增，性能最优，单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表</li><li><span class='p green'>【建议】</span>表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值<br/><code>说明</code>使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题</li><li><span class='p green'>【建议】</span>建议对表里的blob、text等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select</li><li><span class='p green'>【建议】</span>中间表用于保留中间结果集，名称必须以tmp_开头备份表用于备份或抓取源表快照，名称必须以bak_开头中间表和备份表定期清理</li><li><span class='p green'>【建议】</span>反范式设计：把经常需要join查询的字段，在其他表里冗余一份<br/><code>说明</code>在保证数据一致性的前提下，减少关联查询，提高性能，冗余字段应遵循<br>1） 不是频繁修改的字段<br>2） 不是唯一索引的字段<br>3） 不是 varchar 超长字段，更不能是 text 字段</li></ol><h2 id="列结构"><a href="#列结构" class="headerlink" title="列结构"></a>列结构</h2><ol><li><span class='p green'>【建议】</span>表中的自增列（auto_increment属性），推荐使用bigint类型<br/><code>说明</code>无符号int存储范围为-2147483648~2147483647（大约21亿左右），溢出后会导致报错</li><li><span class='p green'>【建议】</span>业务中选择性很少的状态status、类型type等字段推荐使用tinytint或者smallint类型节省存储空间</li><li><span class='p green'>【建议】</span>业务中IP地址字段推荐使用int类型，不推荐用char(15)<br/><code>说明</code>int只占4字节，可以用如下函数相互转换，而char(15)占用至少15字节一旦表数据行数到了1亿，那么要多用1.1G存储空间</li><li><span class='p green'>【建议】</span>不推荐使用enum，set<br/><code>说明</code>浪费空间，且枚举值写死了，变更不方便推荐使用tinyint或smallint</li><li><span class='p green'>【建议】</span>不推荐使用blob，text等类型<br/><code>说明</code>它们都比较浪费硬盘和内存空间在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能Innodb中当一行记录超过8098字节时，会将该记录中选取最长的一个字段将其768字节放在原始page里，该字段余下内容放在overflow-page里不幸的是在compact行格式下，原始page和overflow-page都会加载</li><li><span class='p green'>【建议】</span>文本数据尽量用varchar存储varchar是变长存储，比char更省空间<br/><code>说明</code>MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为mediumtext字段而text在utf8字符集下最多存21844个字符，mediumtext最多存2^24/3个字符，longtext最多存2^32个字符一般建议用varchar类型，字符数不要超过2700</li><li><span class='p green'>【建议】</span>根据业务来决定时间类型选取timestamp还是datetime<br/><code>说明</code>datetime占用8字节，timestamp仅占用4字节，但是范围为1970-01-01 00:00:01到2038-01-01 00:00:00存储目前时区的时间，而datetime存储的时间的绝对值，在哪里都一样</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li><span class='p red'>【强制】</span>InnoDB表必须主键为id int/bigint auto_increment,且主键值禁止被更新</li><li><span class='p red'>【强制】</span>InnoDB和MyISAM存储引擎表，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引</li><li><span class='p red'>【强制】</span>单个索引中每个索引记录的长度不能超过64KB</li><li><span class='p red'>【强制】</span>超过三个表禁止 join 需要 join 的字段，数据类型保持绝对一致 ； 多表关联查询时，保证被关联的字段需要有索引</li><li><span class='p green'>【建议】</span>主键的名称以“pk_”开头，唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀</li><li><span class='p green'>【建议】</span>单个表上的索引个数不能超过7个</li><li><span class='p green'>【建议】</span>在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面如列userid的区分度可由select count(distinct userid)计算出来</li><li><span class='p green'>【建议】</span>在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高</li><li><span class='p green'>【建议】</span>建表或加索引时，保证表里互相不存在冗余索引对于MySQL来说，如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除</li><li><span class='p blue'>【参考】</span>创建索引时避免有如下极端误解<br/>1） 索引宁滥勿缺认为一个查询就需要建一个索引<br>2） 吝啬索引的创建认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度<br>3） 抵制惟一索引认为惟一索引一律需要在应用层通过“先查后插”方式解决</li></ol><h2 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h2><ol><li><span class='p red'>【强制】</span>SELECT语句必须指定具体字段名称，禁止写成*<br/><code>说明</code>select *会将不该读的数据也从MySQL里读出来，造成网卡压力且表字段一旦更新，但model层没有来得及更新的话，系统会报错</li><li><span class='p red'>【强制】</span>insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上</li><li><span class='p red'>【强制】</span>事务涉及的表必须全部是innodb表否则一旦失败不会全部回滚，且易造成主从库同步终端</li><li><span class='p red'>【强制】</span>不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关<br/><code>说明</code>count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行</li><li><span class='p red'>【强制】</span>不得使用外键与级联，一切外键概念必须在应用层解决<br/><code>说明</code>假设学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</li><li> <span class='p red'>【强制】</span>除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找</li><li><span class='p red'>【强制】</span>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性<br/><code>说明</code>存储过程还是以实际业务为主，比较稳定的可以保留，最大优点就在于效率高</li><li><span class='p red'>【强制】</span>生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等<br/><code>说明</code>hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信MySQL优化器！</li><li><span class='p red'>【强制】</span>where条件里等号左右字段类型必须一致，否则无法利用索引</li><li> <span class='p red'>【强制】</span>生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描查询数据量不要超过表行数的25%，否则不会利用索引</li><li> <span class='p red'>【强制】</span>WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引</li><li><span class='p green'>【建议】</span>索引列不要使用函数或表达式，否则无法利用索引如where length(name)='Admin'或where user_id+2=10023</li><li><span class='p green'>【建议】</span>减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引<br/><code>说明</code>如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)</li><li><span class='p green'>【建议】</span>分页查询，当limit起点较高时，可先用过滤条件进行过滤如select a,b,c from t1 limit 10000,20;优化为:select a,b,c from t1 where id>10000 limit 20;</li><li><span class='p green'>【建议】</span>insert into…values(XX),(XX),(XX)…这里XX的值不要超过5000个<br/><code>说明</code>值过多虽然上线很很快，但会引起主从同步延迟</li><li><span class='p green'>【建议】</span>SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内union all不需要去重，节省数据库资源，提高性能</li><li><span class='p green'>【建议】</span>in值列表限制在500以内例如select… where userid in(….500个以内…)<br/><code>说明</code>这么做是为了减少底层扫描，减轻数据库压力从而加速查询</li></ol><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><ol><li><span class='p red'>【强制】</span>禁止跨db的join语句<br/><code>说明</code>可以减少模块间耦合，为数据库拆分奠定坚实基础</li><li><span class='p red'>【强制】</span>禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…</li><li><span class='p green'>【建议】</span>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询</li><li><span class='p green'>【建议】</span>线上环境，多表join不要超过3个表<br/><code>说明</code>超过三个表的可以对表中字段进行适当冗余</li><li><span class='p green'>【建议】</span>多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如select a from db1.table1 alias1 where …</li><li><span class='p green'>【建议】</span>在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol><li><span class='p red'>【强制】</span>程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读线上建议事务隔离级别为repeatable-read</li><li><span class='p green'>【建议】</span>事务中INSERT|UPDATE|DELETE|REPLACE语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内</li><li><span class='p green'>【建议】</span>事务里包含SQL不超过5个（支付业务除外）过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题</li><li><span class='p green'>【建议】</span>事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁</li><li><span class='p green'>【建议】</span>尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长</li><li><span class='p green'>【建议】</span>对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库</li><li><span class='p green'>【建议】</span>批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值5-10秒</li><li><span class='p green'>【建议】</span>对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内</li></ol><h2 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h2><ol><li><span class='p green'>【建议】</span>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做<br/><code>说明</code>order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的</li><li><span class='p green'>【建议】</span>order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据<br/><code>说明</code>如where a=1 order by可以利用key(a,b)</li><li><span class='p green'>【建议】</span>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢</li></ol><h2 id="线上禁止使用的SQL语句"><a href="#线上禁止使用的SQL语句" class="headerlink" title="线上禁止使用的SQL语句"></a>线上禁止使用的SQL语句</h2><ol><li><span class='p red'>【高危】</span>禁用update|delete t1 … where a=XX limit XX; <br/><code>说明</code>这种带limit的更新语句会导致主从不一致，导致数据错乱建议加上order by PK</li><li><span class='p red'>【高危】</span>禁止使用关联子查询，如update t1 set … where name in(select name from user where…)，效率极其低下</li><li><span class='p red'>【强制】</span>禁用procedure、function、trigger、views、event、外键约束<br/><code>说明</code>消耗数据库资源，降低数据库实例可扩展性推荐都在程序端实现</li><li><span class='p red'>【强制】</span>禁用insert into …on duplicate key update…<br/><code>说明</code>在高并发环境下，会造成主从不一致</li><li><span class='p red'>【强制】</span>禁止联表更新语句，如update t1,t2 where t1.id=t2.id…</li></ol><h2 id="【进阶】分库分表、分区表"><a href="#【进阶】分库分表、分区表" class="headerlink" title="【进阶】分库分表、分区表"></a>【进阶】分库分表、分区表</h2><ol><li><span class='p red'>【强制】</span>分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列</li><li><span class='p red'>【强制】</span>单个分区表中的分区（包括子分区）个数不能超过1024</li><li><span class='p red'>【强制】</span>上线前RD或者DBA必须指定分区表的创建、清理策略</li><li><span class='p red'>【强制】</span>访问分区表的SQL必须包含分区键</li><li><span class='p red'>【强制】</span>对于分区表执行alter table操作，必须在业务低峰期执行</li><li><span class='p red'>【强制】</span>采用分库策略的，库的数量不能超过1024</li><li><span class='p red'>【强制】</span>采用分表策略的，表的数量不能超过4096</li><li><span class='p green'>【建议】</span>单个分表不超过500W行，ibd文件大小不超过2G，这样才能让数据分布式变得性能更佳</li><li> <span class='p green'>【建议】</span>水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表</li><li><span class='p green'>【建议】</span>单个分区文件不超过2G，总大小不超过50G建议总分区数不超过20个</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习感想</title>
      <link href="/post/3d24dcf9.html"/>
      <url>/post/3d24dcf9.html</url>
      
        <content type="html"><![CDATA[<h2 id="罗嗦两句"><a href="#罗嗦两句" class="headerlink" title="罗嗦两句"></a>罗嗦两句</h2><p>我是个干Java的，公司安排进行大数据培训（其实跟自学也差不多）其实我也挺感谢这次机会，一个程序员不应该被语言所束缚。</p><p>来之前，我也曾经自学过一些关于大数据的知识，当时是为了面试，问的时候不至于一脸懵，最后也做了一个项目出来，是一个监控网站pv,uv等数值的一个程序。但这个项目急于求成，基础不牢，其实也没有学到什么。所以<strong>学习不能讲究快，它是一种积累</strong>。我们应当知其然，更知其所以然。</p><p>我的Java可是实打实学了两年（从大学开始算），也只是达到了找工作的水平。这次给两个月的时间，说实话，只想着可以入门就可以了。于是怎么去学，如何利用好两个月的时间成了我一个最大的苦恼，我也曾经问过我的导师，也曾网上找过资料，收益甚微。除了理论还有自己动手实操，记笔记，知识复盘等等，俩月真的学不了太多。<strong>所以如何在有限的时间让我的学习收益达到最大。</strong>这才是我需要做的事情。其实两个月下来，我学到的<strong>不仅仅是知识</strong>，还有比技术更重要的。附个图，两个月来的笔记。</p><p><img src="https://pic3.zhimg.com/v2-155ecbf52523c885e1a80f8276badea2_b.png" alt="img"></p><h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>学习按照导师给的大纲来的，也是由浅入深，由必修到选修。最大的感受就是越学越不明白，从Oozie开始，知道他是做什么的，但是没有一个合适的环境去使用它，看在多的理论也是白看，越学越没劲。我比较看重实操，<strong>光学理论，结合不了实操，我索性就不学了</strong>，那只会浪费我的时间。自学大多都是看B站学习的，这个不用我多介绍了，俩字就是良心。希望到后面能够将所学知识窜起来，做一个项目，但最后发现，做一个大数据项目所需的知识体系真的是太多了，俩月不够用，大学荒废了两年，现在才知道时间是多么重要。没时间学，也没时间做项目，所以大学狗们珍惜这4年吧。不过<strong>任何时候学习都不算晚</strong>，动起来的时候就成功99%了。</p><h2 id="俩月的学习感触"><a href="#俩月的学习感触" class="headerlink" title="俩月的学习感触"></a>俩月的学习感触</h2><h3 id="尽量看官方文档"><a href="#尽量看官方文档" class="headerlink" title="尽量看官方文档"></a>尽量看官方文档</h3><p>许多视频中也有老师提及，他们讲的其实也是从官方文档中提炼出来的，官方文档看不懂也不怕，我英语也很烂，看就完事儿了，尝试的看英文，不行就右键翻译或者装个翻译扩展程序，跟视频的好处是人家会带着你走，让你少踩坑。</p><h3 id="版本按最新的走"><a href="#版本按最新的走" class="headerlink" title="版本按最新的走"></a>版本按最新的走</h3><p>公司才会考虑稳定。<strong>学习研究最新的</strong>总没错，技术更新迭代非常快，比如说学习centos，视频大多都是教的6版本的，你一股脑的学完了，现在都出到8了（截止2020-7-11之前）最后你还得在学8。干IT不要走老路，反正都是学，为什么不学新的。</p><h3 id="清楚自己的定位"><a href="#清楚自己的定位" class="headerlink" title="清楚自己的定位"></a>清楚自己的定位</h3><p>就跟高考一样，最后一道总是给清北的学生留的，自己什么水平，心里要有点数，研究到那个境界自己感觉就是不行了。赶紧放过，说明你现在功力不够。4级螳螂能打过6级盲僧吗。</p><h3 id="多定短期计划"><a href="#多定短期计划" class="headerlink" title="多定短期计划"></a>多定短期计划</h3><p>我定了这俩月学大数据。这就是我的计划，这行吗？这不行。这样下来其实也是浑浑噩噩的。计划尽量缩短，最好按天指定（虽然比较难）天不行就周，找到一个时候自己的计划。比如这周我只学习Hadoop，具体在划分，每一天应该学习Hadoop哪块知识。要做到当日事当日毕。</p><h3 id="学习要讲究效率"><a href="#学习要讲究效率" class="headerlink" title="学习要讲究效率"></a>学习要讲究效率</h3><p>去图书馆的一定学习好吗？<strong>学习时间≠有效学习时间</strong>。这个大家应该都是认同的。不要装模做样，该学学，该玩玩。我说说我的情况吧，我也是个普通人，不是什么学霸什么的。我也会犯困，走神，但使用一些技巧还是可以尽量去规避的。我上午一般会看一些理论性的东西，早上也是最清醒的时候。恰好这些东西又会比较枯燥，容易犯困。下午就看一些学习过的东西，做一些实操之类的。中午吃饭之后，有条件的趴个15分钟也是有用的。我就容易在1-2点这个时间段犯困，容易点头（回到了高中的感觉）。去克服这点不是那么容易。通常我会去个厕所，看看风景，站一站。千万别通过自己意志硬抗过来，扛过来的我相信戒烟，戒lu什么的不是问题。有这意志力还会犯困吗？俩月下来我也在这方面做的比较好吧。我知道我不是前者，只好只好想点办法，我中午吃饭后会多喝热水，通常该你醒的那会儿也就有感觉了。这个优先级还是很明显的，我相信少部分人会憋着一直睡吧，反正我是做不到。</p><h3 id="养成写笔记的好习惯"><a href="#养成写笔记的好习惯" class="headerlink" title="养成写笔记的好习惯"></a>养成写笔记的好习惯</h3><p>我以前也不写，认为有这时间我还不如多看点东西。后来我发现，当我用到某个知识点的时候，就是知道我学过，没地方找，不知道这种情况你们遇到过没，我反正多次深有体会。养成一个习惯不是那么容易的，好的习惯通常前面需要强制培养，我写笔记的习惯也是导师逼我写的，每天必须有产出。原先我还很反感，慢慢发现，这个习惯是真的好。现在我无论是学习，还是读书，都顺手写点东西。写笔记不是为了交代谁，就是给自己看的，所以说也不用多么华丽，记得多么官方，<strong>哪怕别人看不懂你笔记，自己能看懂就行了</strong>。如果能把别人的东西按自己的理解翻译出来，那么这么就算你掌握了，到时候忘了也就是翻出来看一眼的事情。我是一个实践主义者，不喜欢形式化的东西，写笔记这个习惯也让我切实的感受到了它的好处。如果你因为我这段话加入进来，我相信你将来会感谢我的。</p><h2 id="做的一个小项目"><a href="#做的一个小项目" class="headerlink" title="做的一个小项目"></a>做的一个小项目</h2><p>我最后做了一个指标监控的小项目，其实也没用到大数据的多少东西，主要是功力不够。</p><p>时间紧，还有很多值得扩展的地方，效果如下</p><p><img src="https://pic2.zhimg.com/v2-a30a3b1661186ba7bbfb0c34e1b5b989_b.gif" alt="img"></p><p>下面是用到的技术栈（公司不准用IDEA开发，最好还是用IDEA）</p><p><img src="https://pic3.zhimg.com/v2-5ae274922956b95dfcd2e2bbd442b7f6_b.png" alt="img"></p><p>从0到1如何做这个项目的文章链接：<a href="https://juejin.cn/post/6908223829039022093">https://juejin.cn/post/6908223829039022093</a></p><p>附一个github的地址：<a href="https://github.com/bigli97/computer">https://github.com/bigli97/computer</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我写文章的一个出发点是站在一个讲师的角度尽量的去让大部分人理解。其实学习最重要的不是学到了什么知识，更重要的是套路和方法，高中的物化生或许对我已经没什么用了，但始终有用的就是解决问题的逻辑与思路。我并不能保证我在IT行业能干多长时间。学到的知识或许不是一生受用的，但如何学的或许是。</p><p><img src="https://pic3.zhimg.com/v2-564372ed3f4e08ed4248f3912ed60782_b.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人见解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
